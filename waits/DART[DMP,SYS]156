COMMENT    VALID 00128 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00039 00002	 VERSION VERSI6 IOVER IOVER2 IOVER3 VERMSK LEDONE LEDZER CONDAR CONFMT LL3TAP LL3DMP LL3FT LL3FSZ LLEAD3 FL A B C D W X Y Z K L Q R S TX P FILE UFD MEM MTA INDIR LST DSKMSC DSKMEM REAPCH MTA2 DSKBAK COPLOG STATCH UDPCHN PDLEN IPDLEN NBUFS NBUFSX INTTTI ALTMOD KMCSW UDPSW PPNDIV PPNADD PPNCHR NTTAPE FTLUFD NTTAPE UDPCSW ZZ UUO
C00053 00003	changes  History Bugs
C00129 00004	Tape Format
C00139 00005	Database Format: DART.DAT, DART.ARC, INDEX.DAT, INDEX.ARC 
C00149 00006	flag bit definitions 
C00154 00007	command syntax 
C00158 00008	magtape parameters	MTNOOP REWIND BACKR UNLOAD BACKF SKIPR SKIPF WREOF WBLANK SKIPT SLICE0 SLICE1 IOIMPM IODERR IODTER IOBKTL IOEOF IOACT IOBOT IOTEND IOPAR DE6250 DE1600 DE1601 DEN800 DEN556 DEN200 IONRCK IOWC IMODE 
C00161 00009	disk parameters  (Stanford)  DDNAM DDEXT DDPRO DDPPN DDLOC DDLNG DREFTM DDMPTM DGRP1R DNXTGP DSATID DQINFO DQAUT DQVER DDWPPN DDOFFS  UNAM UEXT UPRO ULOC ULEN UTIME UREFT UDMPT UQINFO UOFFST
C00167 00010	data storage	PRMERR RDHMSK TAPMSK RDLMSK DATMSK RDHBTS RDLBTS RDHPOS RDLPOS INFOSIZ RECSIZ BRCSIZ  RDHBTS RDLBTS RDMAX RDHPOS RDLPOS CRESTA CREST1 RRCSZ RRCSZ2 NRRCSZ WRCSZ WRCSZ2 NWRCSZ LKBLK GOBBLK STRUCT SYSPPN ERSPPN UFDEBK DAWPRV PROPRV REAPRV WRTPRV AAOPRV INFPRV LUPPRV LIVPRV DUMPRV DUMPER DUMPER DUMPER GOD RDOFFS WROFFS DUMPER GOD UUOCON CRLF PDLIST IPDL ONEPPN MFDPTR INVERS RDVERS TAPCLS THSTAP GLOTAP FSPTR DEST TBASE DEFDEV DEFPPN IDEV INAM IEXT IPPN FDEV FNAM FEXT FPPN STKPPN STKDEV STKBIT MTDEV MTNAM MTEXT MTPPN RSTDEV RSTNAM RSTEXT RSTPPN LSTDEV LSTNAM LSTEXT LSTPPN FILBLK LASSAV DSKMM0 DSKMM1 DSKMM2 DSKMM3 XDMPUT RHDCOP RHDLEN RHDART RHTYPE RHDATE RHDPPN RHDTAP RHDNBR RHDPOS RHDRES RHDONE RHDZER RHDCHK HEDLEN HEDLE0
C00180 00011	more data storage		TAPERR CHKERR CHEIOR TSTERR MTRERR MTRSHR TOOLNG TOOSHR SHRTGO UNEEOT BADWCW CONDFF CONNBG BADFMT BADDAT  FLSDPS OMMNAM OMMEXT ODNAME REPCNT LOGPPN USRPPN DBGNTP DBGMFC DBGPPN TAPREG TAPREG AMBIG SAVDEL IWC WC FWC FSIZE IFSIZE MASCOP NOLIST MASDAF NOSAVM PRVPPN FSTRT TABORT TSKIP TSKIPN TSLICE SLILVL NREADS SAVBKN SAVNS3 LASTIM RECERR SRCDEV FILINF CONDEV CONINF QMODE CHKSUM STRNAM UNQSTR THSDAT THSDAX MTTREC MTFILN FIXCNT FIXSEA COPPED LCWRNF FILERS DARTHD BADHTR LMEDER PRMEND LMEDE1 REDERR MEDERR MRGERR ERDESC MEDPTR PSTDAT MLBAD MLGOOD MRETRY MNRET MXRET DRETRY NRETRY LRETRY SKIPFL REHARS
C00194 00012	more data storage		 FONYFI TTYWRD PRMOK HEDSTR SVHDAT CLASS TAPNO TAPNAM OTPNAM PICKON MRTPNO STAPNO GOTALT DATDAT SPPN SNAME SEXT DTAPPN TRANGE TNAME ANAME AEXT DNAME DEXT DNAMEO MEMWC MEMWC1 MEMWC2 TPTR MTAPNO TNX DNX MMNAM MMEXT MMDAT MJBFF TNWRM1 TNWRM2 ALLSIZ TTNAM TTEXT LQUIET RELMCT PPURGE TAPWFL PTCNTL PTCNTP TODAYD PRDATE LASTTD VEFILE VEEXT VEFDIF LASTDT DEVNAM CLNAM TOBUF TIBUF REDOPN WRTOPN MBUFLG FIBUF FOBUF INDRBF LSTBUF UFDBUF PDATE PDATEH PCOUNT PTAPEN PDDATE PINVAL MONTAB RRD RRD1 REAPLS REAPOP LOGBUF LOGPTR LOGBP REAPNM LOGCMD NOREAP UPDRET ILLFMA ILLFMB INPMOD DENMOD RWMODE DENDAM IDXBEG IDXEND IDDDAT IDDAOB IDADAT IDAAOB LMTFDA MTFDAT MTFFIL MTFEXT MTFPPN MTFBEG MTAFMM MCLNAM MCLCOL MCLCNT MCLBP MCLOPN MCLREC MCLWID LMCLBF MCLBUF BRENDP STATLN STATBF STATFR STATBP STATSU STATLG UUOBLK DBLLEN DBLBUF DBLPTR DBLCNT NCPFIL CPFIL CPEXT CPPPN PCPFIL
C00208 00013	magtape buffers for input and output  DCLASS CHKNUM MSTRNA MMTDEV TAPNUM FUSER FFILE FFEXT LUSER LFILE LEXT PTRSAV MERGFL TTCNT MTAPOS MT2POS MTQPOS MTFPOS MTEPOS MTOPOS CUSER CFILE CEXT MCITAP MCOTAP TAPDMP RELABS REEABE MT2FIL MT2FI2 MTAFIL MTAFI2 DTAMAX MTAEOF MT2EOF MTAIRG MT2IRG MTAWRD MT2WRD ITEPPN DTAOOO MTADFI MCODFI MTADFE MCODFE MTEDFI MTEDFE MTCLPE MTCPER MTCENT MTCMIS MTDCMS NMECNT NSYSCT CHKSUE MTIDAT MTLOSE MTWIN NBRAND TBRAND  NMTBFS MBUF1 ALTBUF MBUF2 MBUF3 MBUF4 MBUF5 MBUF6 MT2BUF ALLPTR REELPT MTREDO TAPBLK MEMBLK ALLBUF REELBF MEMSAV NSYSCT LBRAND TXTECT TXTECT TCIEC2 MTFOOT LSISIZ REDDEN WRTDEN REDIRG WRTIRG REDEFL WRTEFL MTIRGL MTEOFL MTALTB MTDPYD MTLIRG MTLEOF MTLWRD MUDPYD NAMSPL NAMSPL NAMSPL PPNSPL SPLFOR SPLREQ SPLJOB SPLDEV SPLSIZ SPLTIM SPLNAM SPLPPN SPLBIT SPLIOW UUOTMP
C00225 00014	more data  DDCMD DDBUF IIIBUF DMBUF BUFBUF DDDAT DDDEND DPYEND DPYHDR LINSAV DPYSXS TPGNUM TPGPDP TPGFLG TPBUF MAXLEN MAXLEN ARCCMD DATWC IDXPDP IDXPDL ARCWC ADXPDP ADXPDL LSTRPP LSTIPP ALTRPP ALTIPP DATIDX ARCIDX MRBASE MRSTDV MRSTNM MRSTET MRSTPN ALTLST NODDSP SWITOK PUMPCM DAY MONTH YEAR PBASE PIOWD LOCLUK TAPES RTAPES TRMCNT LASTW OWNER PRIVS UPPN UPRG ALIAS PRUIOW PRUFNM DDTADR DDTSVA DDTSVB PRSAVP PREQTP UNP2QF PUMWIZ PREALW PRLSTW PMULTF PFDRIP RETRYC TLISTC SAWEOF TELEOF GOTDOT TELDAT RMDWAK RMDSYS PRVMTA PRVBUF PASWD PRIVWD GRPWD REGRST CMPRST POSRST PUMRST PLBUF UNPUTR UNPBUF PATCH PATCH1 PATCH2 PATCH3
C00239 00015	error messages		 ILLSW2 ILLSWT NOCORE NODEV NODEV0 NODEV1 NOLOOK NOLOO2 NOMTA ILLPPN ALLIND ALLDEV SYNTAX ILLFMT ILLFM2 ALLLST NOENT LSTERR INDERR UFDRER DSKRER NOPRV PURERR NOTDSK MTSAME OPNERR ILLDST NOBACK NOOUT FILETB NFLERS
C00245 00016	display service		 DPYSER DPYSE2 NODPYO NOQUES NODPYF CVFOOT TYFOOT TYPFOO DPYFIL DPYFL1 DPYREL DPYPPN DPYPPR DPYSIX DPYSX1 DPYDEC DPYPPO DPYOCT DPYSER
C00254 00017	dump a data file to tape	 DUMP DUMP2 DUMP0 DUMP0 DUMP1 DUMP4 DUMP3 DXTAB DUMPX0 DUMPX1 DUMPX2 DUMPX3 DUMPXX DUME TAPHED TAPTAI TAPHD0 NXTOBF TIMDAT WRXINF WRXIN2 COLEAD
C00272 00018	restore a data file from tape.  RDFIL RDFI00 RDFIL0 RDHED RDHED6 RDHED9 RDHED7 PRVMTM RDHED8 RDHED5 ISWLUP ISWRNX ISWRN0 CHKPHD ISWRNG WRONGO RDHHAK RDHPRV RDHEDP RDHED2 RDFISS RDFILX RDFILS RDFLX1 RDFLX2 tibufc FMTCHK FMTCH0 FMTBEG FMTBE2 FMTBE3 CPOPJ4 CPOPJ3 FMTBE4 FMTCON FMTCO3 FMTCOE FMTCO2 LENCHK RDERR0 RDER00 RDERR RDERR1 RDER11 RDCON RDERR2 RDERR3 RDERR4 FAKEDV FAKEFI ERREXT MKTURK WRECK1 WRK1 WRECK2 NODART NOHDTR ROTCHK ROTCHL TSTONE TSTZER TSTZE2 MTBFSH RFDB2B RDHED0 RDHED4 RDHED3 PRVMTM
C00331 00019	read a file name from the tape. read tape data.  SRCTST RFIL1 RFIL1A RFIL1B RFIL2 RFDATA RFDT0 UFDWRD NOWRT NENTRY NOTUFD RFDT1 RFDT1A RFDT2 RERDAT RERDAL RERDA2 TYPMER TYPMEL TYPMEX DECOTT RFDTER RFDTCN RFDTEE RFDT3 RFDT3B RFDT5 RFDT6 DDFWRT DDFWR1 DDFWR3 RFDT2L RFDT2S RFDT22 RFDB2S CKPAUS GETCON GETCO1 PPNCHK PPNCHL PPNCH2
C00351 00020	write tape	  TWRITE TWRIT0 TWRIT1 TWRIT2 YMTA1 TWREOT TWRIT4 WRLOCK
C00354 00021	read tape		 TREAD TRELUZ TREADZ TREADX TREADW TREADY TREAD0 TREADU TREAD1 TREAD2 TYRSTA CLNRCK ALNRCK ALNRC2 DECRET DECRE0 DECRE3 DECRES INCRET DECRE2 POPAJ TRLEOT REOTAP REOFIL REOFI2 TAPEND MTAOPT IOBUFH MTINIR MTINIW DENCHK DENSOK NOMTA0 MTINWS MTINRS NOMTAD STFOOT DPMTA DPMTA2 BUFSET BUFSE0 BUFSE1 NMTBFS LBFHDR BU2SET BU2SE0 BU2SE2 BU2SEW MINIT1 MTERR SHRTBF DARTER DOSKIP DOSKI2 DOABOR DOABO2
C00389 00022	low level mta i/o routines  MTAOPE MT2OPE MTACLZ MT2CLZ MT2CL2 MT2CTS YMTA2 NOMTA2 mt2not MT2CT2 TWRERR MTAINP MTAIN0 MTAIN2 MTAIN3 MT2OUP MTABOT MTANOP MT2NOP MTAREL MT2REL MTAREW MTARE2 MT2REW MT2RE2 MT2FOO MTAUNL MT2UNL MTASKR MTASKF MT2SKF MTABKR MTABKF MTASKT MTARET MOUTUP MOUTU2 MGOTWC MEOFUP MWRDUP SEVTRK
C00445 00023	disk i/o for data files	 DFREAD DFRED1 DFRED2 DFREDQ DFREDX DFRED3 DFRED4 DFWRTX DFWRIT DFWRT1
C00452 00024	disk i/o  - indirect read - directory read - listing write	  RINDIR RIND1 RIND2 RIND3 RIND4 LSTSTR LSTST1 LSTOUT LSTOT1 UFDRD UFDRD1 UUFDRD UUFDR1 UUFDR2 INDOUT INDOU1
C00459 00025	check after a lookup - parms in filblk	  LCHECK LCTYPE LCTAB LCBUSY LCNAME LCNOLK LCNOOP LCBRET LCUNA LCILPR LCNFL0 LCNFL1 LCEXIS LCEXI0 LCNOFL LCILUS LCILU1 LCILU2 LCILU3 GETGO GETGO0 GETGO1 YORN GETWRD GETWR1 GETWR2 GETWR5 GETWR3
C00470 00026	some type out routines	  DECOUT TYPOCH TYPOCT TYPOC1 OUT.CH STROUT DISLOT DISLOC OCTCOM OCTOUT SIXOUT SIXOT1 SIXFIL SIXFL0 SIXFL1 OUTFIL TYFIL TYFIL1 PPN0 PPN6 PPN61 PPNOUT PPN8 PPN1 PPN2 PPN3 CTYPPN CTYPP2 CTYOUT CTYMES TYTIME TYFDAT TYDATE TYWHEN TYWHE0 TYWHE2 TYTMDT
C00482 00027	initialize - command dispatch  RESTAR START NORAID STARTP STARTX CMD CMD1 CLRCON CLRCNT CMGET NODPY CMGET1 CMGET2 CMGET3 NOTYET AMBIGC ILLCOM ILLCM1 COMTAB COMTB1
C00505 00028	ddt call and monitor startup	  DDTCOM DDTGO NODDT MONCOM FLUSH FLUSH1 MAXSET
C00510 00029	rewind, eot, advance, backspace	  REWGO UNLGO EOTGO ADVANC BACKSP ADVAN1 ADVAN2 ADVAN3 ADVAN4 ADVGO BACK1 BACK2 ADVCM NUMTST NUMTS1 NUMTSX ADVTO ADVTO2 ADVTO3 POSWIN FIFOOT POSLUZ
C00522 00030	tlist, list commands	  LSTINI LSTIN0 LSTIN1 LSTIN2 LSTBIN LSTBI0 LISTGO LSTLP LSTLP1 NEWDT0 LSTLP1 LSTLPY LSTLPX STOPIT LSTLP2 LSTLP3 LSTFIN TELDMP TELDM0 TEMDMP DALISC DALIST DALIS0 DALISF DALISE DALISX NEWDTA DTAEXT DRADMP
C00544 00031	dump, nodump, reap, unreap commands	  NOREPD UNREAP REAP NODUMP SETCLR DUMPGO SETCL2 DMPG1 DMPG2 DMTERM DMTER1 DMTR1A DMTR1B DMTER3 DMTER2 DMTALL DMTAL1 DUMPG4 DUMPG3 IDENSI IDENS2 DENSIT DENTEL DENTE0 DENLOK DENTE2 DENTEX DENSI0 DENLOP DENILL DENNAM LDENNA DENN78 LDEN78 LDEN SDENDA SDFTDN EOFON EOFOFF
C00561 00032	dump one file to tape	  DMTHIS DMPLKP DMTHIX DMTHX0 DMTHIY NOMTA5 NODTHS STANOD NSTNOD NSTNO1 REAPER UNRPER DMRED0 DMREDO DMRED1 DMRED2 DMRED3 NOMTA7
C00573 00033	process a dump term with wild specification.	  DMALL DMALLD DMALL1 DMALL2 DMALL3 DMALL4 DMALL5 DMALL6 DMALL8 DMALL9 DMAL10 DMAL11
C00580 00034	wildcards for non-sail version, does multiple structures	  DMALL NXTSTR DMALLA DMALLX DMALS1 DMALLS
C00586 00035	process wild file names inside one ufd	  D1PPN DMONE DMONE1 DMONE4 DMONE2 DMONE3
C00593 00036	dump wild specification from udp.	  UDMALL UDMAL1 UDML1A UDML1B UDMAL2 UDMAL3 UDIRER
C00600 00037	copy old udp to new udp	  UDPCOP CUDMAL CUDML1 CUDML3 CDMTHS ECONT RWLOOP RWEOF CMDTHT READ1 WRITE1 ECHECK EFAIL
C00610 00038	dump kmc udps  KMCDMP KMCDM1 KMCDM2 KMCDM4 KMCDM3 DMPKMC KMRED0 KMREDO KMRED1 KMRED2 KMRED3 KMCBUF KMCERR KMCER1
C00620 00039	pumpkin queue format/unpumpkin	  UNPUMP PLIST PRESTO PREST1 PLIST0 EUQMSG EUQPLI NOPEUQ DOEUQ PREQLP PREBLK PRDTLP PREDEL PRDTDN PRDTNX NEWTAP PREOF PRNXTT EUQFIX WEDID DIDNT EUQNXT EUQTST IABORT ISKIP ITOGGL INTRPT INTRPX INTRPI INTRPS INTTSL RETRY EUQPRT EUQNIL PRNXT1 RETRY0 PRSTG3 TFLUSH PRUEOT PRPOSN PRPOS2 PRPOS3 PRUSER PMAIL PRUSE0 PRUSE1 PRUFLP PRUFNX PRUTA1 PRUTAP PRUMAI PRUMA1 PRUTRY PRUMER PRUNXT PRUEND PROPRN PRSKPL PRFNDT PRFND1 PRFND2 PRSKLP PRSKDN PRFND2 PRJUMP PRJUGG PRSKPT PRSKNO NOPQUE NOPREQ QUEERR PRUEOF DELEUQ PYORN PYORN0 PYORN1 PRUSTR PRUST1 PRUSIX PRUDEC PRUDE1 PRUDAT PRLFIL PRUFIL PRLFI1 PRUFD0 PRUFI0 PRUF01 PRUF00 PRUFI1 PUX0 PKLU PUXSTR PNOT PTNF PTNR LPUX UNP2QS
C00667 00040	pumpkin list		 PLIST1 PLIST3 PLIST2 UNPUM1 UNPUM3 UNPUM2 UNPUM5 UNPUM4 UNPUM6 UNPUM8 UNPUM7 UNPUMA UNPUM9 UNPQLP UNPBLK UNPHIT UNPHI1 UNPURD UNPUR1 UNPUIN UNPUI1 UNPEOF UNUEOF UNPLUZ PGETNO PGETN1 PGETN2 PGETN3 DDTKLU DDTENT
C00682 00041	locate and pumpkin	 PUMPKI PUMPKI PUMP0X PUMP00 DLOCAT PUMP01 PUMP0 PUMP11 PUMP21 PUMP1 PUMP2 DLOC1 DLOC11 LOC1A PLOC1A DLOC20 DLOC2 DLOC22 DLOC2 LPPADV LOCPPS LOCPP1 LOCPP2 LOCPP3 LCPP3A LCPP3B LOCPP4 LCPP4A LCPP4B LOCPP5 LOCPP6 LOCPP7 LOCPP8 LOCPP9 LCPP10 LCPP11 LCPP12 LOCFPD LOCFPA STWILD
C00704 00042	locate/pumpkin printer	 LOCFPR LOCFP0 LOCFP1 LOCFP2 LOCFP3 LOCFP4 LOCFP5 LOCFP6 DRATL1 LOCFP7 LOCF7X LOCFP8 LOCF9U LOCF9T LOCF9Y LOCF9W LOCF9V RELOOK ACCOK LOCLKF PBUSY PNOACC PNOAC1 PNOAC2 LOCF9X LOCF9D LOCPRO LOCTRM LOCF9Z LOCF9E LOCPRE LOCHL2 LOCGO LOCUSE LOCOK LOCIGN LOCHLP LOCF8Z LOCF8Y LOCFPX LOCFXX LOCFPZ LOC9 LOC9A LOC9B PFIFP7 LOC9Z PPNPOS PPNPS1 LCPPCK LCPPC1 LCPPC2 IDXPCK IDXPC1 LOCRD1 NEWARC LCR0.0 LCR0.1 LCR0.2 LCR0.3 LCR0.4 INDGET INDGT0 INDGT1 INDGT3 INDGTX CREARC LOCFIN LOCFRT PUMXIT PMPLUZ NULPUM ACCCHK OWNACC GRPCHK GRPWIN SCDIDX FDATIM
C00750 00043	tape-to-tape copy	 WCWD DVWD CKWD UCOPY MCOPY MCOP00 MCOP01 PTLUP MCOP02 UCOP0 MCOP0 MCOP0C MCOP0D
C00760 00044	tape copy -- report MCOPY status  TELMCP TELMCA TELMCB BADPIK MCOBAK MCONFW
C00767 00045	tape copy -- just starting MCOPY  NOMCOP TCPIKS MCONLY
C00770 00046	tape copy -- sort DTAPES.DAT by PPN  DTSOR0 DTSORT DTNXT DTPPN DTPTR DTLEN DTSPPN DTSPP2 DTSCMP DTSINS DTSINL DDREAD DTSEO2
C00780 00047	tape copy -- DTAPES.DAT sorted, now write it out  DTSEOF DTWPPN DTWROK DTWLOO DTUEOF DTWERR DTPDU0 DTPDUN DTPDU2
C00789 00048	tape copy -- request input or output tape mounting  MCOMNT MCIMNT TPHNAM MCREIN
C00796 00049	tape copy -- resume MCOPY, restore all positions  MCOPGO MCOPG2 MCOPG3 MCOPG4
C00802 00050	tape copy -- new output tape and main file loop  TCNXTO TCFSTO TCPIK0 TCOPFI TCOPF0 TCOPF2 MINREC TCOPF3 TCOPF4 TCOPF5 TCOPDP
C00812 00051	tape copy -- misc. subroutines  NEWERR CHKFAK VALDAT VALDA2 VALDA3 VALDA4 VALDA5
C00819 00052	tape copy -- check for new input dump  TCOPND NEWIDE TCOPN1 TCOPA0 TCOPAD
C00826 00053	tape copy -- add file data to DTAPES.DAT  TCOPDT TCOPD2 TCOPD3 TCOPD4 ADJDAT CKDATE POPABJ DMPPN0 DMFIL0
C00835 00054	tape copy -- hit logical end of input tape  TCLEOT TCOPUE
C00841 00055	tape copy -- logical end of input tape in MCOPY  FS3600 MCLEOT MCLECL MCLEFL Counts TELWIN
C00856 00056	tape copy -- finish handling end of input tape  FTLIFT MCLEO2 TCPIKA MCLEO3 TCPIKA TCPIKB TCPIB2 TCPIKC TCPIKD
C00862 00057	 Counts NOPTC MCNEWI BRANEW BRANDL GBRAND GBRAN2 GETBRN GETBOO GETBCR GETBXT
C00869 00058	tape copy -- printing subroutines  DECAB COL10 COL9 COL4 COL3 TYPPER TYP100
C00875 00059	tape copy -- copy Dart header or trailer  TCPHTR TCPHT2
C00883 00060	tape copy -- write EOF on output tape  NEWMTF NEWMT0 POPAJ1 NEWMTT
C00889 00061	tape copy -- hit physical end of output tape  TCPEOT TCPIKX TCPIKY
C00895 00062	tape copy -- error routines  TCPARE TCPIEE TCPIRE TCPIRF
C00901 00063	tape copy -- remember new pickup point  STOIFN STOIF2 STOIER WIZGO
C00909 00064	tape copy -- store pickup code and write DART.MEM  MASPIK MASPI0 MASPI1 MASPI2 MASPSE MASPIE MASCU0 CONFRM CONFR2
C00918 00065	tape copy -- process terms in command line  TCOPTM TCOPT1 TCOPT0 TCOPT2 TCOP2A TCOPT3 TCOPT4 ILLMUL ILLMT2 ILLMTP
C00923 00066	tape copy -- misc. subroutine  FS6250 US6250 INCDMP SWPJST LJUSTH LADJ PMTCLP GETECT GETEC0 GETEC2 GETEC3 GETEC4 GETTAB
C00931 00067	tape copy -- adjust slice level  MTCBKN MTCNS3 MTLOS2 SLIWIN SLIINI SLRMIN SLICHK TOGSLI TOGSLC
C00936 00068	tape copy -- re-position output tape  MFIXO
C00942 00069	tape copy -- re-position input tape  MFIXIB MFIXI MFIXI2 MFIXIE
C00950 00070	tape copy -- compare file found with terms given  TCOPMT TCOPM0 TCOPM1 TCOPM2 TCOPM3 TCOPM4 TCOPM5 TCOPM6 TCOPUF
C00957 00071	tape copy -- pickup-point definitions and documentation  NOITAP NOIFIX NOOTAP NOOFIX NODTAP MCPIK$code MCPIK MCPIKT
C00967 00072	tape copy -- copy input tape file to output tape  TCDUMP TCDU2 TCDU0 TCDU1 TCDU4 TCXTAB TCDUX0 TCDUX1 TCDUX2 TCDUX3 TCDUXX TCDUXY TCDUME FAKERR TCOPI0 TCOPI1 TCOPI2 TCOPI3 TCOPIN TCOPS0 TCOPS4 TCIADJ
C00983 00073	tape copy -- errors during copy of tape file  TCOPSS TCOPS5 TCOPS3 TCOPS2 TCOPS6 TCOPIE
C00989 00074	tape copy -- check checksum, handle previous media error data  ICKSU0 ICKSU1 ICKSUM ICKSU2 ICKBAD ICKBA2 ICKICK SERDAT SERDAL SERDA2
C00998 00075	check file-continuation block  IWCCHK IWCER3 IWCCOA IWCCO4 IWCCO2 IWCERR IWCER2 IWCER4 IWCER0
C01011 00076	continuation block with different filename  CONDIF
C01016 00077	recover from bad continuation block  BADIWC BADIW0 BADIW2 ZERERR ZEREND TYBWCW
C01025 00078	initialize DTAPES.DAT  DTDINI DTDRAM
C01031 00079	tape copy -- re-position output to DTAPES.DAT  MFIXD MFIXD4 MFIXD2 MFIXDE MFIXDI
C01038 00080	tape copy -- bugtraps for word count and filename  IWCDBG DUPCHK DUPLUP DUPDIF DUPINI
C01044 00081	logging of master tape copy typeout  MCLINI MCLIN2 MCLEMP MCLIER UUOTRP MCLHLT MCLCH0 MCLCHL MCLCH2 MCLCH1 MCLCR MCLINS MCLTAB MCLSIX MCLSI2 MCLCHR UUOXFC UUOXIT UUOXI0 MCLSTR MCLSTL MCLFRC MCLCHI MCLCLR PPSAV PPSAVX PPSAVE PPSAVP REENTD REENTE MCLREX DBLOG0 DBLOG1 DBLOG2 DBLOG3 DBLOG4 DBLOG5 DBLOG6 DBLOG7 DBLO10 DBLO11 DBLO12 DBLO13 DBLO14 DBLOG DBLOGA DBLOGB DBLINI
C01067 00082	count files on each P tape, for Master Copy  PTCNT PTCNT1 PTCNTR PTCNT2 PTCNTE PTCNTF
C01076 00083	tell who last used a tape	  TURKEY TURK0 NONMBR TURK1 TURKL TURKL1 TURKL2 TURKD NOTURK NOBODY
C01083 00084	read sixbit command, file name, etc  Delim Spopj1 Spopj2  XGET6 GETSIX GETSX1 XGET6A QSET GETSX2 GETSX3 CPOPJ2 CPOPJ1 MAKLF CPOPJ SEMICO SEMIC1 SEMIC2 BLANK STAR ILSTAR ILLEG ILLEG1 DEVSCN DEVSC1 NUMCHR RDNUMB RDNUM0 RDNUM1 RDNUM2
C01091 00085	switch scanning stuff for pumpkin command	  SWTCH0 SWTCH SWTCH3 MASDA0 GOTMON GETYR REBILD EXYEAR SYSYR SLRET MASDAP HYPHEN MONSIX MMDDYY SIXNUM SIXNU1 SIXNU9 SIXTAP BADATE MASDAE MASDAT SIXTA1 SIXTA2 RRLDMP RRLDM2 SWRELD
C01105 00086	character table for command processing	  CHRTAB
C01111 00087	read a ppn	  RDPPN RDPPN1 RDPPN2 OCTPPN OCTPP1 SIXPP1 SIXPPN RDPPN9 RDPPN9 RDPPN3 RDPPN4 DPOPJ RDPPN5
C01118 00088	get FS block	  GETBLK GETBK1 PGTBLK PGTBK1 TGTBLK TGTBK1
C01123 00089	scan dump, restore, locate, pumpkin commands	  SCAN SCAN1 SCAN2 SCAN4 SCAN4A SCAN4B SCAN7 SCAN8
C01132 00090	more scan - indirect commands.	  MSCAN MSCAN1 SCAN8A SCAN8B SCAN8C SCAN8D SCAN9 SCAN9A SCAN9B SCAN9D SCAN9E SCAN9F SCAN9G INDFLU INDFL1 INDFL2 SCAN10
C01142 00091	documentation for system dumps 
C01150 00092	pickup dump after a system crash  PICKUP NOPICK MCLOUT LOKOUT TBEGOK TABPIK PICKP1 PICKP3 PICKP2 PICPNT TABPNT
C01159 00093	system class dumps  fdump, pdump, tdump, purge	  PURGE PURGE0 FDUMP PDUMP TDUMP TDUMP1 PDUMP1 PDMP2Z PDUMP2 PDMP2A PDUMP3 GETSTR JUST1S STRPIK NNSTR NNST0
C01170 00094	dump an entire file structure	  DMPSTR DMPST0 DMPST3 DPIK2 DMPSTW DMPSTZ DMPSTY PIK6 DMPSTX DPIK1 DMPST1 DMPST2 DPIK3 DPICKT DMPSTP DMPSP0 DMPSP1 DMPSP2
C01183 00095	dump files from one ufd  GETUFD GPUR1 GPUR2 GETUD1 ALLINI GETFIL GETFL1 GETFL2 GFLOOK GFTEST GFALLM GFPTS3 GFPTST GFPTS1 GFPTS2 GFTXL GFDUMP GFDMP1 GFDMP2 GFDP2A GFDP3A GDP3AA GFDP3B GDP3BA NNFIL GFDMP3 YMTA3 GFDMP4 GDP4BA GFDP4B GFDP4C GFDP4A TAPCMP TAPCP1 FIXPDU PUTEST PUTST0 PUTST1 PUTST2 MONTHB DATCNV REAPLG LOGIT0 LOGZ0 LOGOUT LOGZ REAPL2 REAPLX REAPSR REAPS1 REAPOU LOGOK REAPCL
C01220 00096	what to do at end of tape	  GFREDX GFREDO PIK4 PIK5 NOMTA8 GFRED1 GFRD1A GFRED2 PIK0A GFRED4 GFRED5 GFRED6 GFPICK PIK0
C01229 00097	read in the mfd and sort it.	  MFDSOR MFDSR1 MFDSR2 MFDS21 MFSOR0 MFSOR1 MFSOR3 MFSSOR MFSSR1 MFSSR2 MFSSR3 MFDSR3 MFDSR4 MFDSR7 MFDSR5 MFDSR6
C01239 00098	preservation of dumping information  ALLMIN ALLMI1 ALLMI2 ALLMEM REELMX REELM0 REEL00 REELM1
C01247 00099	save dump status for pickups.  SAVMEM SAVME2 SAVME4 SAVME6 SAVORA SAVME3 SAVME5 SAVME7 RDMEM RDMEM2 RDMEM3 CHKLOK SAVINP SAVOUP SAVILL SAVINL SAVINE SAVINO
C01257 00100	split ALLDIR.MEM		 SPLIT SPLIT1 SPLIT2 SPLIT3 SPLIT4 SPLIT5 SPLIT6 SPLIT7 SPLITX SPLITZ SPLITA SPLIT8
C01267 00101	merge DTAPES.DAT and DART.DAT  D DEOF DNEED RT TNEED RD DNEED TNEED MANCMD MANCM0 MANCM1 MMERGE MANMER MANME2 MANTAP EXTRACT EXTRC1 EXTRC2 EXTRC3 EXLPXX MERG00 XMERGE YMERGE ZMERGE SMERGE MERGRT MTSRT1 MTSRT2 MTSRT8 MTSRT3 MTSR30 MTSR3A MTSR3B MTSR3C MTSR3X MTSRT5 MTSRT4 MTSRT7
C01294 00102	merge  MERGRX MERGRY MERGRD MRGRD1 MRGRD2 MRGRD3 MERG1 MERG1A MERG1B MERG1D MERG2 MERG4 MERG4A MERG4C MERG4E MERG4B MERG4D MERG4Q MERG4Y MERG4X MERGRZ MERGZ0 MERGZ1 MERGZ2 MERGE MERGE0 MERG99 RENDAT
C01308 00103	merge  PPNCMP PPNCP1 PPNCP2 PPNCP3 UIDXBW UIDXBG USET10 USET11 UIDXND UIDXFR UIDXIN UIDXWT SKPIDX SKPID1 RDIPP1 RDIPPN
C01318 00104	reel text file output routines  DMFRC0 DMFRC DMFRC2 DMINI DMINIP DMFINI DMINIC DMPUTE DMPUT1 DMPUTX DMPUT TPGDON TPGCLS DSMOC1 DSMOC2 DSMOC3 DSMPPN DSMPPO DSMPPN DSMSX2 DSMSX1 TPGPUT TPGPU1 TPGPU2 TPGPU3 TPGINY TPGINI TPGINX DSDATE DDDEC DMSTR DMSTR1 SPOOL SPOOL1 SPOOL2 SPOOL3 INTSPL INISP1
C01332 00105	merge -- read and write data  TNREAD TNRDR1 TNRD3 TNRD1 TNRD2 UFDCNV UFDCN1 MMREAD MMRED1 MMRED2 MMRFLS MMRED3 MMRED4 MMWRIT MMWRT0 MMWRT1 MMMWRT
C01341 00106	verify the format of DART.DAT or DART.ARC  VERNAM VERIFY IDXBUF VERDAT VERARC MCPVER VERIDX VERID1 VERID2 VRID2A Data VERID3 VERID4 VERID5 VERPPN VERFIL VERFL1 VERFL2 VERATD VEROOD VERFL3 VERTBG VERPBG VERTB2 VERIEN VEREOF VERNPN VERNP1 Location VERBEF VEREFE VEREF1 VERPNO TWOSAM EXTOOO VEROK
C01362 00107	fix magtape position.  FIXPOS FIXP00 FIXP02 FIXP03 FIXSKP FIXNLP FIXP01 FIXPS0 Found FIXPS1 FIXPS2 FIXPS3 FIXPS4
C01374 00108	get a tape number from dart.tap  GETTAP GETTP1 PUTTAP PUTTP1 PUTTP2
C01379 00109	tell operator what tape to mount.  DOMINP DOMOUNT DOMOU0 DOMOUH ONONEW TELOPR TELOP0 TELOP2 TELMLS TELML2 telop4 TELOP1 TELOP5 TELOP6 TELOP8 TELOP9 NOMTA9 TELP10 TELWCK TELWC1 TELWC2 GETANS GETAN1 GETA11 GETAN5 GETAN2 GETAN3 GETAN4 OPRZER OPRERR
C01398 00110	tell operator what tape to mount for mrestore	  DOMT0B DOMT0 DOMT0A DOM0G2 DOMALT DOMT0G DOM0G1 DOMT1 DOMT2 DOMT3 DOMT4
C01405 00111	archive command	  D A ARCHIVE DNEED ARC.RT ANEED ARC.RD DNEED ARC.TS ANEED ARCHIV ARCH0 ARCCOM ARC0.0 ARC.RT ARC.RD ARC.RL ARC.TS ARC.TF ARCTF1 ARCTF2 LSORT SORTUM SORTON SORTLN NSORT INISRT SRTIN SRTNXT SRTOUT SRTOUL ARC.DF ARCDF0 ARCDF1 ARCDF2 ARC.M ARC.M0 ARC.M1 ARC.M2 ARCM2A A.MAF A.MAF0 A.MAF1 A.MDF A.MDF2 A.MDF1 ARCTS1 ARCDRD ARCD00 ARCDR1 ARCDR2 ARCDR0 ARCDR3 AR.DR3 ARCDR4 ARCDR5 ARCDR6 ARCDR7 AIDXBW AIDXBG AIDXND AIDXFR AIDXIN AIDXWT SKPADX SKPAD1 RDAPP1 RDAPPN ARCB0 ARCBX ARCB1 ARCB2 ARCB3
C01435 00112	mrestore	 ILMRS1 ILMRS2 ILMRS3 MRSDEF MRSLNK MRSNAM MRSEXT MRSPPN MRSLEN MRESTO MRES1 MRESL MRESL1 MRESL2 MRES2 MRESA MRESA0 MRESA7 MRESA6 MRESA8 MRESA9 MRESA1 MRESA2 MRES3 MRTS MRTS1 MRTS2 MRTS3 MRTS4
C01448 00113	mrestore	 MRLIST MRLALT MRLST0 MRLST1 MRLST2 MRLST3 MRLST4 MRLST8 MRLST9 MRSORT MRSRT1 MRSRT2 MRSRT3 MRSCMP MRSCM0 MRSCM1 MRSCM3
C01459 00114	mrestore	 MRTV MTRV1 MTRV2 MTRV3 MTRV4 MTRV5 MTRV5A MTRV5B MTRV5C MTRV6 MTRM MTRM1 MTRM2 MTRM3 MTRM4 MTRM5 MTRM6
C01474 00115	uuo handler	  .UUCON UUOCN1 UUSKP2 UUSKP1 UUORET UPDLOV UUOERR UUTAB UDPINX UDPCHX
C01480 00116	help put the world back together after a tape runs away.   HELPPN HELPER HELP1 HELP2 HLPOK HLPUND HLPEOF HLPFIN
C01486 00117	dreck	reconstruct from wreckage left after the head crash, 12/23/80	  UFDLST CURPPN KEEPPN DRKFND DRKLST DRKDEF DRKLNK DRKNAM DRKEXT DRKPPN DRKLEN DRECK DRECK1 DRECK2 DREK2A DREK2B DREK2C DREK2E DREK2D DREK2Z DRECK3 DREK3A DREK3B DREK3D DREK3Z DRKENT DREKE1 DRKWRT DRKWT1 DRKPUT DRKPU1 LITSRT LITSR1 LITSR2 LITSR3 LITSR4 NAMCMP NAMCM1 NAMCM2 DRKSRC
C01506 00118	test magtape by writing and reading back	  MTTEST MTTES2 MTTES3 MTTES4 MTTES7 MTTES6 MTTES5 MTTES9
C01512 00119	check order of PPNs in DART.DAT-format file	  CHKFIL CHKDAT CHKDAI CHKDAL CHKDAY CHKDAX CHKER0 CHKER1 CHKER2 CHKER3 CHKER4 CHKER5 CHKERT
C01519 00120	disaster recovery stuff (FTHELP)  HENTOK THSUNT RSTUFD UFDCNT UNTPNT NUMUNT NXTUNT NXTUN2 NXTUN3 NXTSPL NXTSYS
C01525 00121	temporary tape copy recovery routines  RECOPY RECLUP RECLU2 RECPEF REPEOT RECPER RECFIC RECFIL
C01534 00122	restore, compare commands	  cminfo COMPGO RESTGO RESTG0 RSTG1 RSTG2 RSTG2A RSTG2B CMPDFT RSTDFT
C01545 00123	more restore, compare code	 RSTG3 RSTG3A RSTG4A RSTG4 RSTG5 RSTG5A RSTG5B RSTG5C RSTG50 RSTG51 RSTG6 RSTG66 RST5DD RST5DZ RST5DE RSTG7 RSTG77 RSTG99
C01559 00124	restore/compare	actually move a file here.  RSTG5D RSTG5E RSTPRE RSTG5H RSTG5G RSTG5I RSTG5n RSTG5G RSTG5W RSTG5X RSTG5F PFILEX RSTG6A PSTKIL PREKIL
C01575 00125	compare -- compare file header info  cmplen cmple2 RFCOMP RFCM0 RFCM1 RFCM1A RFCM2 RFCMER RFCMCN RFCMEE RFCM3 RFCM5 RFCM6 DDFCOM DDFCM2 DDFCM1 cmpend cmpen2
C01589 00126	compare -- report a difference  cmpfll cmpfls cmpflo cmpfld cmpfle cmpflp cmpflc cmpfi0 cmpask cmpgo cmpfi3 diffgo supcmp
C01597 00127	tape copy -- save statistics  PDSTAT PADST1 PADST2 UPSTAT UPSTEE UPSTA0 UPSNEW
C01602 00128	end of file - list of needed features, bugs, etc  DART$ DART$
C01637 ENDMK
C;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ; VERSION VERSI6 IOVER IOVER2 IOVER3 VERMSK LEDONE LEDZER CONDAR CONFMT LL3TAP LL3DMP LL3FT LL3FSZ LLEAD3 FL A B C D W X Y Z K L Q R S TX P FILE UFD MEM MTA INDIR LST DSKMSC DSKMEM REAPCH MTA2 DSKBAK COPLOG STATCH UDPCHN PDLEN IPDLEN NBUFS NBUFSX INTTTI ALTMOD KMCSW UDPSW PPNDIV PPNADD PPNCHR NTTAPE FTLUFD NTTAPE UDPCSW ZZ UUO

IFNDEF	FTDBMC,<FTDBMC==0>	;Nonzero for DEBUGGING MCOPY code

IFDEF	SPCWAR,<IFNDEF STANSW,<STANSW==1>>	;Test for WAITS features
IFNDEF	STANSW,<STANSW==0>			;Assume not WAITS by default

IFN STANSW,<
;Automatically compile for system we're compiling on!
;(To cross-compile, define WATSIT in advance.)
;(Probably this makes DART not compile under MACRO.)
.INSERT WATSIT[S,SYS]		;get site specific assembly switches, incl FTF2.
>;IFN STANSW

repeat 0,<		;For disaster recovery
PRINTX Set FTHELP for special version (MRESTOREs to RSK, spreading files around)
.INSERT TTY:
>;repeat 0

IFNDEF	FTCOPY,<FTCOPY==1>	;Nonzero for master tape copy
IFNDEF	SRTENT,<SRTENT==0>	;Nonzero makes ARCHIVE cmd sort .ARC by dates written
				;SRTENT is probably a bad idea.  No way to win.

IFNDEF	FTHELP,<FTHELP==0>	;Nonzero for DISASTER recovery version
IFNDEF	DRATSW,<DRATSW==0>	;Nonzero for DRAT version
IFNDEF	IRCPPN,<IRCPPN==0>	;Nonzero for IRCAM PPN FORMAT
IFNDEF	DBGSW,<DBGSW==0>	;Nonzero for Debugging version

DEFINE	DRAT,<IFN DRATSW>
DEFINE	NODRAT,<IFE DRATSW>
DEFINE	SAIL,<IFN STANSW>	;this really means WAITS
DEFINE	NOSAIL,<IFE STANSW>	;not WAITS

IFE FTHELP,<
NODRAT,<
	TITLE	DART	DUMP AND RESTORE TECHNIQUE
	PRINTX	You are assembling a normal form of DART
>;NODRAT

DRAT,<
	TITLE	DRAT	Special features version of DART
	PRINTX	You are assembling DRAT, a special form of DART
>;DRAT
>;IFE FTHELP

IFN FTHELP,<
	TITLE	HART	special Helper for disk disaster recover
	PRINTS/
FTHELP is on the way, to help you recover from a disaster.

/
>;IFN FTHELP

IFN DBGSW,<
	PRINTX DBGSW is on, for debugging without using tape (no RENAMEs done)
>;IFN DBGSW


	SUBTTL	DEFINITIONS

;R.E. GORIN STANFORD A.I. PROJECT AUGUST 26, 1972

IFDEF FOR,<MACRO__0;>MACRO==1		;SELECT ASSEMBLER

IFE MACRO,<				;FAIL MACROS
	DEFINE	DEF(A,B)<A_B>
	DEFINE	SDEF(A,B)<A__B>
	DEFINE	DDEF(A,B)<A_B>
	DEFINE	DSDEF(A,B)<A__B>
>;IFE MACRO

IFN MACRO,<				;MACRO MACROS
	DEFINE	DEF(A,B)<A=B>
	DEFINE	SDEF(A,B)<A==B>
	DEFINE	DDEF(A,B)<A=B>
	DEFINE	DSDEF(A,B)<A==B>
>;IFN MACRO

VERSION==6	;current Dart version, must be nonzero
VERSI6==6	;format number when prev media error data included, etc.
IOVER==3	;current tape format number
IOVER2==2	;tape format number when disk offset included in retr
IOVER3==3	;tape format number when prev media error data included, etc.
VERMSK==77	;maximum reasonable version or format number mask

LEDONE__11	;Leader word containing all ones.
LEDZER__12	;Leader word containing all ones.
CONDAR__22	;Continuation Block word containing 'DART  '.
CONFMT__23	;Continuation Block word containing 'CON',,n (format number).
LL3TAP__26	;Word containing class,,tapno
LL3DMP__27	;Word containing rel dump,,abs dump numbers.
LL3FT__30	;File block word containing tape position in feet
LL3FSZ__34	;Word within leader containing file words left (last used word).
LLEAD3__43	;Number of leader words before file data in Cont and
		;File-Start blocks, not counting the word count word, for IOVER3.

IFN IRCPPN,<
	SEARCH DPYUUO
	PRINTX You are assembling the IRCAM Version with special PPN Format
>;IFN IRCPPN

;	ACCUMULATOR DEFINITIONS

FL=0	;FLAG AC

A=1	;VERY TEMPORARY AC
B=2
C=3
D=4

W=5
X=6
Y=7
Z=10

K=11
L=12

Q=13	;LESS TEMPORARY AC'S
R=14
S=15
TX=16

P=17	;MAJOR PUSH-DOWN POINTER


;	IO CHANNEL DEFINITIONS

FILE==1		;CHANNEL FOR READING DISK FILES
UFD==2		;CHANNEL FOR READING A UFD
MEM==3		;CHANNEL TO REMEMBER FILE NAMES
MTA==4		;CHANNEL FOR TAPE OPERATIONS (reads)
INDIR==5	;CHANNEL FOR INDIRECT COMMAND FILES.
LST==6		;CHANNEL FOR LISTING
DSKMSC==7	;MISC. DSK CHANNEL (DART.REC,DART.TAP, ETC.)
DSKMEM==10	;DSK CHAN FOR REMEMBERING STATE (DART.MEM)
REAPCH==11	;CHANNEL FOR LOGGING REAPED FILES
MTA2==12	;channel for magtape writes
DSKBAK==13	;channel for BACKUP.MEM during tape copy
COPLOG==14	;channel for logging master tape copy
STATCH==15	;channel for saving stats during master tape copy

SAIL,<
UDPCHN==17	;CHANNEL FOR HELLIWELL'S UDP SERVICE
		;(ONLY AT STANFORD FOR UDPSW NOT 0)
>;SAIL

;	OPDEFS

OPDEF	RESET	[CALLI	0]
OPDEF	DEVCHR	[CALLI	4]
OPDEF	CORE	[CALLI	11]
OPDEF	EXIT	[CALLI	12]
OPDEF	DATE	[CALLI	14]
OPDEF	TIMER	[CALLI	22]
OPDEF	GETPPN	[CALLI	24]
OPDEF	SLEEP	[CALLI	31]
OPDEF	TTCALL	[051B8]
OPDEF	PJOB	[CALLI	30]


PDLEN==100	;PUSH DOWN LIST SIZE
IPDLEN==4	;short stack for Interrupt level

NBUFS==11	;number of disk buffers (whole track at SAIL)
NBUFSX==11	;number of disk buffers put at ALTBUF



SAIL,<		PRINTX You are assembling the WAITS version

INTTTI==4	;left half interrupt bit for ESC I
ALTMOD==175	;Define ESCAPE or ALT-MODE character
KMCSW==0	;ON FOR KMCDMP COMMAND.
UDPSW==0	;ON FOR OLD USER DISK PACK (UDP) SERVICE.
PPNDIV==100	;SIXBIT PPNS
PPNADD==" "	;SIXBIT PPNS
PPNCHR==3	;3 CHARACTERS IN EACH PPN PART
	RADIX	5+5
NTTAPE==35	;TOTAL NUMBER OF T-CLASS TAPES (MAX 2**12-1)
	RADIX	4+4
FTLUFD==1	;NONZERO TO USE SAIL LONG UFD'S TO AVOID
		;READING ALL THE RETRIEVAL IN THE WORLD

OPDEF	DSKPPN	[CALLI	400071]
OPDEF	SEND	[710B8]
OPDEF	NAMEIN	[CALLI	400043]
OPDEF	JBTSTS	[CALLI	400013]
OPDEF	WAKEME	[CALLI	400061]
OPDEF	DSKTIM	[CALLI	400072]
OPDEF	PTYUUO	[711B8]
OPDEF	PPIOT	[702B8]
OPDEF	UPGIOT	[703B8]
OPDEF	CHNSTS	[716B8]		;GET CHANNEL STATUS.
IFNDEF	UDPSW,<UDPSW==0)>	;DEFAULT TO NOT UDP
IFN UDPSW,<
DSDEF	T,1			;DEFINE AC'S FOR UDP SERVICE
DSDEF	T1,1
DSDEF	T2,2
DSDEF	T3,3
DSDEF	T4,4
DSDEF	T5,5
DSDEF	T6,6
DSDEF	T7,7
DSDEF	T8,10
OPDEF	DEFPPN	[CALLI	400071]	;DEFAULT PPN FROM DSKPPN UUO.
OPDEF	UOUT	[1B8]		;OUTPUT
OPDEF	UIN	[2B8]		;INPUT
OPDEF	ULOOK	[3B8]		;LOOKUP
OPDEF	UENTER	[4B8]		;ENTER
OPDEF	URENAM	[5B8]		;RENAME
OPDEF	UOPEN	[6B8]		;OPEN
OPDEF	UCLOSE	[7B8]		;CLOSE
OPDEF	UDPMES	[10B8]		;ERROR MESSAGES
OPDEF	INIUDP	[11B8]		;INITIALIZE UDP
OPDEF	PASCHK	[12B8]		;ASK USER FOR PASSWORD & CHECK
>;IFN UDPSW
>;SAIL

NOSAIL,<PRINTX	This is the TOPS-10 version

SDEF	ALTMOD,33
SDEF	KMCSW,0
SDEF	PPNDIV,10	;OCTAL PPNS.  SET THIS TO 12 FOR DECIMAL.
SDEF	PPNADD,"0"	;OCTAL OR DECIMAL PPNS
SDEF	PPNCHR,6	;MAX OF 6 CHARACTERS IN EACH PPN PART
SDEF	UDPSW,0		;NO UDP'S EXCEPT AT STANFORD.
	RADIX	5+5
NTTAPE==31		;TOTAL NUMBER OF T-CLASS TAPES (MAX 2**12-1)
	RADIX	4+4
OPDEF	TAPOP.	[CALLI 154]
>;NOSAIL

UDPCSW==0*UDPSW		;UDP COPY SWITCH REQUIRES UDPSW ON TOO.

EXTERN	.JBDDT,.JBFF,.JBREL,.JBVER,.JBREN,.JBAPR,.JBOPC,.JBCNI,.JBJDA

ZZ==.
	LOC	40
UUO:	0		;LOCATION FOR UUO INSTRUCTION
	JSR	UUOCON	;GODDDAM RPH
	LOC 136
	JRST DDTKLU	;KLUDGE UP DDT ENTRY
SAIL,<			;NOT CLEAR HOW OUTSIDE WORLD WILL DO THIS
PRINTX Start me at 136 before saving as SYS:DART !!
>;SAIL
	.ORG ZZ
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               SUBTTL	changes ; History Bugs

Comment 
;
;1	NOVEMBER 1972
;
;2	JANUARY 1973
;
;3	MARCH 1973	-  UDP ADDED
;
;4	JUNE 1973 -RECORD OFFSET.  NEW TAPE FORMAT (2).
;	(IN VERSION 4 THE 20TH WORD OF FILE RETRIEVAL IS SET TO
;	THE RECORD OFFSET ON DUMPING. (1 IS NORMAL).
;	ON RESTORE FROM A VERSION 4 TAPE, THE RECORD OFFSET IS
;	WRITTEN INTO THE FILE RETRIEVAL.)
;
;	OCTOBER 1973 ARCHIVE COMMAND
;
;	AUGUST 1974 - UDP FLUSHED
;
;5	NOVEMBER 1974 - DATE75 CONVERSION
;
;
;	SEPT 1982 - FIXED TO GFPTS3 TO MAKE REAPED FILES GET T DUMPED.
;	22 Aug 83 ME - Allow NUL device in RESTORE (RSTG3) for testing purposes.
;	23 Aug 83 ME - ILLFMT saves last tape word and PC where error detected.
;	8 Sept 83 ME - Added UNLOAD command (for TU-78).
;	9 Sept 83 ME - Made MTU0 (TU-78) get bigger record size than other devices
;	26 Oct 83 ME - Spools via "XGP" at LLL, LPT at CCRMA, Dover at Sail.
;	16 Jan 84 ME - MTINIT sets up footage parameters depending on drive.
;	10 Mar 84 ME - DENSITY nnnn command sets density for subsequent cmds;
;			but TDUMP,PDUMP,FDUMP,PICKUP always use default density.
;	19 Mar 84 ME - MTINIT split into MTINIR (reads) and MTINIW (writes).
;			The only difference is that MTINIR always uses large
;			buffers for MTU0, even if 1600 bpi is specified, in
;			case the user is wrong and the tape actually was written
;			at 6250 with large records.  This is done because the
;			TU-78 hardware selects the right density anyway, so we
;			might as well try to win on reads, even if the user is
;			wrong.  For writes, we have to use the right size
;			buffers, since we specify the density (forced to the
;			default for system-class dumps).  It is always safe to
;			call MTINIW, since it uses the correct buffer size for
;			the given density.  MTINIR should definitely only be
;			called when reading (or just spacing) the tape, since
;			it might use the wrong buffer size if used for
;			initializing for a write on a TU-78 (MTU0).  Also,
;			DENSITY command reports selected density, whether an
;			argument (new density) is given or not.
;	2 May 84 ME	DENDAM command means believe user density even if doing
;			a system class dump (PDUMP,TDUMP,FDUMP,PICKUP).
;	7 May 84 ME	Restored the POPJ P, at the end of MMMWRT.  It was
;			probably deleted accidentally when VERDAT was written
;			(on page following MMMWRT), approx in fall of 1983.
;	15 May 84 ME	System class dumps warn if they are ignoring a
;			user-specified density (no DENDAM cmd given).
;	28 Dec 84 ME	Fix to RELOOK for PUMPKIN command, to store extension
;			properly for access-check lookup.
25 Jun 85 ME	New code that can copy DART tapes (COPY/UCOPY/TCOPY/MCOPY).
13 Jul 85 ME	ESC I clears all automatic continuation flags.
		Much better error recovery for various tape read errors.
		ILLFMT is gone, but need something in its place for
		errors during PRestore, for automatic backing up if
		error happens during file being restored (see PRPOSN).
		FIXPOS now types sought and found files more cleanly.
		TREAD1 clears error bits directly instead of skipping forward
		a record, thus avoiding ignoring a possibly good record after
		the bad one.  On tape read error, TREAD3 zeroes the unfilled
		words at the end of the buffer, so tape reader will just see
		zeroes there when doing error recovery.
		Also, all reads are now done on channel MTA, writes on MTA2.
		Now RDFIL checks format of word-count word it finds (FMTCHK)
		and makes up a fake filename (*ERROR.ERR) to contain the data
		found on the tape at that point.
		RDFIL made to take direct return upon seeing tape header/trailer
		and to skip otherwise; it no longer continues scanning the tape
		for a file upon encountering a header/trailer block.  Most
		callers just call RDFIL again if it doesn't skip, but UCOPY/MCOPY
		(and later FIXPOS) will do something special (TCOPY has to copy
		the header/trailer info to output tape).
	-->	IDENSITY nnnn command sets Input density for tape copy (DENSITY
		command used for output density).
		Error messages and data printed consistently wrt using TTY or
		list device -- latter generally used iff never stop for user
		OK at this point.
		MTAINP now calculates amount of tape passed even on errors,
		since some data has probably been read from tape.
		Setting TELEOF nonzero makes REOFIL and RDHED2 type out
		indication of EOF; also types indication when writing or
		copying tape header or trailer.
		New command ADVANCE TO <file(s)> advances to first named file
		found on tape, positioning tape at beginning of record where
		that file starts; issues warning if the file doesn't start
		at beginning of the record.  BACKSPACE TO <file(s)> doesn't
		yet work.  Any parts of <filename(s)> not
		specified are taken as * (use "." for explicit null extension).
		Note that ADVANCE TO is slower than TLIST, as it has to use only
		one magtape input buffer to keep sync with the tape.
		ESC I will stop a PRESTORE, RESTORE or ADVANCE TO command at EOF.
		Commands EOFon and EOFoff turn on and off typeout of input EOFs.
05 Aug 85 ME	UCOPY/MCOPY treat any omitted part of filename as wild, either
		in dest or in source part.
		Offers to rewind tapes at end of tape copy.
		No tape header written unless output tape is at BOT.
		ADVANCE TO mtu0:<file> now works, as well
		as ADVANCE mtu0: TO <file>.
		TLIST MTU0 works even with no colon (like REWIND).
		MT read errors type first two words of buffer returned.
		User normally only has to respond to errors once per output file.
		TLIST types *ERROR filename if that file is on the tape (copy).
	-->	ESC I or (soon) CALL/REENTER during PRESTORE will go
	-->	to PRPOSN to allow Pumpkin to position tape beyond bad spot.
		TLIST now eats the LF after CR in response to mounting a new tape
		and continuing in TLIST, at LSTLP2.
	-->	Unexpected Logical EOT just causes output file to be truncated,
		both for (P)Restore and for U/MCOPY.
		Made (P)Restore do more error checking of continuation blocks.
		TREAD toggles IONRCK when has seen CONTHR consecutive records with
		errors, clears it after any error-free record.  CONTHR could be
		set to something like 2 or 3, but defaults to positive infinity.
26 Aug 85 ME	Fixed PICKP3 to use MTA2 (not MTA) for advancing tape after
		FIXPOS returns.
28 Aug 85 ME	Added code, under FTHELP, for use in (M)RESTORE after RP07 disaster:
		SETLST sets LSTBLK in the RSK DDB -- done before each restore;
		default destination device is RSK for RESTORE and MRESTORE;
		if file is [1,3].UFD, LSTBLK is set to middle of logical unit 2;
		if file is [SPL,SYS].UFD, LSTBLK is set to middle of logical unit 1;
		UFDs restored from tape get written with minimized length and
		zero data (long enough to hold all files in the UFD on the tape,
		plus 16 spare UFD entries -- see RFDT3).
		Added some comments to MFDSOR.
		Turned on DAWPRV if DMP,SYS under FTHELP.
		MRESTORE always uses DSK:ALLDIR.DAT under FTHELP, although it is
		restoring onto RSK: (as the default).
02 Sep 85 JJW	AOS buffer header count after USETO (before RSTG5W and MTRM3)
		to reach first physical record when restoring file with offset.
		Added comments at end of conditionals throughout DART source.
08 Nov 85 ME    Modified LCILUS under FTHELP to automatically create any
		needed UFD, but also to log it on the CTY via new routine
		CTYPPN.
30 May 86 ME	SPLFOR changed to NP2 for new spooler format (PSPEC=100).
13 Aug 86 ME	Flushed MTACLZ at RDHEDP to avoid missing EOFs read ahead.
-- Aug 86 ME	Changed SCOPY command to MCOPY (master copy -- tape to tape).
    to		Added more code for tape copy.
   Mar 87	At MTAIN2-2, changed SKIPN to SKIPG in test for nonempty buffer
		(correcting tape footage).
		Changed MUDPYD interrecord gap for 6250 to .3 (from .4) inch;
		maybe footages will be more realistic (not 4100 foot reels).
		Fixed DOMOUNT bug that could clobber beginning of tape by
		writing new header there when doing a mid-tape pickup with
		the tape rewound (not positioned approximately right).
		Block leaders contain two constant words (all ones and all
		zeroes) for detecting errors (written by COLEAD).
		Dart P- and T-tape listings are no longer automatically spooled.
		Fixed FIXP01 not to advance past tape header after backing up
		to beginning of tape.
		Fixed FIXPS1 to work when positioning to *HEAD* -- formerly
		it would back up over the header, then advance past it (since
		it isn't preceded by tape EOF).  Yes, this is the same bug,
		essentially, that FIXP01 also had (from ancient times?).
		Fixed bug at DFREAD whereby an empty DART.ARC would cause
		a halt at LOCPP4+5 because the EOF on word zero wasn't noticed;
		used same bugfix that BH invented for same bug at IRCAM.
		Same bug could hit on empty DART.DAT, but that's a less likely
		case (which could be fixed by making sure UFDRD returns a zero
		upon EOF).
		The 0,,400000 bit (PRMERR) in the database's tape/date word
		means this version of the file had previous-media errors
		(during tape copy).
		PUMPKIN gives option of ignoring file versions with previous-
		media errors (and allows auto proceeding ignoring or using
		such files); see LOCPRE and PRMOK (cleared by ESC I).
		BACKUP.MEM saved with copy of DART.MEM during tape copy after
		finishing either an input or an output tape; for emergency use
		only.
		REENTER command now starts up PPSAV as a detached job to save
		our page printer.  During MCOPY, REENTER will additionally
		force out the MCOPY log file's buffer.
		New format header info typed out more concisely.
		Subroutinized some DBGSW stuff for MT2CLZ.
		Fixed MT2CLZ not to increment MT2FIL until we're sure we haven't
		hit physical end of tape, so MT2FIL doesn't have to be saved
		after each EOF written.
		Now we SOS MT2FIL in MFIXO to undo MT2SKF's AOSing it.
		MCOPY reports input and output tape pickup positions.
		Modified DUMP routine code to output new format (IOVER3).
		Made MCOPY type out time and date before and after asking
		user to mount or verify a tape.
		MCOPY requires tape number confirmation when starting to read
		a new tape that has no Dart tape header (thus no tape number).
		Last PPN in DTAPES.DAT (as of PTRSAV) for tape copy saved
		in MEMSAV+LUSER.
		Fixed up error recovery in BADIWC and improved checking in IWCCHK.
		Added MT2WRD, etc., to MEMSAV so I can use full tape's worth of
		data, records, and files to refigure the footage parameters.
		Diddled footage parameters, mostly flushing the "fudge" which had
		caused overestimates of tape position footage.
		TCPHTR writes DART.MEM since it has diddled new MEMSAV+MT2FI2.
		MFIXO backups up MT2FI2 extra files, to scan past copied headers.
		DOMOUNT pretends GO already typed when needs new input tape,
		during debugging.
		Fixed VERDAT/ARC to properly check order of PPNs in index --
		wasn't checking at all before, although it claimed to be.
		Made MFIXO/FIXPOS/RDHED able to reposition output tape at a
		copied (previous media) tape header/trailer (uses MEMSAV+CUPRVH).
		DPYSER suppresses displaying filename if it's fake (*ERROR.ERR).
		Adjusted footage for interrecord gap for TU-78 to nominal,
		to improve footage estimates.
23 Mar 87 ME	Added code to do merge after every input tape (instead of
		after each output tape), since after that point, the
		directory names start over in alphabetical order.
24 Mar 87 ME	Relabelled pickup codes and points, removing unneeded ones.
		TCOP66 avoids listing in DTAPES.DAT the ALLDIR.DAT[dmp,sys]
		that's found at end of each dump, since the PPN would be out
		of order and hence would screw up DART.DAT.
		Disabled generic data-error warning message in MCOPY (CKPAUS).
26 Mar 87 ME	Fixed bug in PUTEST (PURGE cmd) that tested only ALLPRG but
		not ALLPRJ in deciding to flush a term.  Changed PUMPKIN code
		to use PFSLEN instead of FSLEN -- PFSLEN has old value of FSLEN,
		which is now changed to add FSTAP word; this change allows Dart
		to remain compatible with old Dart in processing of Pumpkin
		queue files (PUMPKI.QUE).  FSTAP word in term storage holds
		tape or date information in switch following filename in
		RESTORE or PUMPKIN.  In PRESTORE, moved "next term block" out
		of RH of FSDEV and into RH of FSPNXT, to allow tape number/dump
		number to use RH.  PLIST and UNPUMPKIN type relative dump nbr,
		if any, after tape nbr.
27 Mar 87 ME	PUMPKIN and LOCATE and RDHED type relative dump number.
		Replaced all calls to TTCALL UUOs with individual UUO names.
		TELOPR accepts only "LOST" or "GO" for master copy input tape,
		only GO for output tape.  TELMLS needs a list of lost P tapes.
30 Mar 87 ME	TCPIKB checks for out of order PPNs in DTAPES.DAT and halts
		(for now) if any had been seen; eventually, DTSORT will be
		called to sort PPNs in DTAPES.DAT so that merge can then be done.
01 Apr 87 ME	MTSRT3 avoids clearing 200000 bit for master tape copy.
		Fix to setting up of rel dump nbr in DTAPES.DAT data.
06 Apr 87 ME	Removed never-used HTAPES code (two bits to specify tape type).
		LOCFPR uses tape or date info from FSTAP instead of SWITCH
		for both Locate and Pumpkin.  Maybe for Locate there should be
		a way to limit how many files are listed or how far back it
		will list files (some new switch)?  SWTCH now returns tape/date
		info in B for SCAN to store in FSTAP.  SWTCH understands
		P3000/3 format and returns combined results accordingly.
07 Apr 87 ME    Made LOCFPR remember when it had typed out info for a file,
		using ALLFLG bit in FL.  Fixed SCAN to set GOTEXT for all
		terms (not just first one), including from indirect files.
		Made subroutine STWILD to set ALLFIL and maybe ALLEXT when
		appropriate for omitted filename -- making all filename refs
		consistent in this regard.  Now .EXT no longer means *.* but
		means *.EXT instead.
08 Apr 87 ME    MTINIR sets up NRETRY to match system's presumed default
		retry count.  INCRET and DECRET contemplate increasing and
		decreasing the number of tape read retries, after good
		reads and bad reads respectively.  New MTAPEs 200 thru 217
		are used to pass retry count to system.  SWTCH permits
		just a switch with just rel dump number -- /n -- for
		DUMP and RESTORE.  (DUMP should set that into rel dump
		field when doing user mode dump.)  SWITOK flags whether
		switches are permitted at all and if plain rel dump is OK.
10 Apr 87 ME    FIXPOS also checks relative dump number to make sure it has the
		right copy of the given file, unless INVERS indicates an early
		format tape (no rel dump nbr).  [Obsolete -- see just below:
		TCPEOT stuffs MCOTAP into TAPNO for TAPTAI to write correct
		tape number in trailer.]  RDHPRV sets up rel dump nbr for
		FIXPOS from header/trailer, or else clears INVERS for FIXPOS
		if older format (no rel dump nbr).  Dart command 'REENTER'
		acts like same monitor cmd -- starts PPSAV on separate job,
		updates any open log file.  UUOTRP handles HALTs specially,
		since they undo UUOSIM UUO, which thus needs to be redone.
		MCIMNT preserves TAPNO as output tape number (written into
		extended file leaders and tape trailer on output tape).
11 Apr 87 ME	TLIST reports relative dump number for each file, if TELEOF on.
		Cleaned up code around TCOPFI to make it more modular and readable.
		Moved test for new dump to before call to TCDUMP, to make sure
		first file in new dump gets correct rel dump number.
13 Apr 87 ME	TCOPDT counts disk files copied, w/ and w/o errors.
		MCLEOT reports these counts (which are backed up at pickup).
		Counts are maintained per tape and for entire master copy.
		Routine PTCNT, called from DDT, reads DART.DAT and DART.ARC
		from [DMP,SYS], counting files on each tape, writing PTCNT.DAT.
		PTCNTR, called from beginning of MCOPY, reads in PTCNT.DAT.
		MCLEOT makes various checks to see if logical EOT is expected,
		including checking the number of files read from current tape.
14 Apr 87 ME	MFIXI bugtrap allows CUSER to be zero if header or trailer.
15 Apr 87 ME	VERDAT/VERARC do range checks on tape numbers and dates written.
		Found and fixed one bad tape,,date word for ACCUM1.NLY[S1,EJG],
		in DART.ARC.
16 Apr 87 ME    Really adjusted footage for interrecord gap for TU-78 to
		nominal, (from .5 to .3 inch) to improve footage
		estimates (maybe I only changed the comment last time? --
		see just above 23 Mar 87).  No special case for headers in
		FIXPOS -- DOMOUNT/TELOPR sets *HEAD*, etc., in FFILE, FFEXT,
		and FUSER.  Fixed STOFIN/MFIXI to save and restore RELABS.
18 Apr 87 ME	ADVANCE TO reports relative dump number with found filename.
		FIXPOS reports rel dump nbr of each file found.  TCOPF3
		reports rel dump nbr after name of each file copied.
		MTABKF doesn't let MTAFIL go negative.
		TCPHTR updates and extends old format headers to include
		dump numbers and tape position (footage).
19 Apr 87 ME    Moved saving and restoring of RELABS to NEWMTF and MFIXO
		since it really relates to output tape and always needs to
		be restored if repositioning output tape.  LOCFPR uses flags
		ALLFLG and ABFILE in each term to indicate (a) that term has
		been matched and (b) that term has had a dumped version
		listed (and accepted if pumpkin with prev media errors).
		ALLFLG in FL is still used to note first typed out version
		of file.  This make LOCATE and PUMPKIN type dump info
		correctly, including for files with prev media errors,
		files never dumped, and files not available with specified
		tape or date.  LOCPRE now responds correctly to user choice.
21 Apr 87 ME	Bugfix just above TCPHT2 for copying headers correctly.
		Also, header's wd cnt wd is now updated to new format length.
		In MFIXO, restored RELABS before calling FIXPOS, since
		that routine uses RELABS.  BADIWC zeroes the additional part
		of the input buffer if it will use it in extending the byte cnt.
		IWCCHK guarantees RH C has buffer free space count when it
		does XCT to attempt error recovery -- BADIWC needs this.
22 Apr 87 ME	Fixed UNPBLK to clear PRMERR before testing for tape nbr match
		in UNPUMPKIN.  MCOPY shows input and output tape pickup filenames
		before resuming.  Saved backup copies of DART.MEM are called
		OUTPUT.MEM and INPUT.MEM for end of output and input tapes,
		respectively.  Also, old version of each of these two is
		preserved as *.OMM (see SAVOUP/SAVINP).
23 Apr 87 ME	REOFIL forces text out to TTY before saying logical EOT.
		Ignoring checksum errors again, for now during debugging.
24 Apr 87 ME	DTSORT now can sort DTAPES.DAT by PPNs, in case tape errors
		(or whatever) manage to pervert the order of the PPNs.
26 Apr 87 ME	TELDAT nonzero makes TLIST type out each file's date written.
27 Apr 87 ME    RDHED counts down IWC for any length header, although I don't
		know if that's really necessary.  RDCON sets FSIZE very large
		so that all consecutive cont blocks get put into one file
		(since they came from one file).  Also, RDCON sets FSIZE to
		remaining word count if block is new format with that count in
		it.  Invented circular debugging buffer (DBLBUF) and made
		routines that set up IWC insert their IWC (more or less) into
		the circular buffer (DBLOG) for examination upon hitting a
		bugtrap (ICKICK).  When FSIZE is set (or diddled), data is
		inserted into circ buf.
28 Apr 87 ME	Fixed IWCCHK to avoid having C RH being "negative" (large
		positive) when byte pointer has reached end of buffer
		(caused ILM in BADIWC at BLT).
29 Apr 87 ME	Added two more returns to FMTCHK, for file-start with short
		MT buffer and file-cont with short MT buffer.  Made subroutine
		ZEREND to clear remainder of non-full buffer, increasing
		input byte count accordingly.
30 Apr 87 ME    IWCCHK checks for short buffer on continuation block and tries
		to extend it with zeroes if reasonable.  MTAINP types out word
		count from each buffer read for master copy.
04 May 87 ME	Suppressed MKTURK for master copy, since DTAPES.DAT and turkey
		file use same disk channel; master copy keeps own log anyway.
		RDHED5 allows wrong tape to be mounted during debugging.
		Added (first) name of each file read to debugging buffer (RFIL1).
08 Jun 87 ME    Fixed RFDB2S and MTBFSH to increment MTRSHR (not TOOSHR).
		Flushed unused count RFDERR.  Revised some of the texts in
		ERDESC's error descriptions.  Fixed TCPIKS to initialize
		ITEPPN with special programmer name '2' to ensure first
		tape of copy doesn't immediately trigger a new relative
		dump number.  LENCHK and callers handle a truncated tape
		record more leniently; if word count exactly matches the
		space to the end of the physical buffer, then it's assumed
		that the hardward truncated the record's data.
10 Jun 87 ME	IWCER2 accepts word count that exactly reaches to end of
		physical buffer (leaving room for checksum).
11 Jun 87 ME	MCLEOT types out increments in system error counts.
		IWCCHK detects end of buffer occurring at wd-cnt word.
15 Jun 87 ME	Patched DART[1,3] to use bigger buffers when reading from
		all MTU drives, not just MTU0 (MTINIR) (source code was
		already edited to do this).
16 Jun 87 ME	Fixed SAVINP to preserve date of .OMM files in doing the rename.
		Now always halts when issuing warning about fake logical EOT.
		Major MCOPY errors are preceded by %%% instead of ###.
		Made subroutine ZERERR to report failure return of ZEREND.
17 Jun 87 ME	Installed explicit list of missing SAIL P tapes in TELMLS, for
		the tape copy; list was generated by JXK and BJR, independently.
		RFDTER and FMTCON call new temporary error-halt routines if
		IWCCHK returns saying no room for any data in the buffer.
		Some way of recovering from these errors is needed.
18 Jun 87 ME	Fixed MMREAD not to flush any old DART.DAT data from same
		tape as new data is for, during MCOPY.  Need to fix this
		properly for restarted P dumps after MCOPY is finished
		(because multiple dumps will be on a single tape).
19 Jun 87 ME	TCOPFI normalizes disk offset word to 1 in retrieval of files
		from any tape format earlier than IOVER2; also moves writer's
		PPN into DDWPPN word.
21 Jun 87 ME	MTAFIX monitor command added to unwedge a jammed MTREQ/MTAVAL.
		(Use this command if Dart seems to hang after a rewind finishes.)
		MCOPY pickup reports input file count both at pickup point and
		at last reading point (indicates how much it will back up).
22 Jun 87 ME	More kludge under DRAT and FTCOPY, for TLIST to regenerate
		DTAPES.DAT files made during tape copy, avoiding ALLDIR.DAT.
		Output files are called DRAT.CPA, .CPB, etc., on current area.
		Fixed DTSPPN to make sure it has enough core when sorting PPN
		in DTAPES.DAT.
		TCOPDT makes sure date written of file copied is not in future;
		if it is, zero is used for the date.  Reports what the bad
		file date was.
		MCLEOT includes tape number in type out of system error data,
		which are now indented.
		MTAIN0 no longer sets position questionable upon read error.
		REOTAP clears IOIMPM in RH (instead of LH as formerly) since
		IOIMPM comes with phys EOT bit.
23 Jun 87 ME	TCPIKA asks operator to insert tape lifter and type GO
		before input tape rewind.  Default devices for MCOPY are:
		MTA1 for input, MTU1 for output.  Found tape P908 and removed
		it from list at TELMLS.
25 Jun 87 ME	DPYFIL in DPYSER displays relative dump number, if nonzero.
		Changed MRETRY to 2 (number of consecutive bad MT records
		before we reduce the retry count).
		ICKBAD suppresses checksum-failure typeout if NRETRY is
		zero (lots of errors); same for TREAD2 and BADIWC.
		ICKICK no longer halts; just prints error msg and tries
		to recover.  LENCHK now tests word count for being negative
		18-bit number, lest 0,,-1 overflow to zero when CKWD is added.
		(Maybe this'll make ICKICK never get hit.)
		RFIL1 makes sure filename and PPN in retrieval are nonzero.
		DPYSER displays rel dmp number after output tape number during
		master copy.
26 Jun 87	MCLINI inserts name of log file into beginning of log file.
		NOMCOP reports DART.MEM lookup failure reason if other that
		non-ex file.  MCLEFL reports nice table of good/bad file counts
		for current tape and previous tapes.
		Fixed TELMLS to force uppercase correctly for "LOST".  Fixed
		TELML2 to increment PREQTP (number of expected tape) and
		MCITAP.  Marked P54 as "lost" (really just garbage tape).
28 Jun 87	TREAD2 even avoids typing CRLF when NRETRY is zero.
		RFIL1 ensures that file length read isn't negative, that
		PPN consists of right-aligned (sixbit) half words (so maybe
		it isn't valid for IFE STANSW), and that device is DSK.  If
		not, assumes bad tape format (RDERR0).  MERGZ2 renames
		DTAPES.DAT to names like P00001.DAT instead of deleting it,
		for master copy.  Routine MASDAT reads date from operator,
		returning system date in B (what a kludge to avoid going to
		RESTAR on error).  RDHED saves date from valid tape header
		in MEMSAV+MCITAP (MFIXO preserves that cell).
		RFDT2+12 reports previous media errors if any, when file
		appears to end too soon; otherwise, it reports current media
		error.  Flushed "count of" from error labels in MEDERR.
		NOHDTR doesn't pause when encountering ill-defined
		header/trailer block.  RDHED5 doesn't check tape number
		if header has bad format (ill-defined).
		Spruced up RDHED's typeout format for headers and trailers.
		RFIL1 lets fake file *ERROR.ERR get through filename check.
29 Jun 87 ME	Fixed RFDT2+12 to once again backup input by one byte even
		when calling TYPMER.  Fixed RDHED1 to type rel dmp nbr after
		dump set number, instead of after tape number.
		TCOPFI calls VALDAT to validate or obtain a new date for
		a new input tape.  MANMER asks for date if MASCOP is set;
		also turns on PCLASS bit.  Then MERGE/MASCOP checks all
		dates from DTAPES.DAT against MTIDAT and clears bad ones.
30 Jun 87 ME	RFDT2+12 avoids reporting "new" tape error if previous media
		error data indicates file was too short when copied, or if
		filename is fake generated during tape copy.
		RDERR1 increments TAPERR and BADFMT -- didn't used to record
		an error (?!).
		(Can't we have an *ERROR.ERR file from some other previous
		media problem other than too short?  Yes, from RDERR.  So
		are there RDERR files copied without any previous media
		errors noted?  No, because the 300000,,0 file size would
		force a premature EOF error during the copy, unless UNEEOT
		was hit (unexpected EOT).  But RDERR will almost
		invariable see a checksum failure.)
		In DECRET, if NRETRY reaches -REHARD, then it is reset to
		small positive retry count to see if that helps (maybe not).
		Alternatively, if NRETRY reaches -REHARS, then DECRET skips
		tape to next EOF (backing over it).  This doesn't seem to
		affect the input buffers, and if it did, it probably
		wouldn't matter.
		Under DRAT, TLIST will now avoid listing files with improper
		PPNs, lengths, devices or names, since RFIL1 will turn such
		filenames into *ERROR.ERR and code above LSTLP1 (DRAT) will
		not record such files in listing file.
		STOIER, MASPSE, MASPIE and MASCU0 don't halt but just
		avoid saving state in DART.MEM, in hopes condition will go
		away before a crash (for STOIER and MASCU0, crash won't
		cause trouble, because the bad situation is detected and
		prevented before it can actually exist).  These all ask for
		a wizard, but accept GO from operator.
01 Jul 87 ME	MCNEWI asks operator for brand and type of each new input tape.
		MTCHK5 in MTCSER now sets IOSLIC by default to use low slice
		level to read all the old tapes (still toggles slice during
		each retry).  Constant PRMERR ('$PEND$') inserted in last word
		of prev media error data written at end of each data block.
		** To force MCOPY to think it's reached end of input tape,
		use DDT to make TREAD2 jump to TAPEND.
02 Jul 87 ME	MMERGE is like MANMER but sets MASCOP for merging master tape
		copy DTAPES.DAT files.  MMERGE command calls this routine.
		Fixed MANMER/MMERGE to finish cleanly, halting after reporting
		done.  DTSORT command calls DTSOR0 to sort DTAPES.DAT by PPN.
		VERDAT checks for order of filenames in consecutive entries.
		Bugtrap checks for TIBUF+1 overflowing into LH on ADDM.
03 Jul 87 ME	IWCDBG routine called to check word count being stored in IWC
		from various places (since have seen IWC/0,,730000).
		RDFILX uses IWCCHK to verify continuation-block wd count.
		Ran VERDAT/ARC over [DMP,SYS] files and found a number of
		duplicated filenames, mostly with identical dump info, but
		at least one with a probably wrong date (in first copy).
		ICKBAD prints short msg (not none) if NRETRY nonpositive.
		Revamped RDERRx messages, shortening, making sure wd-cnt wd
		is always typed out.  Trying to resume MCOPY with P3004
		by setting pickup code to 5 (new output tape), then forcing
		TREAD1 to go to TAPEND, and avoiding merge stuff in MCLEO2,
		since MMERGE and DRAT/TLIST have been used to regenerate
		DART.DAT through P3003, and P56 is unreadable.
		MCOPY pickup info now includes tape numbers.
		RDERR3 zeroes MTFPPN to prevent STOIFN from saving bad
		spot on tape for pickup point (probably wouldn't read same
		data from that spot twice).  INCRET refuses to increment
		retry count if input buffer byte count is 2 or less -- can't
		possibly be a good data record.  Reduced REHARD and REHARS.
		RFIL1 permits invalid names when called from FIXPOS (RDHACK on).
		STOIFN prints CUSER filename when it sets it, so we can figure
		out how a bad filename gets in there while reading a tape
		that is almost entirely bad.
04 Jul 87 ME	Fixed DDREAD not to increment ARCWC upon EOF, since MEMWC1
		isn't incremented then; makes DTSORT work for sorting of
		one-record DTAPES.DAT.  Set DUMPER and TAPREG to MC4,SYS
		if DBGSW on.  RDERR3 sets test words with ones and zeroes
		to avoid failing test later.  DTSORT can handle empty
		DTAPES.DAT, although it asks calls WIZGO to check it out.
		FAKEFI extension is .NEW to indicate we just read a new
		error file; TCOPFI turns that into .ERR, so when we read
		a tape and see .ERR, we should accept that as normal filename.
		TCPIB2 makes sure that MTIDAT has valid date before it calls
		MERGE0.  RDHED avoids clobbering valid MTIDAT (e.g., with
		date from tape trailer).  Fixed MERGE0 to properly set up
		filename to rename DTAPES.DAT to for master copy.
		MASCU0 and MASPSE don't pause (via WIZGO) any more, since
		this happens when RFIL1 rejects a bad filename and RDERR3
		zeroes MTFPPN to prevent STOIFN from saving the bad filename
		in CUSER.
06 Jul 87 ME	INCDMP types absolute dump number (dump set nbr) instead of
		rel dmp, since latter is typed out right afterward anyway.
		Backed up tape copy to beginning of tape P35; fixed DART.MEM,
		DART.DAT.
07 Jul 87 ME	Added info to input tape stats: number of records read;
		output tape number, dump set nbr, rel dump nbr; and
		adjustments to expected disk file counts for ALLDIR.DAT.
		STOIFN types out dump set number.  TELOP5 types rel dump
		and dump set numbers when mounting a new output tape.
		TREAD1 checks TABORT flag (set by ESC 5 I) and asks operator
		to type GO if wants to pretend we've reached the end of a
		presumably-unreadable input tape during master copy.
		MCLEOT types current output tape position in feet.
		TCPIRE allows operator to continue copy even if no files
		in DTAPES.DAT.
08 Jul 87 ME	DECRES only backs up a record, not an MT file, after skipping
		forward an MT file after lots of read errors.
		RFIL1 now requires PPN of read in filename on tape not only
		to be properly right aligned in each half but also to contain
		only letters and digits (PPNCHK).
		TREAD1 checks TSKIP flag (set by ESC 7 I) and asks operator
		to type GO if wants to skip forward over some tape files
		during master copy.  ESC 7 I GO<return> increments skip count
		and skips that many files; ESC 7 I XX<return> resets skip
		count to zero; ESC 7 I <return> does nothing.
09 Jul 87 ME	RESTORE makes log file, sets LRETRY, under FTCOPY.  MTAIN3
		prints record size iff LRETRY is set.
02 Aug 87 ME	COMPARE command is like RESTORE, but compares disk file
		to tape file (syntax: COMPARE disk_tape).  Changed NBUFS
		and NBUFSX to 9 from 23.
03 Aug 87 ME	MCLINI writes log file on current area, not DUMPER.
		RDFILS sets up IFSIZE so that IWCCHK won't complain (after
		doing a RESTORE or a COMPARE).  ESC I doesn't stop
		comparison, but does undo GO response.  COMPI0 only shows
		first file data difference in each file.  COMPARE cmd
		uses *.*[*,*] as default dest term and default source term.
06 Aug 87 ME	RSTG5G (CMPG5G) now correctly skips past rest of a file for
		which the ENTER (RESTORE) or LOOKUP (COMPARE) has failed.
		CMPLEN fixed to do the offset-read MTAPE and all the comparing
		of file info (except file data), now compares file length
		correctly even if file has disk offset.  Also, COMPARE now
		checks for nonzero data in disk file if disk file is longer
		than file on tape and everything matches up to shorter end.
07 Aug 87 ME	Merged COMPGO and RESTGO.  Also, COMPARE now assumes dest
		PPN of [*,*] if no explicit dest PPN given (even if
		filename given).
15 Dec 87 ME	DUPCHK is called from TCOPF3 to check for a duplicated filename
		that may have resulted from error recovery accidentally
		reading the same piece of tape twice.  Currently it halts if
		that situation is detected, forcing a PICKUP to be done
		(although the PICKUP may have trouble if this portion of
		the input tape is bad -- maybe it should just do a space
		forward record or file?).  VERDAT/TWOSAM prints any filename
		that is duplicated, such as DB.LSP[C,RPO] (MC5,SYS).
20 Jan 88 ME	Changed default input tape for MCOPY to MTA0 (drive A, which
		now has remanufactured heads).
21 Jan 88 ME	MTAIN2 prints "\" instead of " 2400 " for standard word count
		in tape record read for MCOPY, to save space, unclutter output.
		Broke MCOPY code into many pages instead of a couple of very
		long ones.  ESC 9 I toggles default slice level.
22 Jan 88 ME	TREAD1 calls TOGSLI to toggle slice level if requested by user.
		MCOPY makes slice level start up at 1 (mostly old tapes).
24 Jan 88 ME	TCPIB2 calls MCPVER to verify the format of DART.DAT right
		after the merge (following logical end of input tape).
27 Jan 88 ME	VEROK turns off filestatus from wholine, doesn't erase it.
		Bugfix at TOGSLI, which also now reports resulting slice level.
		MCIMNT ensures that slice level is set to that established
		previously, when mounting new input tape (upon PICKUP, however,
		slice level will always be set to the default from code at MCOPY).
		REENTER normalizes display before starting up PPSAV.
		TCOPFI calls SLICHK to see if it might be a good idea to toggle
		the slice level (if most reads are winning on first re-read).
28 Jan 88 ME	Made SLIWIN always save new counts, only have two returns.
		Avoid having MFIXO clobber saved counts for input tape
		by pushing and clearing TSLICE.  Turned off use of tape lifter
		before rewind at MCLEO2.  MERGRZ renames old DART.DAT to
		P00001.DAT (if just finished reading P2), to allow backing
		up the dump.  SAVINP saves a copy of .MEM file at end of
		input tape as P00001.MEM (copy saved at end of output tape
		still called OUTPUT.MEM); so no renames of INPUT.MEM to .OMM
		are done anymore (still done for OUTPUT.MEM to .OMM).
29 Jan 88 ME	Added new pickup point TCPIKD after verify of DART.DAT finishes.
		Made one macro generate MCOPY pickup tables MCPIK & MCPIKT.
		MTAINP types "" for RECSIZ or BRCSIZ record.
		ESC 5 I (abort) and ESC 7 I (skip records) permitted by
		anyone (formerly only in MCOPY).  PRESTO enables limiting
		of retries when getting lots of errors.
31 Jan 88 ME	Moved documentation of new Dart format into DART[DMP,SYS].
		Bugfix in RENDAT, for renaming P00001.DAT_DART.DAT, to
		preserve file's date and time.  Under FTCOPY, the normal
		system dump commands, including PICKUP and PURGE, are
		prohibited (call MCONLY).
01 Feb 88 ME	Parsing of /P1234 switch by MCOPY for input tape coded,
		to allow operator to backup the tape copy to given tape.
		But backup code not yet written (MCOBAK).  MCINEW types
		out time before asking for tape Brand, so we can tell how
		long it took to read previous tape.  TYWHEN shows how long
		since we last got to TYWHEN.  MASPIK knows about MCPIKD,
		avoids bugtrap for it.
02 Feb 88 ME	Bugfix to DUPCHK to correctly check against saved list of
		file names.
03 Feb 88 ME	Corrected instructions for backing up the MCOPY (MCOBAK).
		GETECT reads system's record win-lose info from MTA DDB (not
		actually in DDB yet), allows system table to be different
		size from ours.  MCLEOT report how many records in
		latest tape were read successfully on first try, second try,
		etc.; also, checksum error count is maintained and reported.
04 Feb 88 ME	System has record lossage count patched in and GETEC5 knows
		where.  Bug fixes at TELWIN and MCLECL for printing try counts.
		Only checksum errors occurring in read-error-free MT records
		are counted in display at MCLEOT.
03 Mar 88 ME	Revised MCOBAK help info, to mention DO files for backing
		up the MCOPY.  GETEC5 no longer knows about any counts patched
		into system, since 9.18/C is up with counts in MT DDB.
07 Mar 88 ME	Added physical input tape name to typeout of system counts at
		end of each input tape.
08 Mar 88 ME	MCLEOT types input tape brand and model, and MCOPGO requests
		it from user.
09 Mar 88 ME	MCLEOT also types time and date and interval on percent line.
10 Mar 88 ME	Under FTCOPY, MTAINP always types out "" or word count.
		Fixed bug of clobbered A at MCOPG3.
11 Mar 88 ME	Changed default MCOPY output drive to MTU0 (drive D is down).
		Fix at GETBXT to make length of brand text positive.
19 Mar 88 ME	Added BADDAT bad date word to previous media error data --
		indicates previous media file had bad date written (it has
		been zeroed).  Tape brand name is stored in DART.MEM to avoid
		asking for it upon each pickup of same tape.
21 Mar 88 ME	ICKBAD always types out XOR bits of checksum errors.
19 Aug 88 ME	LCEXIS types name of device existing file is on, if not DSK.
17 Sep 89 ME	Modified FTHELP not to compress RM?,SYS UFDs during
		restore, to avoid DSKSER bugs when having to expand a UFD
		for multiple jobs at once (RSTUFD flag made positive).
14 Feb 90 ME	Added MANMERGE command; take tape name as arg: P2345 or T12.
		Run MANMER with MANTAP and PCLASS set up, avoids tape listing.
30 Mar 90 ME	Updated TXTECT for types of errors recorded by system for
		TU-20 7-track tape drive now in use.
12 Apr 90 ME	Fix to RDER11 to avoid loop when TIBUF+2 is 2 or less.
		MCNEWI preloads line editor with previous tape brand.
16 Apr 90 ME	Turned on use of tape lifter for tape copy, at MCLEO2.
		Changed MTARET to limit retries to 0 (1 try) for MCOPY.
17 Apr 90 ME	MTINIx opens magtape in IONRCK to suppress retries, if
		compiled for MCOPY (FTCOPY).
18 Apr 90 ME	Disabled yesterday's change, to allow retries, but reduced
		the max number of retries, MXRET, to 3.  Made MTINIx call
		MTARET, which no longer is limited to 1 try under FTCOPY.
20 Apr 90 ME	Made MLBAD and MLGOOD be number of bad and good reads to
		decrement and increment the retry count, respectively, making
		them independent.  DECRE3 no longer enables more retries
		after lots of losses (no variable slice level on TU-20).
23 Apr 90 ME	Fix to use of MLBAD and MLGOOD.  If see duplicated filename
		from tape during copy, you can probably resume at TCOPFI
		to avoid copying and listing the file twice.  Reset NRETRY
		to zero after skipping a file, so don't immediately skip
		again.  Disabled slice level changing in SLICHK since no
		slice change possible with TU-20, disabled typeout in TOGSLC.
25 Apr 90 ME	Fix to GBRAND's attempt to avoid accepting "GO" as tape brand.
		TCOPDP doesn't halt, just goes on, omitting the duplicated file.
26 Apr 90 ME	Fix to Verify routine at VERNPN, for case of last index block
		in .DAT or .ARC file being completely filled.
30 Apr 90 ME	Avoid forcing out retrieval in output file at DMFRC when doing
		ARCHIVE command (big speedup).
02 May 90 ME	STOIER doesn't pause when first file in output tape file isn't
		first file in input tape file.  MCOP00 asks for user's name,
		so it can go in log file to show who was running MCOPY.
		MCOP01 stuffs an MTAFIX command into a PTY, to clear any
		jammed MTA interlock.  MCOMNT suggests using a write ring
		on output tape.  VALDA4 doesn't require confirmation of
		tape's date if date is close to previously validated date.
		TYTIME prints hours with leading 0 if less than 10.
14 May 90 ME	Patched TWOSAM not to halt for now.  Some input tapes in
		tape copy have two copies of the same file on them, e.g.,
		P561 and S20A.DAT[1,MMM] and P475 and SIMP.FOL[CHS,REF].
		ARCD00 allows manual flushing off duplicated filenames
		from .DAT file when doing ARCHIVE command.  Duplicated
		names are left in .DAT file (as T tape entries -- kludge).
15 May 90 ME	Fixed ARC.RD to ignore extra zeroes at the end of the file
		(DART.DAT).  That allows .ARC file to be reprocessed as a
		DART.DAT file -- .ARC files have extra zeroes at end, but
		normally DART.DAT doesn't.  STARTP-3 AND ARCH0-2 have code
		under FTCOPY to let [1,ME] and [1,JJW] get privs and do an
		ARCHIVE command (for MCOPY).
31 May 90 ME	Added an extra space to GBRAND prompt to avoid DD hardware
		bug of first char being displayed wrong in line editor.
03 Jun 90 ME	Fix at VERIEN to allow for zeroes following last PPN's data
		in file, when last index block is completely full.
		TELML2 asks for brand of next tape, after operator says
		current one is lost.  RDHED5 also asks again for the brand
		of the tape, after finding the wrong tape loaded.
		Statistics are saved in STATS.LST (summary) and STATS.TOT (all).
04 Jun 90 ME	Removed extra CRLFs from text saved in STATS.*.
05 Jun 90 ME	RDHED5 doesn't check tape number if tape class is invalid.
10 Jun 90 ME	VERFL1 checks for dumps dates being in reverse chrono order.
		Assembly switch SRTENT allows sorting of dump dates in .ARC
		file during ARCHIVE, but currently assumes .DAT file dates
		are newer yet (and thus should just be prepended as usual).
		Disabled VERFL1's date order checking (see comment there).
10 Jul 90 ME	MASDAP checks operator-supplied date against last tape's date.
		VERIFY command verifies format of DART.DAT and DART.ARC.
27 Jul 90 ME	Added code in RDHED above ISWRNG to look for a second DART
		header after finding we have the wrong tape during tape copy.
		This was needed because some tapes have a T tape header
		preceding the valid and expected P tape header (e.g., P2324).
12 Aug 90 ME	Avoid checking file's date written in tape copy unless
		doing master copy.  Same for checking for first file in
		output tape file being first file in input tape file -- only
		in master copy.  Same for error messages in MASPIK -- none for
		user copy.  Now that all 7-track tapes have been copied,
		changed the default input tape for master copy to MTU1.
		Fixed bug in US6250 for start of reading 6250-bpi tapes.
		Increased number of buffers from 3 to 6 (for master copy
		of 9-track tapes).  Patched GETECT to do nothing, now that
		7-track tapes are copied.  Disabled use of tape lifter (FTLIFT).
		Fix to bug of "duplicated" filenames being removed from
		database after new output tape.  DUPCHK was screwing up.
		Now it's array is cleared upon each input or output tape change.
		MCLEO2 unloads (instead of just rewinding) old input tape.
		Default devices for MCOPY: MTU1:_MTU0:.  Limit typeout during
		MCOPY by not typing CRLF and PPN except upon new PPN.
13 Aug 90 ME	Fix to BUFSE1 to really set up 6 buffers in ring.

History: add new stuff above here  ("-->" means still not really tested)

Now for some bugs --

(Fixed) ***	** Dart (?) bug causes 3-buffer ring Input not to detect EOF
		after Dart tape header at beginning of tape.  MTACLZ at CLREOF
		should be avoided -- it clears IOSEOF and IOEND in DEVIOS, thus
		making system forget about advance-seen EOF.
	***	RDHEDP clears EOF (if on), but doesn't look for second EOF,
		thus possibly missing logical EOT.  Fortunately, we shouldn't
		ever see EOF after reading the tape header/trailer (so why
		does it even look for it?).
(Fixed)	***	** Found apparent BUG at DOMOUNT, overwriting tape hdr on pickup
		if tape is rewound instead of positioned in middle for pickup.
	***	Does the word count (and first record of data) of the next file
		restored after restoral of an empty file get screwed up by one?
	***     Free storage for terms (PUSHJ P,SCAN sets TBASE) is never
   (Feature?)   returned (via .JBFF); giving lots of commands (that
		scan for terms) will slowly use up memory.  This may be
		important for a PRESTORE that's interrupted by a bad tape,
		but probably not since RETRY doesn't scan for terms
		(PRESTORE does, but it also preserves .JBFF).
	***	Forgetting to put in write ring (or hardware failure to
		detect it) at beginning of a dump makes it impossible to
		do a pickup -- the tape has no (new) data on it but the MEM
		file thinks a header has been written.

Bugs: add bugs above here

end of comment 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   subttl	Tape Format

COMMENT $

New format for DART tapes  19 Sept 86

Tape format 3 (and later).
Dart version 6 (and later).

Tapes were originally recorded at 800 bpi, odd parity.  Now they may be
recorded at 1600 or 6250 bpi.  Magtape record length for 800 or 1600 bpi
tapes does not exceed 1280 words.  Tapes written at 6250 bpi have record
lengths up to 10240 (decimal).

There are these types of data blocks:  Header blocks, Trailer blocks,
File-Start blocks, and File-Continuation blocks.

Header blocks appear at the beginning of (1) a dump or (2) each subsequent tape.
Trailer blocks appear at the end of a full tape (near physical EOT marker).
File-Start blocks hold the beginning of a file (and possibly the entire file).
File-Continuation blocks hold a continuing portion of a file.

(Note that for user-mode dumps, a Header block is written at the beginning
of each DUMP command given by the user.)

Tape numbers are kept only for system class dumps.  User class is class 0.
Classes 1 and 2 are system classes (Temporary and Permanent).

Note that even if the first part of a tape (tape header) is unreadable,
the tape number is still available in the extended file leader information
on every file, for formats of IOVER3 and beyond.


HEADER AND TRAILER BLOCKS:
	(Words 6 through 13 do not appear if "version" is less than 6.)

Word 0:		version,,length
				"version" is the positive version number of
				the DART that created this tape (VERSION);
				"length" is the length of the data following,
				including the rotated checksum word below.

Word 1:		'DART  '	sixbit DART

Word 2:		'*HEAD*' or '*TAIL*'
				data in sixbit, indicates Header or Trailer block

Word 3:		time,date	in file system format
				Bits 13:23 are time in mins, bits 24:35 are date.
				Bits 4:12 are unused (considered high minutes).
				Version 5: Bits 0-2 are high date.
				Version 6: Bit 3 means this is time from prev media

Word 4:		ppn		the name of the person running Dart.

Word 5:		class,,tapno	Tape number of this tape
				Dump class of this dump
				The top bits of tapno indicate which
				sequence of tapes this nbr is in.

Word 6:		relative dump,,absolute dump	(relative is within this tape)

Word 7:		tape position in feet from load point

Word 10:	0		reserved for future use

Word 11:	-1		all bits on

Word 12:	0		all bits off

Word 13:	rotated checksum of words 1 through 12 above.


FILE-START BLOCKS:
	(Words 22 through 43 and words length-7 through length
	 do not appear if tape format is less than 3.)

Word 0:		-n,,length	-n denotes file-start blocks.
				"length" is the number of data words that follow.
				"n" is the tape format number (IOVER).

Word 1:		devnam		name of the source device

Words 2-21:			file retrieval of this file as it
				appeared on the disk.

Word 22:	'DART  '	sixbit DART

Word 23:	'*FILE*'	sixbit *FILE* indicating file-start block

Word 24:	time,date	in file system format, when this tape was written.
				Version 5: Bits 0-2 are high date.

Word 25:	ppn		the ppn of the dumper running Dart.

Word 26:	class,,tapno	Tape number of this tape
				Dump class of this dump
				The top bits of tapno indicate which
				sequence of tapes this nbr is in.

Word 27:	relative dump,,absolute dump	(relative is within this tape)

Word 30:	tape position in feet from load point

Word 31:	0		reserved for future use

Word 32:	-1		all bits on

Word 33:	0		all bits off

Word 34:	file words left (incl. this block and any hidden (offset) records)

Words 35-43:	0		reserved for future use (higher tape formats)

Words 44 thru
  length-LMedEr:  file data	data from the file.

Words length
  -LMedEr+1
  thru length:	error data	data indicating previous-media errors, in
				order according to the array MEDERR.

The value of LMedEr (media error data field length) is a function of the tape
format number (n, that is IOVER).


Word length+1:	checksum	exclusive or of words 1 through length above

Word length+2:	next block	if this is 0, skip to next magtape record.
				if this is <0, treat as word 0 above.


FILE-CONTINUATION BLOCKS:
	(Words 1 through 43 and words length-LMedEr+1 through length
	 do not appear if tape format is less than 3.)

Word 0:		0,,length	length is the number of data words that follow

Words 1-22:		<same as in File-Start block>

Word 23:	'CON',,n	indicates file-continuation block, tape format n

Words 24 thru
  length+1:		<same as in File-Start block>

Word length+2:	next block	<same as in File-Start block>




GENERAL NOTES ON FORMAT:

If a file start is seen, then at least all of the retrieval data and some
file data (unless empty file) is present in the current magtape record.

Tape formats (IOVER):
   1	Disk file record offset is zero in retrieval on tape.
   2	File-starts have only words 0 through 21 before file data.
	File-continuations have only word 0 before file data.
	File-starts and File-continuations have only checksum word
	after file data (and before next block).
   3	As documented on this page.


Time/date word format is:
	BYTE (3) hi-date (1)previous-media flag (20) time in mins (12) low-date

Previous-media flag is called PREMED.


*** Misc. notes:

IWCCHK is called from:
	FMTCON (from FMTCHK with cont block)
	RFDTER (with garbaged WC word instead of valid cont block)
	TCOPS4 (in TCOPIN, with garbaged or valid WC word for cont block)

FMTCHK is called from:
	TCOPSS (tape copy, cont block not found)
	RFDT2 (in RFDATA, with data left in file being read from tape)
	RDFIL0 (in RDFIL, looking for new file)

RDFIL is called from:
	LSTLP (TLIST)
	DMRED1 (after phys EOT)
	KMRED1 (after phys EOT)
	RSTG4 (RESTORE)
	TCOP4 (tape copy)
	FIXPS0 (PICKUP)
	MTRV2 (MRESTORE)

end of comment $
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           subttl	Database Format: DART.DAT, DART.ARC, INDEX.DAT, INDEX.ARC ;

comment 

The Dart Database

The disk files DART.DAT and DART.ARC contain the information about what
files are dumped on what system backup tapes.  This includes both T
(temporary) and P (permenent) tape information.

Each dump merges more data into DART.DAT.  Since DART.DAT can get very big,
this merging process can take a long time.  This merging process is kept
relatively fast by giving the Dart command ARCHIVE to merge most of the
DART.DAT information into DART.ARC (archive) every so often (say, once a
year).  However, the T tape data is never merged into DART.ARC, since T
tapes are only temporary.  When an ARCHIVE command is done, the P tape data
is moved from DART.DAT into DART.ARC and the T tape data is left in (a new
smaller) DART.DAT.


Format of the Files: DART.DAT, DART.ARC

DART.DAT and DART.ARC have exactly the same structure.  Although this file
format is explained below, you might also want to look at the Dart routine
VERDAT, which verifies the format of a DART.DAT (or DART.ARC) file -- the
format can be deduced from that very thorough verifying routine.

The file structure is fairly simple, consisting of Index Blocks and Data
Blocks.  Each index or data block is one disk 200-word record.  The first
record of the file is an index block.  Word 176 of each index block points
to the next index block.  All file records that are not in the list of index
blocks are data blocks.

An Index Block consists of pairs of words containing: (1) the name of a PPN
and (2) the word address in the file where the data for that PPN starts.
Each index block is one 200-word record, with word 176 of the block
containing the word address in the file of the next index block, if any.
Word 177 is always zero.  The PPNs are in Dart PPN order within the
collection of index blocks.  A PPN of zero marks the end of the index
data -- word 176 of the block containing the first zero PPN is also zero,
indicating no more index blocks.

Index     Word	+---------+
Block	    0 	|   PPN   |
		+---------+
            1	| pointer |
		+---------+
	    2	|   PPN   |
		+---------+
	    3	| pointer |
		+---------+
		    ...
		+---------+
	  174	|   PPN   |
		+---------+
	  175	| pointer |
		+---------+
	  176	| nxt idx | Word address of next index block.
		+---------+
	  177	|    0    |
		+---------+

The Data Blocks hold the dump information for all disk files.  The dump data
in a file occurs in Dart PPN order (see MFDSOR for the exact way PPNs are
sorted).  Within a PPN, data is in order by signed-36-bit filename and then
by signed 18-bit extension.  All the dump entries for a given file are
contiguous.  The information kept for each file is a list of tape/date data
for each time the file has been backed up in a system class (T or P) dump.
A single tape/date entry for one file contains two half-word values: (1) the
number of the tape holding the file and (2) the dumped disk file's date last
written as of that dump.  The tape number has the '400000 bit on if it is a
T tape; otherwise it is a P tape.

NEW as of 26 Dec 86: The high-order bits of the date right half-word have
special meanings.  Here are all the bits of the tape/date dump word.
[For actual symbol definitions, see p. 10 of this file.]

    400000,,0	This bit is on if the tape is a T tape.

    200000,,0	This copy of the file had previous-media errors and thus
  (PRMERR bit)	is presumably not entirely valid.  More information is
		contained in the previous-media error data block on the
		tape indicated.

    140000,,0	High-order bits in the relative dump number, which is the
  (RDHMSK bits)	number of the particular dump within the given tape that
		this copy of the file occurs in.  Necessary because the
		same-named file may occur several times in multiple dumps
		on the same (P) tape.

    20000,,0	(not implemented yet, but reserved to mean:) This copy of
		the file apparently has data errors (in the current media).
		Therefore, you might want to find another version instead.

    37777,,0	tape number (P or T, depending on 400000,,0 bit above)
  (TAPMSK bits)	(currently includes reserved 20000,,0 bit above)

    0,,700000	Low-order bits in the relative dump number.  See RDHMSK above.
  (RDLMSK bits)

    0,,77777	Date written of the disk file dumped here.  (System date format.)
  (DATMSK bits)



Dump Data for one PPN (immediately followed by data for next PPN):

	PPN
	file		;files are in order by signed 36-bit filename, then ext
	ext,,count	;count is number of tape,,date words following
	tape,,date
	tape,,date
	...
	tape,,date
	file
	ext,,count
	tape,,date
	tape,,date
	...
	tape,,date
	0		;end of data for this PPN


Format of New (Proposed) Additional Files: INDEX.DAT, INDEX.ARC

To speed up the LOCATE and PUMPKIN commands, we will add a second level index
file for each of DART.DAT and DART.ARC.  The second level index files (which
could also be included in the main files) will be called INDEX.DAT (for
DART.DAT) and INDEX.ARC (for DART.ARC).  These files will speed up the
search for a given PPN, which currently involves reading through about 200
index blocks scattered around the disk.

The INDEX.* files will contain indexes of index blocks, with the initial PPN
of each index block and the pointer to that index block, like this:

Second level index file (each line is a word):

	First PPN of 1st index block
	Word address of 1st index block
	First PPN of 2nd index block
	Word address of 2nd index block
	First PPN of 3rd index block
	Word address of 3rd index block
	...
	First PPN of Last index block
	Word address of Last index block
	0	;end of Second Level Index
	0

The program INDEX.FAI generates INDEX.DAT from DART.DAT or INDEX.ARC
from DART.ARC.

end of comment 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          subttl	flag bit definitions ;
;RIGHT SIDE

SDEF	ALLFLG,1			;* HAS BEEN SEEN IN A SIXBIT TERM
SDEF	ALLFIL,2			;* SEEN FOR FILE NAME
SDEF	ALLEXT,4			;* SEEN FOR FILE EXTENSION
SDEF	ALLPRJ,10			;* SEEN FOR PROJECT NAME
SDEF	ALLPRG,20			;* SEEN FOR PROGRAMMER NAME
SDEF	GOTEXT,40	;(not in FL, but in FSEXT).
SDEF	SCANON,40			;WE HAVE DONE A RESCAN
SDEF	MRUNCM,100			;WE HAVE SEEN A MONITOR LEVEL RUN COMMAND
SDEF	ABFILE,200			;ADVANCE/BACKSPACE FILE - NOT RECORD
SDEF	ADVCOM,400			;ADVANCE - NOT BACKSPACE COMMMAND
SDEF	PURCOM,400			;PURGE COMMAND - NOT PDUMP OR FDUMP
SDEF	INDON,1000			;SET WHILE WE ARE READING AN INDIRECT COMMAND
SDEF	INDEOF,2000			;SET WHEN EOF SEEN ON INDIRECT FILE.
SDEF	LSTON,4000			;SET WHILE WE ARE DOING A LIST OPERATION
SDEF	LSTTTY,10000			;SET IF LISTING DEVICE IS A TTY.
SDEF	MTAEOT,20000			;SET IF WE READ LOGICAL END OF TAPE
SDEF	SAFETY,40000			;SET WHILE WE DO A SAFETY LOOKUP
SDEF	LOOKDN,100000			;A LOOKUP HAS BEEN DONE (OTHERWISE MTAPE)
SDEF	FULL,  200000			;FULL DUMP REQUIRED
SDEF	PCLASS,400000			;PERMANENT CLASS DUMP

SDEF	ALLMSK,ALLFIL!ALLEXT!ALLPRG!ALLPRJ	;MASK FOR ALL WILD SPECS.

;LEFT SIDE
SDEF	IGNEOT,     1			;IGNORE EOT WHILE READING/WRITING
SDEF	MCLOSE,     2			;AN OUTPUT CLOSE ON THE MTA HAS JUST BEEN DONE.
SDEF	UFDEOF,     4			;EOF SEEN ON CURRENT UFD.
SDEF	DEOF,      10			;EOF ON DART.DAT IN MERGE (ARCHIVE/LOCATE)
SDEF	DNEED,     20			;NEED A NEW RECORD FROM DART.DAT WHEN CLEAR!
SDEF	TEOF,      40			;EOF SEEN ON TAPE-FILE IN MERGE
SDEF	AEOF,      40			;EOF SEEN ON ARC FILE (ARCHIVE/LOCATE)
SDEF	TNEED,    100			;NEED DATA FROM TAPE FILE WHEN BIT CLEAR!
SDEF	ANEED,    100			;NEED DATA FROM ARC-FILE WHEN BIT CLEAR!
SDEF	RDHACK,   200			;hack indicating we're in middle of FIXPOS
SDEF	MOUNT,    400			;SET WHEN WE REQUIRE MT MOUNT OPERATION.
SDEF	UDPGO,   1000			;CURRENT TRANSFER IS USING THE UDP
SDEF	DMEMRA,  2000			;STATE MEMORY FILE (DART.MEM) IS OPEN RA
SDEF	L.NOD,   4000			;NODUMP COMMAND (NOT DUMP)
SDEF	L.WLDS, 10000			;WILD STRUCTURE IN LOCATE
SDEF	L.TURK,	20000			;TURKEY COMMAND, P OR T OK FOR GETANS
					;ALSO FLAGS OLD .EUQ FILE PICKUP IN PRESTORE
SDEF	L.PUMP, 40000			;PUMPKIN COMMAND, /SWITCH OK IN SCAN
					;ALSO FLAGS PLIST (VS. PRESTORE)
SDEF	L.SWIT,100000			;NOW PARSING /SWITCH IN SCAN
SDEF	L.BOTH,200000			;FOUND SAME FN IN DAT AND ARC

;FREE STORAGE PARAMETERS
SDEF FSDEV,0		;DEVICE NAME
SDEF FSNAM,1		;FILE NAME
SDEF FSEXT,2		;FILE EXTENSION,,FLAGS
SDEF FSPPN,3		;FILE PPN
SDEF FSTAP,4		;Tape number or date for Restore or Locate
SDEF PFSLEN,4		;Word where pumpkin request data starts (old FSLEN)
SDEF FSLEN,5		;SIZE OF AN FS. BLOCK.

SDEF FSPNAM,PFSLEN	;EXTENSION TO TERM BLOCKS for pumpkin
SDEF FSPEXT,PFSLEN+1
SDEF FSPPPN,PFSLEN+2
SDEF FSPREQ,PFSLEN+3	;EXTRA WORD FOR REQUESTOR'S PPN
SDEF FSPDAT,PFSLEN+4	;DATE OF REQUEST
SDEF FSPNXT,PFSLEN+5	;next term block
SDEF FSPLEN,PFSLEN+6	;EXTENDED LENGTH

;DEVCHR BITS	LEFT SIDE
SDEF	TTYBIT,10			;DEVICE IS A TTY
SDEF	DIRBIT,4			;DEVICE HAS A DIRECTORY.
SDEF	DEVDSK,200000
IFN UDPSW,<
SDEF	DEVUDP,100000			;DEVICE IS A UDP
>;IFN UDPSW
SDEF	DEVMTA,20			;device is a magtape
                       subttl	command syntax ;

COMMENT $

Every command is a single line; each command line must end with a CRLF.
The first thing on the line is a command name.
Command names may be abbreviated down to the minimum unique name.
Parameters within a command cannot be abbreviated (e.g., 'RECORD' in
an ADVANCE or BACKSPACE command).  Device names and file names must be
completely specified wherever they appear; the only exeception is that parts
of a file specification, (the name, extension, project, and programmer)
can specified by an asterisk, "*", matching any value for the given part.

Commands are:

DUMP  		;Dump files for a user
RESTORE		;RESTORE FILES FOR A USER
TURKEY		;TELL WHO LAST USED A DART TAPE
PUMPKIN		;ASK GREAT PUMPKIN TO RESTORE FILE(s)

MRESTO		;MAJOR RESTORE  - PRIVILEGED
FDUMP 		;FULL DUMP      - PRIVILEGED
PDUMP 		;PERMANENT DUMP - PRIVILEGED
TDUMP 		;TEMPORARY DUMP - PRIVILEGED

PICKUP		;PICKUP LAST COMMAND AFTER A CRASH
REWIND		;REWIND
UNLOAD		;REWIND AND UNLOAD TAPE
ADVANCE		;ADVANCE FILE OR RECORD
BACKSPACE	;BACKSPACE FILE OR RECORD
LIST  		;LIST THE TAPE
LOCATE		;LOCATE WHERE THE NAMED FILES WERE DUMPED
EOT   		;ADVANCE TO END OF TAPE

IF THE DEVICE NAME IS OMITTED, MTA0 IS ASSUMED.

REWIND    {<DEV>{:~~
UNLOAD    {<DEV>{:~~
EOT	  {<DEV>{:~~

ADVANCE   {FILE|RECORD~{<DEV>{:~~{<COUNT>~
BACKSPACE {FILE|RECORD~{<DEV>{:~~{<COUNT>~

LIST      {<DEST>_~{<DEV>:~

DUMP      {<DEST>_~<SOURCE>
RESTORE   {<DEST>_~<SOURCE>
PUMPKIN   {/<SWITCH>~{<DEST>_~<SOURCE>

FDUMP	  {<DEV>:~
TDUMP	  {<DEV>:~
PDUMP	  {<DEV>:~

MRESTO
PICKUP

LOCATE	<SOURCE>

TURKEY	P<NUMBER> | T<NUMBER>

<SOURCE>   {{<DEV>:~{[<PRJ>,<PRG>]~@~
		{<DEV>:~{<FILENAME>{.<EXT>~~{[<PRJ>,<PRG>]~{,<SOURCE>~

<DEST>  {<DEV>:~{<FILENAME>{.<EXT>~~{[<PRJ>,<PRG>]~

<COUNT>	 <NUMBER>

<SWITCH>  P<NUMBER> | T<NUMBER> | <DATE>
<DATE>  <DAY>-<MONTH>{-<YEAR>~ | <NMONTH>/<DAY>{/<YEAR>~
<DAY>  <NUMBER>
<NMONTH>  <NUMBER>
<MONTH>  <NMONTH> | JAN | FEB | ... | DEC
<YEAR>  <NUMBER>

<NUMBER>  "STRING OF DECIMAL DIGITS"

THE FOLLOWING TERMS ARE DEFINED BY COMMON USAGE:
<FILENAME>
<EXT>
<PRJ>
<PRG>
<DEV>

$

                                                                                                                                                                                                                                                                                                                                                                                    subttl	magtape parameters	;MTNOOP REWIND BACKR UNLOAD BACKF SKIPR SKIPF WREOF WBLANK SKIPT SLICE0 SLICE1 IOIMPM IODERR IODTER IOBKTL IOEOF IOACT IOBOT IOTEND IOPAR DE6250 DE1600 DE1601 DEN800 DEN556 DEN200 IONRCK IOWC IMODE ;

;EVERYTHING YOU WANTED TO KNOW ABOUT MAGTAPES BUT WERE AFRAID TO ASK

;MTAPES:
OPDEF	MTNOOP	[MTAPE	0]	;NO OPERATION. WAIT FOR CONTROLLER TO FINISH
OPDEF	REWIND	[MTAPE	1]	;REWIND THE TAPE TO LOAD POINT
OPDEF	BACKR	[MTAPE	7]	;BACKSPACE RECORD
OPDEF	UNLOAD	[MTAPE	11]	;REWIND AND UNLOAD TAPE
OPDEF	BACKF	[MTAPE	17]	;BACKSPACE FILE.
				;PUTS TAPE AT LOAD POINT OR IN FRONT 
				;OF EOF OF PREVIOUS FILE
OPDEF	SKIPR	[MTAPE	6]	;ADVANCE RECORD
OPDEF	SKIPF	[MTAPE	16]	;ADVANCE FILE
OPDEF	WREOF	[MTAPE	3]	;WRITE END OF FILE
OPDEF	WBLANK	[MTAPE	13]	;WRITE 3 INCHES OF BLANK TAPE.
OPDEF	SKIPT	[MTAPE	10]	;SKIP TO END OF TAPE -- STOPS AFTER
				; 2 EOFS OR (?) AN EOF AFTER EOT MARK
OPDEF	SLICE0	[MTAPE 220]	;set slice level to 0
OPDEF	SLICE1	[MTAPE 221]	;set slice level to 1

;IO STATUS BITS

SDEF	IOIMPM,400000		;WRITE LOCKED OR CONTROLLER ILLEGAL OPERATION
SDEF	IODERR,200000		;DATA MISSED, TAPE IS BAD OR CONTROLLER HUNG
SDEF	IODTER,100000		;PARITY ERROR
SDEF	IOBKTL,40000		;RECORD READ EXCEEDS BUFFER SIZE
SDEF	IOEOF,20000		;EOF MARK SEEN
SDEF	IOACT,10000		;DEVICE IS ACTIVE
SDEF	IOBOT,4000		;LOAD POINT
SDEF	IOTEND,2000		;TAPE END
SDEF	IOPAR,1000		;PARITY. 0=ODD, 1=EVEN
SDEF	DE6250,600		;DENSITY = 6250 (TU78, see DDNTBL in PHYDAT)
SDEF	DE1600,400		;DENSITY = 1600 (  "    " )
SDEF	DE1601,200		;DENSITY = 1600 (  "    " )
SDEF	DEN800,600		;DENSITY = 800
SDEF	DEN556,400		;DENSITY = 556
SDEF	DEN200,200		;DENSITY = 200
SDEF	IONRCK,100		;SUPRESS ERROR RETRIES
SDEF	IOWC,20			;INHIBIT SYSTEM COMPUTATION OF OUTPUT WC
SDEF	IMODE,10		;IMAGE MODE

                                                                                                              subttl	disk parameters  (Stanford) ; DDNAM DDEXT DDPRO DDPPN DDLOC DDLNG DREFTM DDMPTM DGRP1R DNXTGP DSATID DQINFO DQAUT DQVER DDWPPN DDOFFS ; UNAM UEXT UPRO ULOC ULEN UTIME UREFT UDMPT UQINFO UOFFST
;	EVERYTHING YOU WANTED TO KNOW ABOUT THE DISK BUT WERE AFRAID TO ASK

SDEF	DDNAM,0		;.RBNAM		;FILE NAME
SDEF	DDEXT,1		;.RBEXT		;EXT,,CREATION DATE (AND HIGH DATE)
SDEF	DDPRO,2		;.RBPRV		;PROTECTION, MODE, TIME & DATE
SDEF	DDPPN,3		;.RBPPN		;PPN OF FILE OWNER
SDEF	DDLOC,4		;--		;LOCATION OF FIRST BLOCK OF THIS GROUP
SDEF	DDLNG,5		;.RBSIZ		;+LENGTH OF THIS FILE IN WORDS.
SDEF	DREFTM,6	;.RBEXT (!)	;DATE OF LAST REFERENCE
SDEF	DDMPTM,7	;.RBNCA		;DUMP STATUS WORD
SDEF	DGRP1R,10	;--		;POINTER TO RECORD 1 OF GROUP 1
SDEF	DNXTGP,11	;--		;BLOCK NUMBER OF NEXT GROUP
SDEF	DSATID,12	;.RBDEV		;SATID OF THIS FILE
SDEF	DQINFO,13	;--		;START OF 5 WORDS FOR LOGIN,ETC
IFE STANSW,<
SDEF	DQAUT,15	;.RBAUT
SDEF	DQVER,16	;.RBVER
>;IFE STANSW
SDEF	DDWPPN,16			;PPN of writer (tape format 2 and later)
SDEF	DDOFFS,17			;DISK OFFSET (format 2 and up), normal=1
		;DDOFFS has normal=1, unlike real disk retrieval, where normal=0

;;NOTE: THE NON-STANFORD VERSION STORES RETRIEVAL INFORMATION ON THE TAPE
;;	IN SAIL FORMAT, RATHER THAN USING DEC'S RIB ORGANIZATION, SO THAT
;;	MAYBE SOMEDAY DART WILL BE USABLE AS A SAIL-IRCAM FILE TRANSPORTER
;;	GIVEN THEY GET 9-TRACK DRIVES OR WE GET 7-TRACK DRIVES!!  TO THIS
;;	END, THE DDOFFS WORD IS ALWAYS STORED =1 IN THE NON-SAIL VERSION.

IFN STANSW,<
;UFD ENTRY FORMAT
UNAM==0
UEXT==1
UPRO==2
ULOC==3
IFN FTLUFD,<
ULEN==4				;FILE LENGTH IN UFD
UTIME==5			;EXTENDED TIME LAST WRITTEN
UREFT==6			;REFTIME
UDMPT==7			;DMPTIME
;UNUSED==10			;(DGRP1R)
;UNUSED==11			;(DNXTGP)
;USATID==12			;DSATID
UQINFO==13; 14, 15, 16		;DQINFO
UOFFST==17			;DOFFST
>;IFN FTLUFD
>;IFN STANSW

SDEF	UFDN,20			;NUMBER OF WORDS IN A DIRECTORY ENTRY

;	BITS FOR DEVICE MODE 
SDEF	GARBIT,200		;ALLOWS ERROR RETURN FROM BAD RETRIEVAL
SDEF	DMPBIT,400		;USE 6 WORD LOOKUP/RENAME BLOCKS.


IFE STANSW,<			;ASSUME PARALLEL FEATURES DON'T EXIST ELSEWHERE
SDEF	GARBIT,0
SDEF	DMPBIT,0
>;IFE STANSW

;	BITS FOR CLOSE UUO
SDEF	NUPACC,0		;STANFORD: "DON'T UPDATE ACC" NOT AVAIL.

IFE STANSW,<
SDEF	NUPACC,110		;ELSEWHERE, "DON'T UPDATE ACCESS TIME" BITS
>;IFE STANSW

COMMENT $
	DEFINITION OF THE DDMPTM WORD

BIT	FUNCTION
0	SET BY T CLASS DUMP. CLEARED BY P CLASS.
1-3	PERMANENT DUMP COUNT.  INCREMENTED BY P CLASS DUMPS
	  (PCOUNT is a byte poiner to this field in FILINF+DDMPTM.)
4	DUMP DATE INVALID.
	  (PINVAL is a byte poiner to this field in FILINF+DDMPTM.)
5	DELETE AFTER DUMPING.  IF SET, FILE WILL BE DELETED AFTER
	  IT HAS BEEN PDUMPED TWICE.
6	DUMP NEVER.  (NON-STANFORD ONLY. UNUSED AT SAIL.)
7-8	RESERVED FOR FUTURE EXPANSION
9-20	TAPE NUMBER OF THE MOST RECENT DUMP TAPE.
	  (PTAPEN is a byte poiner to this field in FILINF+DDMPTM.)
21-35	DUMP DATE - 15 BIT SYSTEM FORMAT DATE OF THIS DUMP.
	  (PDDATE is a byte poiner to this field in FILINF+DDMPTM.)

IFE STANSW, BIT 6 MEANS DUMP NEVER.  IFN STANSW, 400 BIT IN PROTECTION
CODE MEANS DUMP NEVER, BUT WE CAN'T USE THAT BECAUSE IT REALLY MEANS
SOMETHING IN THE DEC MONITOR.  THIS IS WHY I USE THE NONPRIVILEGED
CUSTOMER RIB WORD INSTEAD OF THE PRIVILEGED ONE, SO PEOPLE CAN SET THE
DUMP NEVER BIT.
$

;Left-Half bits in the Dump-date word (DDMPTM)
SDEF	REAPBT,10000	;Flag to delete after dumping twice (i.e., Reap)
                                                                                                                                                                                                                                                                                                                                                                                   subttl	data storage	;PRMERR RDHMSK TAPMSK RDLMSK DATMSK RDHBTS RDLBTS RDHPOS RDLPOS INFOSIZ RECSIZ BRCSIZ ; RDHBTS RDLBTS RDMAX RDHPOS RDLPOS CRESTA CREST1 RRCSZ RRCSZ2 NRRCSZ WRCSZ WRCSZ2 NWRCSZ LKBLK GOBBLK STRUCT SYSPPN ERSPPN UFDEBK DAWPRV PROPRV REAPRV WRTPRV AAOPRV INFPRV LUPPRV LIVPRV DUMPRV DUMPER DUMPER DUMPER GOD RDOFFS WROFFS DUMPER GOD UUOCON CRLF PDLIST IPDL ONEPPN MFDPTR INVERS RDVERS TAPCLS THSTAP GLOTAP FSPTR DEST TBASE DEFDEV DEFPPN IDEV INAM IEXT IPPN FDEV FNAM FEXT FPPN STKPPN STKDEV STKBIT MTDEV MTNAM MTEXT MTPPN RSTDEV RSTNAM RSTEXT RSTPPN LSTDEV LSTNAM LSTEXT LSTPPN FILBLK LASSAV DSKMM0 DSKMM1 DSKMM2 DSKMM3 XDMPUT RHDCOP RHDLEN RHDART RHTYPE RHDATE RHDPPN RHDTAP RHDNBR RHDPOS RHDRES RHDONE RHDZER RHDCHK HEDLEN HEDLE0

;Fields in database tape/date word in DART.DAT or DART.ARC for each file dumped.
;400000,,0		;this is a T-tape (else P tape)
SDEF PRMERR,200000	;LH: file had previous-media errors, so not entirely valid
SDEF RDHMSK,140000	;LH: high bits in rel dump nbr
; 20000,,0		;LH: reserved: this file apparently has current-media errors
SDEF TAPMSK,37777	;LH: tape number field (currently includes above "reserved" bit)
SDEF RDLMSK,700000	;RH: low bits of rel dump nbr
SDEF DATMSK,77777	;RH: date written of the dumped file, also used by Pumpkin

;The dump number bits (RDHMSK,,RDLMSK) are split: 140000,,700000
;in the dump date/tape number word.
;The bits in the left half are the high order bits for the relative dump number.
;The defs below must agree with above defs of RDHMSK and RDLMSK.
RDHBTS__2	;number of high bits in rel dump nbr
RDLBTS__3	;number of low bits in rel dump nbr
RDMAX_1<RDHBTS+RDLBTS>-1 ;max number that fits in rel dump nbr field
RDHPOS__3	;bit position of rightmost high bit in rel dump nbr
RDLPOS__=20	;bit position of rightmost low bit in rel dump nbr

repeat 0,<
CRESTA:	TRLEOT			;UNEXPECTED EOT GOES JRST @CRESTA
				;PRESTORE CHANGES IT TO PRUEOT

CREST1:	ILLFM2			;ILLEGAL TAPE FORMAT GOES JRST @CREST1
				;PRESTORE CHANGES IT TO PRPOSN
>;repeat 0

SDEF	INFOSIZ,20		;SIZE OF IMPORTANT PART OF RETRIEVAL
SDEF	RECSIZ,2400		;MAX SIZE OF RECORDS ON TAPE (800 bpi)
SDEF	BRCSIZ,24000		;Max record size for 6250 bpi tapes

;record size for reading
RRCSZ:	BRCSIZ			;RECSIZ or BRCSIZ depending on density
RRCSZ2:	BRCSIZ-2		;record size minus two
NRRCSZ:	-BRCSIZ			;negated record size

;record size for writing
WRCSZ:	BRCSIZ			;RECSIZ or BRCSIZ depending on density
WRCSZ2:	BRCSIZ-2		;record size minus two
NWRCSZ:	-BRCSIZ			;negated record size

IFE STANSW,<
DEFINE LKDEF(XX)<
SDEF(XX,.-LKBLK)
0>

LKBLK:	LKLEN-1
LKDEF(.RBPPN)
LKDEF(.RBNAM)
LKDEF(.RBEXT)
LKDEF(.RBPRV)
LKDEF(.RBSIZ)
LKDEF(.RBVER)
LKDEF(.RBSPL)
LKDEF(.RBEST)
LKDEF(.RBALC)
LKDEF(.RBPOS)
LKDEF(.RBFT1)
LKDEF(.RBNCA)
LKDEF(.RBMTA)
LKDEF(.RBDEV)
LKDEF(.RBSTS)
LKDEF(.RBELB)
LKDEF(.RBEUN)
LKDEF(.RBQTF)
LKDEF(.RBQTO)
LKDEF(.RBQTR)
LKDEF(.RBUSD)
LKDEF(.RBAUT)
SDEF(LKLEN,.-LKBLK)

GOBBLK:	0		;GOBSTR ARG BLOCK
	-1
	0

STRUCT:	0		;STRUCTURE NOW BEING DUMPED
SYSPPN:	0		;PPN FOR SYS DEVICE
ERSPPN:	0		;PPN EQUIVALENT FOR ERSATZ DEVICE IN LOCATE

UFDEBK:	LKLEN-1		;ENTER BLOCK FOR MAKING A UFD
	1,,1		;.RBPPN
REPEAT .RBSTS-.RBNAM,<
0>
	400000		;.RBSTS
	0
	0
	377777,,777777	;.RBQTF
	377777,,777777	;.RBQTO
	0
	0
	0
>;IFE STANSW

IFN STANSW,<
;NOTE: All privilege/group bit names (including groups bits)
;are FULL WORD VALUES in DART!

;GROUP ACCESS/PRIVILEGE BITS
;None of these symbols are actually used in the code except GROUPS and MASPRV.

SDEF(MASPRV,1)		;Full word values (happen to be in RH)
SDEF(SYSPRV,2)
SDEF(SCYPRV,4)
SDEF(DECPRV,10)
SDEF(ACTPRV,20)
SDEF(CSPPRV,40)

SDEF(GROUPS,47)		;ALL OF THE ABOVE.

;More privileges: note again these are FULL WORD VALUES.
DAWPRV==<200000,,0>
PROPRV==<100000,,0>
REAPRV==< 40000,,0>
WRTPRV==< 20000,,0>
AAOPRV==< 10000,,0>
INFPRV==<    20,,0>
LUPPRV==<     1,,0>
LIVPRV==<0,,200000>

DUMPRV:	PROPRV!REAPRV!WRTPRV!INFPRV! ifn fthelp,<dawprv;>0 ;PRIVS REQUIRED BY THE SYSTEM DUMPER
IFN FTCOPY,<
IFE DBGSW,<
DUMPER:	' MCSYS'		;directory for master tape copy output files
Printx Assembling for master tape copy, on directory: MC,SYS.
>;IFE DBGSW
IFN DBGSW,<
DUMPER:	'MC4SYS'		;directory for master tape copy output files
Printx Assembling for DEBUGGING master tape copy, on directory: MC4,SYS.
>;IFN DBGSW
>;IFN FTCOPY
IFE FTCOPY,<
DUMPER:	'DMPSYS'		;AT STANFORD THE DUMPER'S NAME
>;IFE FTCOPY
GOD:	'  1  1'		;AT STANFORD THE GUY WITH ALL THE UFDS

RDOFFS:	'GODMOD'		;STANFORD READ FILE OFFSET
	20			;OPCODE
	0			;OFFSET NUMBER HERE (1=NORMAL)
	0			;ACTUAL FILE LENGTH IN WORDS

WROFFS:	'GODMOD'		;WRITE FILE OFFSET
	21			;OPCODE
	0			;SET TO DESIRED OFFSET (1=NORMAL)
>;IFN STANSW

IFE STANSW,<
DUMPER:	1,,2			;EVERYWHERE ELSE THE DUMPER IS 1,2
GOD:	1,,1			;HOW THEY SPELL ONE OF THE 9 BILLION NAMES OF GOD
>;IFE STANSW
UUOCON:	0
	JRST	.UUCON		;CALL UUO ROUTINE.

CRLF:	BYTE(7)15,12
PDLIST:	BLOCK PDLEN		;normal stack
IPDL:	BLOCK IPDLEN		;interrupt level stack

ONEPPN:	0			;THE ONE PPN THAT IS BEING SCANNED FOR WILD FILE
MFDPTR:	0			;IOWD TO INCORE COPY OF MFD

INVERS:	0			;input tape format number: IOVER
RDVERS:	0			;Dart version number read from tape header/trailer
TAPCLS:	0			;tape class -1 = unk; 0 = user; 1=Temp; 2=Perm
THSTAP:	0			;Current input tape number from header.
				;Zero if not a system tape, else
				;tape number + 400000 if T-class
GLOTAP:	0			;global value of tape/date switch in Pump/Rest/etc.

FSPTR:	0			;POINTER TO LAST TERM
DEST:	0			;POINTER TO DESTINATION TERM
TBASE:	0			;POINTER TO BASE OF SOURCE TERMS.

DEFDEV:	0			;DEFAULT DEVICE SET BY DEV:@FILE
DEFPPN:	0			;DEFAULT PPN SET BY [P,PN]@FILE

IDEV:	0			;INDIRECT DEVICE
INAM:	0			;INDIRECT NAME
IEXT:	0			;INDIRECT EXTENSION
IPPN:	0			;INDIRECT PPN

FDEV:	0			;DEVICE
FNAM:	0			;NAME
FEXT:	0			;EXTENSION
FPPN:	0			;PPN

STKPPN:	0			;SAVE THE STICKY PPN HERE.
STKDEV:	0			;SAVE THE STICKY DEVICE HERE.
STKBIT:	0			;SAVE [*,*] BITS HERE

	0			;EXTRA CELL FOR MTDEV BLOCK. - USED IN DUMPGO
MTDEV:	0			;NAME OF MAG TAPE FOR DUMP.
MTNAM:	0			;FILE NAME ON MAGTAPE
MTEXT:	0			;FILE EXTENSION ON MAGTAPE
MTPPN:	0			;FILE PPN ON MAGTAPE

	0			;EXTRA CELL FOR RSTDEV BLOCK - USED IN RESTGO
RSTDEV:	0			;DEVICE TO RESTORE ONTO
RSTNAM:	0			;FILE NAME TO RESTORE ONTO
RSTEXT:	0			;FILE EXTENSION TO RESTORE ONTO
RSTPPN:	0			;FILE PPN TO RESTORE ONTO

	0			;EXTRA CELL FOR LSTDEV BLOCK - USED IN LISTGO
LSTDEV:	0			;LISTING DEVICE
LSTNAM:	0			;LISTING FILE NAME
LSTEXT:	0			;LISTING FILE EXTENSION
LSTPPN:	0			;LISTING FILE PPN.

FILBLK:	BLOCK	UFDN		;A PLACE FOR LOOKUPS/ENTERS.
LASSAV:	BLOCK	4		;NAME OF FILE THAT WAS LAST SAVED.

DSKMM0:	0			;count of records written in file on DSKMSC chan
DSKMM1:	0			;byte ptr for depositing bytes for output
DSKMM2:	0			;remaining byte count in our dump-mode buffer
DSKMM3:	0			;FLAG FOR ASCII/BINARY
XDMPUT:	0			;INSTR. XCTED AT DMPUT.  USUALLY SOSGE DSKMM2

;The following must be together in this order.  This is the info from a tape
;header or trailer read by RDFIL.
RHDCOP::		;block copied to output tape by TCPHTR
RHDLEN:	0		;header/trailer word-count word
RHDART:	0		;header/trailer 'DART  ' word
RHTYPE:	0		;header/trailer type word: *HEAD* or *TAIL*
RHDATE:	0		;header/trailer time and date word
RHDPPN:	0		;header/trailer writer-ppn word
RHDTAP:	0		;header/trailer class/tape-number word
RHDNBR:	0		;header/trailer relative/absolute dump numbers (rel,,abs)
RHDPOS:	0		;header/trailer tape position in feet
RHDRES:	0		;header/trailer reserved word (unused currently)
RHDONE:	0		;header/trailer test word of all ones
RHDZER:	0		;header/trailer test word of all zeroes
RHDCHK:	0		;header/trailer rotated checksum word
;Possible valid lengths for header and trailer blocks (see FMTCHK).
HEDLEN__.-RHDLEN-1	;nbr of words in tape header/trailer after word count word.
HEDLE0__5		;old hdr length before tape format 3, Dart version 6.
                                                                                                                                                                                                                                                                      ;more data storage		;TAPERR CHKERR CHEIOR TSTERR MTRERR MTRSHR TOOLNG TOOSHR SHRTGO UNEEOT BADWCW CONDFF CONNBG BADFMT BADDAT ; FLSDPS OMMNAM OMMEXT ODNAME REPCNT LOGPPN USRPPN DBGNTP DBGMFC DBGPPN TAPREG TAPREG AMBIG SAVDEL IWC WC FWC FSIZE IFSIZE MASCOP NOLIST MASDAF NOSAVM PRVPPN FSTRT TABORT TSKIP TSKIPN TSLICE SLILVL NREADS SAVBKN SAVNS3 LASTIM RECERR SRCDEV FILINF CONDEV CONINF QMODE CHKSUM STRNAM UNQSTR THSDAT THSDAX MTTREC MTFILN FIXCNT FIXSEA COPPED LCWRNF FILERS DARTHD BADHTR LMEDER PRMEND LMEDE1 REDERR MEDERR MRGERR ERDESC MEDPTR PSTDAT MLBAD MLGOOD MRETRY MNRET MXRET DRETRY NRETRY LRETRY SKIPFL REHARS

;Data for kludge to flush duplicate entries from .DAT during ARCHIVE cmd.
FLSDPS:	0		;nonzero RH if checking for duplicate names to flush
OMMNAM:	0		;old filename from .DAT file, for FLSDPS
OMMEXT:	0		;old extension from .DAT file, for FLSDPS
ODNAME:	0		;old PPN from .DAT file, for FLSDPS

REPCNT:	0			;REPEAT COUNT FOR ADVANCE/BACKSPACE
LOGPPN:	0			;LOGGED IN NAME OF THIS USER.
USRPPN:	0			;NAME OF THIS USER
IFN DBGSW,<
DBGNTP:	1			;WHEN DEBUGGING, NONZERO TO BYPASS TAPE OUTPUT
DBGMFC:	0			;WHEN DEBUGGING, COUNTER TO LIMIT MFD READING
DBGPPN:	'MC4SYS'		;WHEN DEBUGGING, PPN DEBUG PERSON WILL USE
printx For DEBUGGING, using  MC4,SYS  for Turkey info.
DEF	TAPREG,DBGPPN		;WHEN DEBUGGING, KEEP RECORDS IN DBGPPN
>;IFN DBGSW
IFE DBGSW,<
IFN STANSW,<
TAPREG:	' SSSYS'
>;IFN STANSW
IFE STANSW,<
TAPREG:	1,,2
>;IFE STANSW
>;IFE DBGSW
AMBIG:	0			;FOR DETECTING AMBIGUOUS COMMANDS AND MATCH UNDER MASK
SAVDEL:	0			;SAVE TERM DELIMITER HERE.
IWC:	0			;Word count remaining in record read from tape
WC:	0			;WORD COUNT OF REMAINING SPACE IN output RECORD
FWC:	0			;FILE WORD COUNT
FSIZE:	0			;FILE SIZE IN WORDS
IFSIZE:	0		;remaining input file size during tape copy, in words
MASCOP:	0		;nonzero if doing system master tape copy
NOLIST:	0		;-1 to suppress generation of tape listing file in merge
MASDAF:	0		;nonzero if reading date in master copy, holds stack ptr
NOSAVM:	-1		;-1 to enable messages at MASPSE, MASPIE
PRVPPN:	0		;nonzero if any output in current MT file during tape copy
FSTRT:	0		;flag indicating new file in TCDUMP
TABORT:	0		;nonzero if operator typed ESC 5 I to request tape abort
TSKIP:	0		;nonzero if operator typed ESC 7 I to request tape skip fwd
TSKIPN:	0		;number of MT files skipped in last TSKIP request
TSLICE:	0		;nonzero if operator typed ESC 9 I to toggle def slice level
SLILVL:	0		;nonzero for slice level (for tape reads) of 1, else 0
NREADS:	0		;number of tape records read recently by MTAINP (SLICHK)
SAVBKN:	0		;saved value of system's MTCBKN (records read by drive)
SAVNS3:	0		;saved value of system's MTCNS3 (slice-correction wins)
LASTIM:	0		;saved date,,time at last call to TYWHEN
RECERR:	0		;nonzero if last record read got MT read error

;Next two labels must be together.
SRCDEV:	0		;NAME OF STRUCTURE FROM WHICH MT FILE CAME.
FILINF:	BLOCK LLEAD3-1	;PARTIAL RETRIEVAL DATA OF CURRENT FILE, plus extra info

;Next two labels must be together.
CONDEV:	0		;device name in continuation block (IOVER3 and later)
CONINF:	BLOCK LLEAD3-1	;same as FILINF, but from Continuation Block on tape

QMODE:	0			;SET WHILE QUOTING SPECIAL SIXBIT CHARACTERS
CHKSUM:	0			;CHECKSUM (XOR) OF DATA WORDS
STRNAM:	0			;SAVE CURRENT STRUCTURE NAME HERE FOR READING
UNQSTR:	0			;[IRCAM] SYSTEM DUMP ON A SINGLE STR, NAME HERE
THSDAT:	0			;THE DATE TODAY IN SYSTEM FORMAT
THSDAX:	0			;THE DATE TODAY IN DAYCNT FORMAT
MTTREC:	0			;TOTAL OF ALL RECORDS WRITTEN ON MTA2
MTFILN:	0			;TOTAL OF ALL RECORDS WRITTEN ON THIS MT FILE.
FIXCNT:	0			;nbr of MT files to backup and search in FIXPOS
FIXSEA:	0			;nbr of MT files from BOT to logical EOT (FIXPOS)
COPPED:	0			;nonzero if copied files exist in current MT file

LCWRNF:	0			;non-zero: don't warn that file exists at Restore

;Next group of words contain auto-continue flags (-1) in LH and error cnts in RH.
FILERS:	0			;non-zero: don't stop for file errors
DARTHD:	0			;non-zero: don't stop at head-tail record w/o 'DART'
BADHTR:	0			;non-zero: don't stop at head-tail record w/o hd/tl

;Error data for one file read off tape.
;DO NOT CHANGE THE ORDER OF THESE.  They go onto copied DART tapes in this order.
;You can add new ones at the end (up to LMEDE1 of them).
;TAPERR must be first (see TYPMER).
;The final word of previous-media error data block contains a constant: PRMEND.
DEFINE ERRLST<
XX TAPERR,ADD,total number of tape errors for current file
XX CHKERR,ADD,checksum errors
XX CHEIOR,IOR,inclusive-or of error bits for all checksum errors
XX TSTERR,ADD,bad test constants in leader data
XX MTRERR,ADD,tape read errors
XX MTRSHR,ADD,tape records shorter than expected
XX TOOLNG,ADD,file longer than expected
XX TOOSHR,ADD,file shorter than expected
XX SHRTGO,ADD,tape records too short for Dart word count
XX UNEEOT,ADD,unexpected logical EOTs
XX BADWCW,ADD,bad file-continuation blocks
XX CONNBG,ADD,unexpected continuation blocks
XX CONDFF,ADD,wrong filenames in continuation blocks
XX BUFEND,ADD,continuation blocks without buffer space
XX BADWCS,ADD,inconsistent word counts
XX BADFMT,ADD,bad file-start blocks
XX BADDAT,ADD,bad date written has been zeroed
>;ERRLST

LMEDER__30		;length of previous media error info on tape
PRMEND__'$PEND$'	;constant stored in last word of prev media data block
LMEDE1__LMEDER-1	;number of prev media data before the constant at end

DEFINE XX(NAME,op,desc)< NAME: 0 >;named error cell
REDERR:: ERRLST	;media error data -- errors during current read
	 BLOCK LMEDE1+REDERR-.	;reserved for expansion
	 PRMEND		;constant at end of media error block

;Table of media errors parallel to REDERR above.  This data comes from the
;file-start and continuation blocks on tapes, indicating previous-media errors.
MEDERR:	BLOCK LMEDER	;previous media error data, read from trailer in file block

DEFINE XX(name,OP,desc)< OP A,REDERR(B) >;instruction to merge two error cells
;Table parallel to REDERR above: instructions to merge current
;  media errors with previous media errors (see TCDUME).
MRGERR: ERRLST
    REPEAT LMEDE1+MRGERR-.<
	ADD A,REDERR(B) ;fill out table, assuming rest are counts
    >;REPEAT
	IOR A,REDERR(B)	;For the constant word, OR the constant with any value read

DEFINE XX(name,op,DESC)< [asciz\DESC\]>;text describing type of error
ERDESC:	ERRLST
    REPEAT LMEDE1+ERDESC-.<
	[asciz/count of errors of unknown type/]
    >;REPEAT
	[asciz/constant '$PEND$' marking end of error block/]

MEDPTR:	0	;byte pointer into MEDERR array
PSTDAT:	0	;number of words of trailer info after file data

;NRETRY is number of read retries we do (not counting initial read) times
;MRETRY (which is just a multiplier to provide higher resolution).
;Upon a tape read error, we decrement NRETRY by MRETRY/MLBAD and if
;NRETRY/MRETRY rounded up changes and LRETRY is nonzero, then we tell
;system to limit retries to MNRET+(NRETRY/MRETRY) (rounded up).  Thus,
;after MLBAD consecutive read errors, we reduce the retry count by one.
;But, when a record is read OK, we increase NRETRY by MRETRY/MLGOOD
;(limiting it to a max of DRETRY), telling the system about the increase
;unless at max already.  See INCRET and DECRET, both called from TREAD2.

;Also, if NRETRY reaches -REHARD (that many consecutive bad records), then
;we reset NRETRY to a small positive amount to see if that helps (probably not).
MLBAD__3			;nbr of read errors to reduce retry cnt by 1
MLGOOD__5			;nbr of good reads to increase retry cnt by 1
MRETRY__MLBAD*MLGOOD		;arbitrary multiplier for retry count
MNRET__1			;minimum number of read retries no matter what
;;MXRET__=10			;maximum number of read retries (system default)
MXRET__=3			;maximum number of read retries
DRETRY__<MXRET-MNRET>*MRETRY	;default nbr of read retries on tape read error
NRETRY:	DRETRY			;current nbr of read retries on tape read error
LRETRY:	0			;nonzero to limit read retries
SKIPFL:	0			;flip-flop -- non-zero means skip file on losing
REHARS__<20*MLBAD>-<DRETRY/MRETRY> ;after this many, we skip to next tape file
;REHARD__=20			;after this many consecutive errors, retry some
;REHARC__<3-MNRET>*MRETRY	;number of retries after REHARD hit (3)
;IFL REHARC,<.FATAL REHARC can't be negative, or DECRE2 will screw up>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ;more data storage		; FONYFI TTYWRD PRMOK HEDSTR SVHDAT CLASS TAPNO TAPNAM OTPNAM PICKON MRTPNO STAPNO GOTALT DATDAT SPPN SNAME SEXT DTAPPN TRANGE TNAME ANAME AEXT DNAME DEXT DNAMEO MEMWC MEMWC1 MEMWC2 TPTR MTAPNO TNX DNX MMNAM MMEXT MMDAT MJBFF TNWRM1 TNWRM2 ALLSIZ TTNAM TTEXT LQUIET RELMCT PPURGE TAPWFL PTCNTL PTCNTP TODAYD PRDATE LASTTD VEFILE VEEXT VEFDIF LASTDT DEVNAM CLNAM TOBUF TIBUF REDOPN WRTOPN MBUFLG FIBUF FOBUF INDRBF LSTBUF UFDBUF PDATE PDATEH PCOUNT PTAPEN PDDATE PINVAL MONTAB RRD RRD1 REAPLS REAPOP LOGBUF LOGPTR LOGBP REAPNM LOGCMD NOREAP UPDRET ILLFMA ILLFMB INPMOD DENMOD RWMODE DENDAM IDXBEG IDXEND IDDDAT IDDAOB IDADAT IDAAOB LMTFDA MTFDAT MTFFIL MTFEXT MTFPPN MTFBEG MTAFMM MCLNAM MCLCOL MCLCNT MCLBP MCLOPN MCLREC MCLWID LMCLBF MCLBUF BRENDP STATLN STATBF STATFR STATBP STATSU STATLG UUOBLK DBLLEN DBLBUF DBLPTR DBLCNT NCPFIL CPFIL CPEXT CPPPN PCPFIL

FONYFI:	0			;filename in FILINF is a fake, wasn't on tape
TTYWRD:	0			;word for GETWRD
PRMOK:	0			;nonzero for auto proceed in pumpk on prv-med errors

HEDSTR:	0			;flag within RDFIL indicating bad header/trailer blk
SVHDAT:	0			;date seen in tape header

CLASS:	0			;CLASS OF DUMP. 0 = USER
TAPNO:	0			;TAPE NUMBER OF THIS TAPE.
TAPNAM:	0			;TAPE TITLE IN SIXBIT (e.g., P00001  or T00001)
OTPNAM:	0			;output TAPE TITLE IN SIXBIT during tape copy
PICKON:	0			;SET TO -1 WHEN DOING A PICKUP.
MRTPNO:	0			;IN MRESTORE, OPR TELLS PGM WHICH TAPE TO USE
STAPNO:	0			;IN MRESTORE, SAVE CURRENT TAPNO IN FUNNY FORMAT
GOTALT:	0			;IN MRESTORE, OPR TELLS PGM NOT TO REWIND TAPE

DATDAT:	0			;EXT,,DATE OF ALLDIR.DAT, SET BY DMPSTR FOR MERGE
SPPN:	0			;IN SPLIT, PPN FROM ALLDIR.MEM
SNAME:	0			;IN SPLIT, FILE NAME FROM ALLDIR.MEM
SEXT:	0			;IN SPLIT, EXT FROM ALLDIR.MEM
DTAPPN:	0			;IN SPLIT, NONZERO WHEN SPPN=NEW PPN FOR DTAPES.DAT
TRANGE:	0			;IN MERGE, DISP. INTO TTBUF OF CURRENT TAPE RANGE
TNAME:	0			;IN MERGE. UFD NAME FROM TAPE FILE.
ANAME:	0			;IN LOCATE UFD NAME FROM ARC
AEXT:	0
DNAME:	0			;IN MERGE, UFD NAME FROM DART.DAT
DEXT:	0			;IN LOCATE EXT FROM DAT
DNAMEO:	0			;IN ARCHIVE, UFD NAME FROM/TO DAT FILE.
MEMWC:	0			;IN MERGE, -WC REMAINING IN  TAPE FILE.
MEMWC1:	0			;IN MERGE, BYTE POINTER TO IN CORE BUFFER.
MEMWC2:	0			;IN MERGE, -WC REMAINING IN TAPE FILE BUFFER.
TPTR:	0			;IN MERGE, -WC,,MA OF TAPE FILE DATA IN CORE.
MTAPNO:	0			;IN MERGE, TAPE NUMBER + IF TEMPORARY THEN 400000
TNX:	0			;IN MERGE, SPECIAL VERSION OF TNAME
DNX:	0			;IN MERGE, SPECIAL VERSION OF DNAME
MMNAM:	0			;IN MERGE, NAME OF FILE FROM DART.DAT
MMEXT:	0			;IN MERGE, EXT OF FILE FROM DART.DAT
MMDAT:	0			;
MJBFF:	0			;IN MERGE, LOC OF DATA FROM DART.DAT
TNWRM1:	0			; TNWRIT POINTER
TNWRM2:	0			; TNWRIT COUNTER
ALLSIZ:	0			; SIZE (IN WORDS) OF CURRENT ALLDIR.MEM
TTNAM:	0
TTEXT:	0			;IN ARCHIVE..
LQUIET:	0			;FLAGS WHETHER OR NOT TO PRINT IN LOCATE
RELMCT:	0			;COUNT ACCESS FAILURES IN ALLMEM.
PPURGE:	0			;IF SET TO -1, THIS IS A PHONY PURGE
TAPWFL:	0			;Flag for TAPHED/TAPTAI to check for write lock
PTCNTL__=4000			;max P tape number for PTCNT (counts files on tapes)
PTCNTP:	0			;indirect ptr to table of size PTCNTL -- (A) in LH.
TODAYD:	0			;today's system format date, in VERDAT/VERARC/MCOPY
PRDATE:	0			;previously validated date on mcopy input tape
LASTTD:	0			;last time and date returned by TIMDAT, for DOMOUH
VEFILE:	0			;last file name seen in VERDAT
VEEXT:	0			;last filename ext seen in VERDAT
VEFDIF:	0			;nonzero in VERDAT if consecutive filenames differ
LASTDT:	0			;last date seen in dump info in VERFL1

DEVNAM:	0			;DISK STRUCTURE NAME FOR INPUT OR OUTPUT
IFN STANSW,<
SDEF(STRUCT,DEVNAM)		;ONLY ONE STRUCTURE
>;IFN STANSW

	[ASCIZ/ UNKNOWN /]
CLNAM:	[ASCIZ/ USER /]
	[ASCIZ/ TEMPORARY /]
	[ASCIZ/ SYSTEM PERMANENT /]
SDEF	CLMAX,.-CLNAM


TOBUF:	400000,,MBUF1+1		;HERE IS WHAT WE INITIALIZE THE BUFFERS TO.
	POINT	36,0,35		;THIS IS THE BYTE SIZE
	0			;THIS IS WHERE THE WORD COUNT GOES

TIBUF:	400000,,MBUF1+1		;HERE IS WHAT WE INITIALIZE THE BUFFERS TO.
	POINT	36,0,35		;THIS IS THE BYTE SIZE
	0			;THIS IS WHERE THE WORD COUNT GOES

;Next two words must be in this order.
REDOPN:	0		;nonzero if MTA open for reading
WRTOPN:	0		;nonzero if MTA2 open for writing (must follow REDOPN)

MBUFLG:	0		;0/normal; -1/use MBUF1,2,3; +n/use extra core buffers.

FIBUF:	BLOCK	3
FOBUF:	BLOCK	3
INDRBF:	BLOCK	3
LSTBUF:	BLOCK	3
UFDBUF:	BLOCK	3

;BYTE POINTERS
PDATE:	POINT	12,FILINF+DDPRO ,35	;CREATION DATE FROM PROTECTION WORD
PDATEH:	POINT	 3,FILINF+DDEXT ,20	;HIGH BITS OF CREATION DATE
PCOUNT:	POINT	 3,FILINF+DDMPTM, 3	;DUMP COUNT FROM DUMP WORD
PTAPEN:	POINT	12,FILINF+DDMPTM,20	;TAPE NUMBER FROM DUMP WORD
PDDATE:	POINT	15,FILINF+DDMPTM,35	;DUMP DATE IN DUMP WORD
PINVAL:	POINT	 1,FILINF+DDMPTM, 4	;DATE DUMPED INVALID BIT (20000 LEFT)

MONTAB:	ASCII	/Jan-/
	ASCII	/Feb-/
	ASCII	/Mar-/
	ASCII	/Apr-/
	ASCII	/May-/
	ASCII	/Jun-/
	ASCII	/Jul-/
	ASCII	/Aug-/
	ASCII	/Sep-/
	ASCII	/Oct-/
	ASCII	/Nov-/
	ASCII	/Dec-/

IFN STANSW,<			;BLOCK FOR ABSOLUTE MODE DISK READ.
RRD:	'GODMOD'		;FOR ABSOLUTE DISK READ
	1			;CODE FOR READ
	IOWD	20,FILINF	;THIS IS WHERE TO PUT THE DATA
RRD1:	0			;THIS IS THE TRACK NUMBER.
>;IFN STANSW

REAPLS:	0		;Flag: non-zero if CH.OUT should output to reap log file
REAPOP:	0		;Flag: non-zero if reap log file is open already
LOGBUF:	BLOCK 201	;Dump mode I/O buffer for reap-log file, extra zero at end
LOGPTR:	0		;USET record number for reap-log file
LOGBP:	0		;Byte pointer into LOGBUF for reap-log output
REAPNM:	SIXBIT /REAPED/	;Filename of reap-log file
	SIXBIT /LOG/
	0
LOGCMD:	IOWD 200,LOGBUF	;Dump mode command list for output to reap-log file
	0		;End of cmd list
NOREAP:	0		;Flag: non-zero if reap-deletions are disabled for now
IFN STANSW,<
UPDRET:	'GODMOD'	;STANFORD update retrieval
	17		;OPCODE
>;IFN STANSW

repeat 0,<
ILLFMA:	0		;word from tape upon illfmt error, for debugging
ILLFMB:	0		;PC where illfmt error detected
>;repeat 0

INPMOD:	DEN800		;input density for tape copy
DENMOD:	DEN800		;density requested by user.  Note DEN800 = DE6250.
RWMODE:	0		;MTINIR/W stores mode here (read zero, write nonzero)
DENDAM:	0		;nonzero to believe user density even in system class dump

IFN STANSW,<
IDXBEG:	0		;first PPN in index block, for IDXPCK
IDXEND:	0		;first PPN in next index block, for IDXPCK
IDDDAT:	0		;date written of INDEX.DAT
IDDAOB:	0		;aobjn ptr to INDEX.DAT in core
IDADAT:	0		;date written of INDEX.ARC
IDAAOB:	0		;aobjn ptr to INDEX.ARC in core
>;IFN STANSW

;Data from beginning of input magtape file, for finding first disk file inside.
LMTFDA__2+4		;save 2 leader words + 4 words of file retrieval
MTFDAT:	BLOCK LMTFDA	;data from front of magtape file, for tape copy
MTFFIL__MTFDAT+2	;filename
MTFEXT__MTFDAT+3	;extension
MTFPPN__MTFDAT+5	;PPN
MTFBEG:	0		;-1 if input tape positioned at beg of MT file (see MTAINP)

MTAFMM:	0		;value of MEMSAV+MTAFIL written in last DART.MEM (tape copy)

MCLNAM:	0		;primary name of current log file, sixbit of course
MCLCOL:	0		;output column for master tape copy text logging
MCLCNT:	0		;number of bytes left in buffer for mcopy logging
MCLBP:	0		;output byte ptr for logging mcopy output text
MCLOPN:	0		;nonzero to indicate mcopy log file is open
MCLREC:	0		;next record to be output to log file
MCLWID__=80		;max width of lines output to mcopy log file
LMCLBF__200		;length of logging buffer -- has to be one record
MCLBUF:	BLOCK LMCLBF	;buffer for mcopy logging
BRENDP:	0		;byte ptr to end of brand name (into MEMSAV)

STATLN__=20*=80		;max amount of stats text we expect
STATBF:	BLOCK STATLN/5	;buffer for text of stats in tape copy
STATFR:	0		;count of remaining free bytes in stats buffer
STATBP:	0		;byte pointer into stats buffer
STATSU:	0		;byte pointer to start of summary line in stats
STATLG:	0		;nonzero if logging system stats for tape copy

;UUOSIM block of three 3-word sub-blocks
UUOBLK:	0			;UUO return PC
	0			;UUO itself
	UUOTRP			;UUO trap address
	000000		;Don't trap spacewar or I-level UUOs

;Circular debugging buffer, used by DBLOGA and friends.
DBLLEN__1000		;number of words in circular debugging buffer
DBLBUF:	BLOCK DBLLEN	;circular debugging buffer
DBLPTR:	0		;byte pointer into DBLBUF
DBLCNT:	0		;counter till DBLPTR reaches end of DBLBUF

NCPFIL__=15	;number of recent files to check for duplicated filename
CPFIL:	BLOCK NCPFIL		;main file names of recently copied files
CPEXT:	BLOCK NCPFIL		;file exts
CPPPN:	BLOCK NCPFIL		;file PPNs
PCPFIL:	0			;current pointer into above circular file list
                                                                                                                                                                                                                                                                                                                                                       subttl	magtape buffers for input and output  ;DCLASS CHKNUM MSTRNA MMTDEV TAPNUM FUSER FFILE FFEXT LUSER LFILE LEXT PTRSAV MERGFL TTCNT MTAPOS MT2POS MTQPOS MTFPOS MTEPOS MTOPOS CUSER CFILE CEXT MCITAP MCOTAP TAPDMP RELABS REEABE MT2FIL MT2FI2 MTAFIL MTAFI2 DTAMAX MTAEOF MT2EOF MTAIRG MT2IRG MTAWRD MT2WRD ITEPPN DTAOOO MTADFI MCODFI MTADFE MCODFE MTEDFI MTEDFE MTCLPE MTCPER MTCENT MTCMIS MTDCMS NMECNT NSYSCT CHKSUE MTIDAT MTLOSE MTWIN NBRAND TBRAND ; NMTBFS MBUF1 ALTBUF MBUF2 MBUF3 MBUF4 MBUF5 MBUF6 MT2BUF ALLPTR REELPT MTREDO TAPBLK MEMBLK ALLBUF REELBF MEMSAV NSYSCT LBRAND TXTECT TXTECT TCIEC2 MTFOOT LSISIZ REDDEN WRTDEN REDIRG WRTIRG REDEFL WRTEFL MTIRGL MTEOFL MTALTB MTDPYD MTLIRG MTLEOF MTLWRD MUDPYD NAMSPL NAMSPL NAMSPL PPNSPL SPLFOR SPLREQ SPLJOB SPLDEV SPLSIZ SPLTIM SPLNAM SPLPPN SPLBIT SPLIOW UUOTMP

NMTBFS__6 ;number of magtape buffers we'll use (must match MBUFn blocks).
	  ;only valid numbers are 1, 3 and 6 currently.
MBUF1:	0			;BUFFER 1 FIRST WORD UNUSED
	BRCSIZ+1,,MBUF2+1
ALTBUF:	BLOCK	BRCSIZ+1	;SPACE USED FOR INDIRECT BUFFERS
IFG NBUFSX*203-<.-ALTBUF>,<
	BLOCK NBUFSX*203-<.-ALTBUF> ;leave enough room for disk buffers
>;IFGE

MBUF2:	0
	BRCSIZ+1,,MBUF3+1
	BLOCK	BRCSIZ+1

MBUF3:	0
IFG NMTBFS-3,<
	BRCSIZ+1,,MBUF4+1
	BLOCK	BRCSIZ+1

MBUF4:	0
	BRCSIZ+1,,MBUF5+1
	BLOCK	BRCSIZ+1

MBUF5:	0
	BRCSIZ+1,,MBUF6+1
	BLOCK	BRCSIZ+1

MBUF6:	0
>;IFG NMTBFS-3
	BRCSIZ+1,,MBUF1+1
	BLOCK	BRCSIZ+1

;Ptr to area for 2nd set of magtape buffers used when copying from tape to tape.
MT2BUF:	0			;ptr to first word of buffer area

ALLPTR:	0			;POINTER INTO ALLBUF
REELPT:	0			;POINTER IN REELBF

MTREDO__=7			;estimated size of system's record win table

TAPBLK:	BLOCK	2		;BUFFER FOR I/O TO DART.TAP (P tape nbr, T tape nbr)
MEMBLK:	BLOCK	200		;BUFFER FOR DUMP MODE IO
ALLBUF:	BLOCK	400		;BUFFER FOR ALLDIR.DAT
				;CAUTION: ALLBUF HAS TO BE CLEARED BEFORE CALLING REELMM
				;FORMAT IS: WORD 0/ PPN
					    ;WORD 1,3,.. /FILE NAME
					    ;WORD 2,4,.. /EXT,,TAPE NUMBER
;REELBF is written out in DART.MEM followed by the MEMSAV data.
;MEMSAV must follow REELBF.
REELBF:	BLOCK	200		;REEL FILE LIST BUFFER.
				;FORMAT IS: WORD 0/ PPN
					    ;WORD 1,3,../FILE NAME
					    ;WORD 2,4,../EXT,,DATE LAST WRITTEN
DEFINE MDEF(XX)<
SDEF(XX,.-MEMSAV)
0>
MEMSAV:				;DATA TO BE SAVED FOR PICKUPS.
MDEF	(DCLASS)	;0	;FLAGS,,CLASS
MDEF	(CHKNUM)	;1	;CHECKPOINT NUMBER.
MDEF	(MSTRNA)	;2	;NAME OF CURRENT STRUCTURE.
MDEF	(MMTDEV)	;3	;DEVICE NAME OF MAGTAPE.
MDEF	(TAPNUM)	;4	;TAPE NUMBER
MDEF	(FUSER)		;5	;USER IN PROGRESS.
MDEF	(FFILE)		;6	;FILE NAME FIRST DUMPED ON MTFILE
MDEF	(FFEXT)		;7	;AS ABOVE, EXTENSION
MDEF	(FUPRVH)	;10	;nonzero means file is altered header (PRVMTM added)
MDEF	(LUSER)		;11	;LAST USER NAME IN ALLDIR.
MDEF	(LFILE)		;12	;LAST FILE SAVED IN ALLDIR
MDEF	(LEXT)		;13	;AS ABOVE, EXTENSION.
MDEF	(PTRSAV)	;14	;SAVE REELPTR HERE.
MDEF	(MERGFL)	;15	;SET TO -1 AFTER A MERGE.
MDEF	(TTCNT)		;16	;COUNTS NUMBER OF TERMS IN TTBUF
;Next two must be in this order: MTAPOS, MT2POS (see MWRDUP and MEOFUP).
MDEF	(MTAPOS)	;17	;input tape position in tape copy
MDEF	(MT2POS)	;20	;output tape position

MDEF	(MTQPOS)	;21	;set to -1 if input tape position is questionable
MDEF	(MTFPOS)	;22	;output tape position at start of output MT file
MDEF	(MTEPOS)	;23	;input tape position after last input EOF
MDEF	(MTOPOS)	;24	;input tape position of file beginning output MT file
MDEF	(CUSER)		;25	;master tape copy: input file user starting MT file
MDEF	(CFILE)		;26	;master tape copy: input file starting MT file
MDEF	(CEXT)		;27	;master tape copy: input file ext starting MT file
MDEF	(CUPRVH)	;30	;nonzero means file is altered header (PRVMTM added)
MDEF	(MCITAP)	;31	;master tape copy: input tape number
MDEF	(MCOTAP)	;32	;master tape copy: output tape number
MDEF	(TAPDMP)	;33	;UNUSED
MDEF	(RELABS)	;34	;relative dump nbr within tape,,global dump set nbr
MDEF	(REEABE)	;35	;saved RELABS at latest potential pickup point
MDEF	(MT2FIL)	;36	;number of MT files seen on output tape
MDEF	(MTAFIL)	;37	;number of complete MT files seen on input tape
MDEF	(MTAFI2)	;40	;nbr of input MT files before input reposition point
MDEF	(DTAMAX)	;41	;maximum length DTAPES.DAT got, for backing up with zeroes
;Next two must be in this order: MTAPOS, MT2POS (see MWRDUP and MEOFUP).
MDEF	(MTAWRD)	;42	;number of words read on this tape
MDEF	(MT2WRD)	;43	;number of words written on this tape
;Next two must be in this order: MTAPOS, MT2POS (see MWRDUP and MEOFUP).
MDEF	(MTAEOF)	;44	;number of EOFs read on this tape
MDEF	(MT2EOF)	;45	;number of EOFs written on this tape
;Next two must be in this order: MTAPOS, MT2POS (see MWRDUP and MEOFUP).
MDEF	(MTAIRG)	;46	;number of data records read on this tape
MDEF	(MT2IRG)	;47	;number of data records written on this tape
MDEF	(ITEPPN)	;50	;last PPN on an input tape, for dump-end test
MDEF	(DTAOOO)	;51	;nonzero if PPNs in DTAPES.DAT are out of order
MDEF	(MTADFI)	;52	;number of disk files read from this input tape
MDEF	(MTEDFI)	;53	;saved MTADFI at latest potential pickup point
MDEF	(MCODFI)	;54	;number of disk files read, from all input tapes
MDEF	(MTADFE)	;55	;nbr of disk files with errors on input tape
MDEF	(MTEDFE)	;56	;saved MTADFE at latest potential pickup point
MDEF	(MCODFE)	;57	;nbr of disk files with errors, all input tapes
;following must be together, through BLOCK MTREDO-1 (see MCLEOT).
MDEF	(MTCLPE)	;60	;error count for unit: longitudinal parity error
MDEF	(MTCPER)	;61	;error count for unit: lateral parity error
MDEF	(MTCENT)	;62	;error count for unit: ill op
MDEF	(MTCMIS)	;63	;error count for unit: tape drive missed data
MDEF	(MTDCMS)	;64	;error count for unit: DC missed data
MDEF	(MTLOSE)	;65	;saved copy of systems losing record count
MDEF	(MTWIN)		;66	;beginning of copy of system table of saved win cnts
	BLOCK MTREDO-1	;67:74	;copy of rest of system win table
    NSYSCT__.-MEMSAV-MTCLPE	;size of data group copied at MCLEOT
;end of together group
MDEF	(CHKSUE)	;75	;number of checksum errors reading current tape
MDEF	(MTIDAT)	;76	;input tape's date written, from tape header
MDEF	(NBRAND)	;77	;number of chars in brand name string below
MDEF	(TBRAND)	;100	;brand and model of MCOPY input tape, end w/null
    LBRAND__5		;max nbr of words for storing brand name
	BLOCK LBRAND-1 ;101:104 ;rest of ASCIZ brand name string
;add new MEMSAV cells here
SDEF(TTBUF,.-MEMSAV)
SDEF(LTTBUF,20)
	BLOCK LTTBUF		;SPACE FOR TAPE TERM BUFFER
	BLOCK 3			;EMPTY SPACE TO ACCOUNT FOR DISK LOSS
SDEF(MEMLEN,.-MEMSAV)		;LENGTH OF MEMSAV

repeat 0,< ; for old HP 545 tape drives, RIP
;Types of errors recorded for HP 545 tape drive DC 136 controller.
TXTECT:	[ASCIZ/Longitudinal parity errors . /]
	[ASCIZ/Lateral parity errors  . . . /]
	[ASCIZ/Illegal drive operations . . /]
	[ASCIZ/Tape drive data missed . . . /]
	[ASCIZ/DC 136 data missed . . . . . /]
>;repeat 0 ; for old HP 545 tape drives, RIP
;Types of errors recorded for TU-20 tape drive on TM10A controller.
TXTECT:	[ASCIZ/Transport hung . . . . . . . /]
	[ASCIZ/Parity errors  . . . . . . . /]
	[ASCIZ/Illegal drive operations . . /]
	[ASCIZ/Tape drive data missed . . . /]
	[ASCIZ/Bad tape (data in EOR gap) . /]
SDEF(NMECNT,.-TXTECT) ;number of error counts (should match MTCLPE in MEMSAV)

TCIEC2:	BLOCK NSYSCT	;Copy of counts from MEMSAV+MTCLPE onward

;MTA POSITION DISPLAY DATA:
	RADIX	5+5

SDEF(MXINCH,556*800)		;NUMBER OF arbitrary UNITS IN ONE INCH
SDEF(MXFOOT,12*MXINCH)		;NUMBER OF these arbitrary UNITS IN ONE FOOT
MTFOOT:	MXFOOT
;LASTDN:	0			;magtape mode, for checking density
LSISIZ:	0			;tape length of last record read, for DPYSER

;Next two words must be in this order.
REDDEN:	0			;tape length of one word on input tape
WRTDEN:	0			;tape length of one word on output tape

;Next two words must be in this order.
REDIRG:	0			;interrecord gap on input tape
WRTIRG:	0			;interrecord gap on output tape

;Next two words must be in this order.
REDEFL:	0			;length of EOF on input tape
WRTEFL:	0			;length of EOF on output tape

repeat 0,<
;The next 3 labels (6 words) must be in this order, to match parallel tables below.
;These represent whatever kind of tape drive we're currently using.
;This table is set from one of those below.
MTIRGL:	3*MXINCH/4		;INTERRECORD GAP = 3/4 INCH
MTEOFL:	3*MXINCH		;EOF MARK = 3 INCHES
MTALTB:	6*MXINCH/556*21/20	;556 BPI : ONE WORD = 6 FRAMES * FUDGE
	6*MXINCH/200*21/20	;200 BPI : ONE WORD = 6 FRAMES * FUDGE
	6*MXINCH/556*21/20	;556 BPI : ONE WORD = 6 FRAMES * FUDGE
	6*MXINCH/800*21/20	;800 BPI : ONE WORD = 6 FRAMES * FUDGE
SDEF(LDPYD,.-MTIRGL)	;length of table above
>;repeat 0

;Footage table for 7-track tapes:
MTDPYD:
MTLIRG::3*MXINCH/4		;INTERRECORD GAP = 3/4 INCH
MTLEOF::3*MXINCH		;EOF MARK = 3 INCHES
MTLWRD::6*MXINCH/556*21/20	;556 BPI : ONE WORD = 6 FRAMES * FUDGE
	6*MXINCH/200*21/20	;200 BPI : ONE WORD = 6 FRAMES * FUDGE
	6*MXINCH/556*21/20	;556 BPI : ONE WORD = 6 FRAMES * FUDGE
	6*MXINCH/800*21/20	;800 BPI : ONE WORD = 6 FRAMES * FUDGE

;Footage table for TU78 tapes, must parallel 7-track table above.
MUDPYD:	3*MXINCH/10		;inter-record gap = .3 inches (.3 nominal)
	<4*MXINCH/10>+<325*MXINCH/9042> ;EOF mark = .4 inches + 325/9042 inch
	5*MXINCH/1600 ;*23/20	;1600 BPI : ONE WORD = 5 FRAMES (flush fudge)
	5*MXINCH/1600 ;*23/20	;1600 BPI : ONE WORD = 5 FRAMES (flush fudge)
	5*MXINCH/1600 ;*23/20	;1600 BPI : ONE WORD = 5 FRAMES (flush fudge)
	5*MXINCH/6250 ;*11/9	;6250 BPI : ONE WORD = 5 FRAMES (flush fudge)

	RADIX	4+4


IFN FTSUAI,<
SDEF(SPLEXT,'DSP')		;extension for spooler command file (Dover)
NAMSPL:	'DOVER!'		;SPOOLER'S JOB NAME AND WAKEME BLOCK.
>;IFN FTSUAI
IFN FTLLL,<
SDEF(SPLEXT,'XSP')		;extension for spooler command file (XGP)
NAMSPL:	'[XSPL]'		;SPOOLER'S JOB NAME AND WAKEME BLOCK.
>;IFN FTLLL
IFN FTCCRMA,<
SDEF(SPLEXT,'SPX')		;extension for spooler command file (LPT)
NAMSPL:	'[LIST]'		;SPOOLER'S JOB NAME AND WAKEME BLOCK.
>;IFN FTCCRMA
PPNSPL:	'SPLSYS'
	0			;FOR WAKEME
SPLFOR:	'NP2',,1		;BLOCK FOR SPOOL COMMANDS. SPOOLER ID,,version
SPLREQ:	0			;STUFF OUR PPN HERE.
SPLJOB:	0			;STUFF LINE,,JOB NUMBER HERE.
SPLDEV:	0			;DEVICE NAME TO LOCATE FILE.
	0			;READ IN MODE 0
SPLSIZ:	0			;FILE SIZE IN RECORDS.
SPLTIM:	0			;SET DATE,,TIME
SPLNAM:	0			;SET FILE NAME
	'LST',,0		;FILE EXTENSION
	0
SPLPPN:	0			;FILE PPN.
	BLOCK 3			;3 ZEROES FOR ALIAS.
SPLBIT:	100			;NARROW TITLE. (headings bit is off)
	BLOCK 100-<.-SPLFOR>	;fill out reserved area, up to page spec
	BLOCK 3			;NO PAGE SPECS.
SDEF(SPLLNG,.-SPLFOR)
SPLIOW:	IOWD	SPLLNG,SPLFOR	;IOWD FOR THE SPOOLER COMMAND FILE.
	0

UUOTMP:	0			;CELL FOR UUO DISPATCH

                                                                                                                 subttl	more data ; DDCMD DDBUF IIIBUF DMBUF BUFBUF DDDAT DDDEND DPYEND DPYHDR LINSAV DPYSXS TPGNUM TPGPDP TPGFLG TPBUF MAXLEN MAXLEN ARCCMD DATWC IDXPDP IDXPDL ARCWC ADXPDP ADXPDL LSTRPP LSTIPP ALTRPP ALTIPP DATIDX ARCIDX MRBASE MRSTDV MRSTNM MRSTET MRSTPN ALTLST NODDSP SWITOK PUMPCM DAY MONTH YEAR PBASE PIOWD LOCLUK TAPES RTAPES TRMCNT LASTW OWNER PRIVS UPPN UPRG ALIAS PRUIOW PRUFNM DDTADR DDTSVA DDTSVB PRSAVP PREQTP UNP2QF PUMWIZ PREALW PRLSTW PMULTF PFDRIP RETRYC TLISTC SAWEOF TELEOF GOTDOT TELDAT RMDWAK RMDSYS PRVMTA PRVBUF PASWD PRIVWD GRPWD REGRST CMPRST POSRST PUMRST PLBUF UNPUTR UNPBUF PATCH PATCH1 PATCH2 PATCH3

;Line characteristic bits
SDEF DISLIN,400000
SDEF DMLIN,40000
SDEF DDDLIN,20000

;TYPE 0=VISIBLE, 1=ENDPOINT, 2=INVISIBLE,
;MODE 1=ABSOLUTE, 0=RELATIVE.
	DEFINE	LVW(X,Y,BRIGHT,SIZE,MODE,TYPE)
<	BYTE(11)X,Y(3)BRIGHT,SIZE(1)0,MODE(2)TYPE(4)6	>
	DEFINE	CW(C1,D1,C2,D2,C3,D3)
<	BYTE(8)D1,D2,D3(3)C1,C2,C3,4>

;THE WORD AT BUFBUF IS IGNORED FOR A III PROGRAM

DDCMD:	CW(1,46,2,0,2,0)	;FUNCTION CODE - TEXT MODE, SELECT OWN CHANNEL
;DDBUF:	CW(3,47,4,1,5,10)	;COLUMN 39., LINE 24.
DDBUF:	CW(3,33,4,1,5,10)	;COLUMN 27., LINE 24. (cols numbered 2-85.)
IIIBUF:	LVW(0,700,0,0,1,2)	;ABSOLUTE INVISIBLE
;DMBUF:	BYTE(7)177,14,106,142	;Column 39., line 3.
DMBUF:	BYTE(7)177,14,165,142	;Column 21., line 3. (cols numbered 0-79.)

;;Old Display format: P00001 ?+1234 ft. FOOBAR.BAZ[GAR,PLY]
;;Dpy format: P03000/32 1234 ft  P00001 ?+1234 ft FOOBAR.BAZ[GAR,PLY]/12 (58 cols)
BUFBUF:	0			;Position select word(s) go here, device dependent.
	0
DDDAT:	REPEAT =12,<1
>
DDDEND:	1			;ROOM FOR 65 CHARACTERS
	<BYTE(7)15,12>+1
DPYEND:	0

DPYHDR:	642000,,BUFBUF		;Overlapped, DD double-field, DM truncate, DM USERGO
	DPYEND-BUFBUF+1		;TOTAL LENGTH OF DPY PROGRAM
	0			;FLAG TO SEE IF STILL IN PROGRESS
	BUFBUF+1		;ADRESS OF LOW ORDER LINE SELECT FOR DD

LINSAV:	0			;LINE CHARACTERISTICS WORD.
DPYSXS:	0			;CHARACTER COUNT FOR DPYSIX

TPGNUM:	0			;PAGE NUMBER IN LISTING FILE
SDEF(TPBUFL,64*3*2)		;LINE/PAGE * WORDS/ENTRY * ENTRY/LINE = WORDS/PAGE
TPGPDP:	0			;AOBJN (PDL) POINTER TO PAGE BUFFER
TPGFLG:	0			;0=NORMAL, -1 = MRESTORE
TPBUF:	BLOCK	TPBUFL

IFE STANSW,<
MAXLEN:	2000*200		;DEFAULT MAXIMUM LENGTH FOR SYSTEM DUMPS (IRCAM)
>;IFE STANSW
IFN STANSW,<
MAXLEN:	200000*200		;DEFAULT MAXIMUM LENGTH FOR SYSTEM DUMPS (STANFORD)
				;formerly 42410 (17672 DECIMAL) RECORDS = 2209 KWORDS
				;ABOUT 2/3 OF AN 800 BPI 7-TRK 2400 FOOT TAPE
				;Now about 8000K (1/4 of a 6250bpi 3600-ft tape)
>;IFN STANSW

ARCCMD:	0		;nonzero if doing ARCHIVE command

;PARAMETERS FOR WRITING THE INDEX INTO DART.DAT (MERGE/ARCHIVE OUTPUT FILE)
DATWC:	0
IDXPDP:	0
IDXPDL:	BLOCK	200

;PARAMETERS FOR WRITING THE INDEX INTO DART.ARC (ARCHIVE OUTPUT FILE)
ARCWC:	0
ADXPDP:	0
ADXPDL:	BLOCK	200

;PARAMETERS FOR SKIPPING THE INDEX PORTION ON INPUT OF DART.DAT
LSTRPP:	0			;LAST PPN READ FROM FILE
LSTIPP:	0			;LAST PPN READ FOUND IN INDEX.

;PARAMETERS FOR SKIPPING THE INDEX PORTION ON INPUT OF DART.ARC
ALTRPP:	0			;LAST PPN READ FROM FILE
ALTIPP:	0			;LAST PPN READ FOUND IN INDEX.

;IN LOCATE, AOBJN POINTERS TO INDEX DATA THAT'S IN CORE
DATIDX:	0
ARCIDX:	0

;MRESTORE COMMAND
MRBASE:	0
MRSTDV:	0
MRSTNM:	0
MRSTET:	0
MRSTPN:	0
ALTLST:	0			;-1 for alternate listing format

;NODUMP, REAP COMMANDS (SET/CLEAR BIT PER FILE)
NODDSP:	0			;ADDR OF COMMAND-SPECIFIC ROUTINE

SWITOK:	0		;non zero if switches OK, negative if rel dump switch OK

;PUMPKIN COMMAND
PUMPCM:	0		;NON ZERO TO FLAG WE'RE INSIDE PUMPKIN CMD
;SWITCH:	0
DAY:	0
MONTH:	0
YEAR:	0
PBASE:	0
SDEF(PFILES,200)	;MAX NUMBER OF FILES WE CAN RESTORE
SDEF(PDEV,0)		;FORMAT OF P BLOCK
SDEF(PNAME,1)
SDEF(PEXT,2)
SDEF(PPPN,3)
SDEF(PTPDT,4)		;TAPE,,DATE
SDEF(PSIZE,5)		;WORDS PER FILE BLOCK
PIOWD:	0		;WILL GET IOWD FOR OUTPUT
	0
LOCLUK:	BLOCK 4
TAPES:	0		;POINTER TO HEAD OF PRESTORE TAPES LIST
RTAPES:	0		;POINTER TO ORIGINAL LIST HEAD
TRMCNT:	0		;HOW MANY TERMS TO RESTORE IN THIS TAPE
LASTW:	0		;BACK POINTER FOR TERM LIST
OWNER:	0		;-1 IF HAVE OWNER ACCESS TO FILE
PRIVS:	0		;OUR PRIVILEGES
UPPN:	0		;OUR PPN
UPRG:	0		;OUR PRG
ALIAS:	0		;OUR DSKPPN
PRUIOW:	0		;IOWD FOR MAILING TO LUSER
	0		;END OF IO CMD LIST
PRUFNM:	0		;UNIQUE FN FOR MAIL GOES HERE
DDTADR:	0		;DDT START ADDR
DDTSVA:	0		;AC SAVE WORDS FOR DDT ENTRY
DDTSVB:	0
PRSAVP:	0		;SAVED PDL FOR EMERGENCY UNWIND DURING PRESTORE
PREQTP:	0		;REQUIRED TAPE NUMBER, FOR HEADER CHECK
UNP2QF:	0		;-1 WHILE READING EUQ FOR UNPUMPKIN
PUMWIZ:	0		;-1 ON BAD FORMAT TAPE DURING PRESTORE
PREALW:	0		;SAVED W (TERM BLOCK) MATCHING FILE IN PRESTORE
PRLSTW:	0		;SAVED LASTW DITTO
PMULTF:	0		;-1 IF THIS FILE MATCHES 2 TERM BLOCKS
PFDRIP:	0		;-1 if file-data-read in progress (ENTER done)
RETRYC:	0		;positive to retry automatically after ILL FMT in PRESTORE
TLISTC:	0		;count of magtape files to list in TLIST
SAWEOF:	0		;-1 if eof seen on tape, for TLIST/ADV TO/[P]RESTORE stopping
;printx TELEOF currently defaults on for debugging.
TELEOF:	-1		;-1 if want to typeout indications of EOFs to user
GOTDOT:	0		;-1 if saw "." in filename in SCAN (explicit extension)
TELDAT:	0		;-1 makes TLIST report date written of each file seen

RMDWAK:	'<RMND>'
RMDSYS:	'RMDSYS'
	0

PRVMTA:	SIXBIT /GODMOD/
	14
	IOWD 17,PRVBUF
PRVBUF:	BLOCK 13
PASWD:	0			;PASSWORD RETURNED HERE IF INF
PRIVWD:	0			;PRIVILEGES RETURNED HERE
	0			;LAST LOGIN TIME RETURNED HERE
GRPWD:	0			;GROUP ACCESS BITS RETURNED HERE

SDEF(R.NAM,0)		;offsets of entries in tables below
SDEF(R.EXT,1)
SDEF(R.PPN,2)
SDEF(R.NXT,3)
SDEF(R.END,4)
SDEF(R.BLT,5)
SDEF(R.NULP,6)
SDEF(R.EMPT,7)
SDEF(R.SAFE,10)
SDEF(R.REGP,11)
SDEF(R.POST,12)
SDEF(R.FIND,13)
SDEF(R.DIFF,14)
SDEF(R.COMP,15)

;table for normal RESTORE command
REGRST:	RSTNAM		;0 OUTPUT NAME LOCATION
	RSTEXT		;1 OUTPUT EXT LOCATION
	RSTPPN		;2 OUTPUT PPN LOCATION
	ADDI W,FSLEN	;3 POINT W TO NEXT BLOCK
	CAMGE W,FSPTR	;4 END TEST FOR INPUT TERMS
	JFCL		;5 NO-OP FOR NORMAL BLT TO ELIMINATE TERM
	CAIA		;6 ANY TERM BLOCK OK FOR NORMAL RESTORE
	CAMGE W,FSPTR	;7 TEST FOR EMPTY TERM LIST SAME AS END TEST
	PUSHJ P,LCHECK	;10 WHAT TO DO IF FILE ALREADY EXISTS
	CAIA		;11 SKIP unless PRestore (Pumpkin)
	JFCL		;12 WHAT TO DO AFTER RESTORING FILE SUCCESSFULLY
	CAIA		;13 SKIP UNLESS POSITIONING TAPE
	JRST RSTG6	;14 what to do if no match of filename portion
	CAIA		;15 skip unless COMPARE command

;table for COMPARE command
CMPRST:	RSTNAM		;0 OUTPUT NAME LOCATION
	RSTEXT		;1 OUTPUT EXT LOCATION
	RSTPPN		;2 OUTPUT PPN LOCATION
	ADDI W,FSLEN	;3 POINT W TO NEXT BLOCK
	CAMGE W,FSPTR	;4 END TEST FOR INPUT TERMS
	JFCL		;5 NO-OP FOR NORMAL BLT TO ELIMINATE TERM
	CAIA		;6 ANY TERM BLOCK OK FOR NORMAL RESTORE
	CAMGE W,FSPTR	;7 TEST FOR EMPTY TERM LIST SAME AS END TEST
	HALT .		;10 WHAT TO DO IF FILE ALREADY EXISTS
	CAIA		;11 SKIP unless PRestore (Pumpkin)
	JFCL		;12 WHAT TO DO AFTER RESTORING FILE SUCCESSFULLY
	CAIA		;13 SKIP UNLESS POSITIONING TAPE
	JRST RSTG6	;14 what to do if no match of filename portion
	JFCL		;15 skip unless COMPARE command

;table for tape positioning command -- position tape to given file
POSRST:	RSTNAM		;0 OUTPUT NAME LOCATION
	RSTEXT		;1 OUTPUT EXT LOCATION
	RSTPPN		;2 OUTPUT PPN LOCATION
	ADDI W,FSLEN	;3 POINT W TO NEXT BLOCK
	CAMGE W,FSPTR	;4 END TEST FOR INPUT TERMS
	JFCL		;5 NO-OP FOR NORMAL BLT TO ELIMINATE TERM
	CAIA		;6 ANY TERM BLOCK OK FOR NORMAL RESTORE
	CAMGE W,FSPTR	;7 TEST FOR EMPTY TERM LIST SAME AS END TEST
	PUSHJ P,LCHECK	;10 WHAT TO DO IF FILE ALREADY EXISTS
	CAIA		;11 SKIP unless PRestore (Pumpkin)
	JFCL		;12 WHAT TO DO AFTER RESTORING FILE SUCCESSFULLY
	JFCL		;13 SKIP UNLESS POSITIONING TAPE
	JUMPN Y,RSTG6	;14 if no match of filename portion, lose unless not spec'd
	CAIA		;15 skip unless COMPARE command

;table for PRESTORE command -- restore PUMPKIN'd files
PUMRST:	FSPNAM(W)	;0 OUTPUT NAME LOCATION
	FSPEXT(W)	;1 OUTPUT EXT LOCATION
	FSPPPN(W)	;2 OUTPUT PPN LOCATION
	HRRZ W,(W)	;3 POINT W TO NEXT BLOCK
	SKIPE W		;4 END TEST FOR INPUT TERMS
	JRST PREKIL	;5 LEAVE MAIN RESTORE CODE TO LINK OUT TERM
	SKIPGE FSPREQ(W);6 SKIP IF THIS TERM BLOCK STILL UNRESTORED
	SKIPLE TRMCNT	;7 TEST FOR NO TERMS LEFT IN PRESTORE TAPE LIST
	PUSHJ P,PFILEX	;10 WHAT TO DO IF FILE ALREADY EXISTS
	JFCL		;11 SKIP unless PRestore (Pumpkin)
	PUSHJ P,PSTKIL	;12 WHAT TO DO AFTER RESTORING FILE SUCCESSFULLY
	CAIA		;13 SKIP UNLESS POSITIONING TAPE
	JRST RSTG6	;14 what to do if no match of filename portion
	CAIA		;15 skip unless COMPARE command

PLBUF:	BLOCK 20	;TEXT BUFFER FOR ONE LINE OF PLIST OUTPUT

SDEF(PUMNUM,200)	;HOW MANY REQUESTS CAN WE UNDELETE
UNPUTR:	BLOCK PUMNUM	;TABLE OF POINTERS TO USER'S REQUESTS FOR UNPUMPKIN
UNPBUF:	BLOCK 200	;BUFFER FOR ONE DISK RECORD OF .QUE FILE

PATCH:	BLOCK	20
PATCH1:	BLOCK	20
PATCH2:	BLOCK	20
PATCH3:	BLOCK	20
                     subttl	error messages		; ILLSW2 ILLSWT NOCORE NODEV NODEV0 NODEV1 NOLOOK NOLOO2 NOMTA ILLPPN ALLIND ALLDEV SYNTAX ILLFMT ILLFM2 ALLLST NOENT LSTERR INDERR UFDRER DSKRER NOPRV PURERR NOTDSK MTSAME OPNERR ILLDST NOBACK NOOUT FILETB NFLERS

;Here if bad switch found in command line term for MCOPY.
ILLSW2:	CLRBFI
ILLSWT:	OUTSTR [ASCIZ/Invalid switch given.  Only P tape number for input tape is valid.
/]
	JRST RESTAR

NOCORE:	OUTSTR	[ASCIZ/Can't get enough core.
/]
	JRST	RESTAR

NODEV:	OUTSTR	[ASCIZ/OPEN failed on device /]
	PUSH	P,A
	PUSH	P,B
	PUSH	P,C
	JUMPE	B,NODEV1
	MOVE	A,B
	PUSHJ	P,SIXOUT
NODEV0:	OUTSTR	[ASCIZ/:  Called from: /]
	HRRZ	A,-3(P)
	PUSHJ	P,DISLOC
	OUTSTR	[ASCIZ/
/]
	JRST	RESTAR

NODEV1:	OUTSTR	[ASCIZ/
Device name is blank.  See if you can locate a wizard.
/]
	HALT	NODEV0

NOLOOK:	OUTSTR [ASCIZ/LOOKUP failed -- /]
NOLOO2:	MOVEI C,(B)
	CAILE C,NFLERS		;reasonable error code?
	MOVEI C,NFLERS		;no
	OUTSTR @FILETB(C)	;explain failure
	PUSHJ P,TYFIL		;type filename
	OUTSTR CRLF
	JRST RESTAR

NOMTA:	OUTSTR	[ASCIZ/Can't INIT magtape
/]
	JRST	RESTAR

ILLPPN:	OUTSTR	[ASCIZ/Illegal PPN
/]
	JRST	RESTAR

ALLIND:	OUTSTR	[ASCIZ/"*" specification in the name of an indirect file is illegal
/]
	JRST	RESTAR

ALLDEV:	OUTSTR	[ASCIZ/Device "*" illegal
/]
	JRST	RESTAR

SYNTAX:	OUTSTR	[ASCIZ/Improper syntax in command
/]
	JRST	RESTAR

repeat 0,<
ILLFMT:	MOVEM A,ILLFMA		;store bad word from tape, for debugging
	MOVEM B,ILLFMB		;store PC of place error detected too
	JRST @CREST1

ILLFM2:	OUTSTR	[ASCIZ/Illegal tape format.  This doesn't look like a DART tape.
Try a BACKSPACE command to position the tape, or an ADVANCE command
to skip the bad part.
/]
	JRST	RESTAR
>;repeat 0

ALLLST:	OUTSTR	[ASCIZ/"*" in the name of a listing file is illegal.
/]
	JRST	RESTAR

NOENT:	OUTSTR	[ASCIZ/ENTER failed -- /]
	JRST	NOLOO2

LSTERR:	OUTSTR	[ASCIZ/IO error on listing file.
/]
	JRST	RESTAR

INDERR:	OUTSTR	[ASCIZ/Output error on archive file.
/]
	JRST	RESTAR

UFDRER:	OUTSTR	[ASCIZ/UFD read error.
/]
	JRST	RESTAR

IFN STANSW,<
DSKRER:	OUTSTR	[ASCIZ/Disk read error.
/]
	JRST	RESTAR
>;IFN STANSW

NOPRV:	OUTSTR	[ASCIZ/You are not privileged to do
FDUMP, PDUMP, TDUMP, PURGE, PRESTORE, or MRESTORE commands.
/]
	JRST	RESTAR

PURERR:	OUTSTR	[ASCIZ/PURGE command requires an argument list
/]
	JRST	RESTAR

NOTDSK:	OUTSTR	[ASCIZ/Illegal source device /]
	MOVE	A,B
	PUSHJ	P,SIXOUT
IFE UDPSW,<
	OUTSTR	[ASCIZ/:  only DSK is legal.
/]
>;IFE UDPSW
IFN UDPSW,<
	OUTSTR	[ASCIZ/:  ONLY DSK AND UDP ARE LEGAL.
/]
>;IFN UDPSW
	JRST	RESTAR

;From TCOPY
MTSAME:	OUTSTR [ASCIZ/Input and output magtape drives must be different!
/]
	JRST RESTAR

OPNERR:	OUTSTR [ASCIZ/
Trying to re-use a magtape channel that's still in use.  Tell a wizard.
Then maybe type CONTINUE to go ahead anyway.
/]
	HALT CPOPJ

ILLDST:	OUTSTR [ASCIZ/No destination terms allowed.
/]
	JRST RESTAR

NOBACK:	OUTSTR [ASCIZ/Positioning tape at file not implemented for backwards direction.
/]
	JRST RESTAR

;From PTCNT.
NOOUT:	OUTSTR [ASCIZ/Disk write error.
/]
	JRST RESTAR

FILETB:	[ASCIZ /File not found: /]			;0
	[ASCIZ /User area doesn't exist: /]		;1
	[ASCIZ /Protection failure: /]			;2
	[ASCIZ /File in use: /]				;3
	[ASCIZ /File already exists: /]			;4 (RENAME error)
	[ASCIZ /Impossible LOOKUP-ENTER error (5): /]	;5
	[ASCIZ /Impossible LOOKUP-ENTER error (6): /]	;6
	[ASCIZ /Impossible LOOKUP-ENTER error (7): /]	;7 sys error if happens
	[ASCIZ /Bad retrieval: /]			;10
	[ASCIZ /Bad retrieval: /]			;11
	[ASCIZ /Disk is full: /]			;12
NFLERS__.-FILETB
	[ASCIZ /Out of range LOOKUP-ENTER error: /]
                                                                                                                      subttl display service		; DPYSER DPYSE2 NODPYO NOQUES NODPYF CVFOOT TYFOOT TYPFOO DPYFIL DPYFL1 DPYREL DPYPPN DPYPPR DPYSIX DPYSX1 DPYDEC DPYPPO DPYOCT DPYSER

;CALL WITH:
;	PUSHJ P,DPYSER
;	 DATA,,ROUTINE
;ROUTINE WILL BE CALLED WITH A PUSHJ P, WITH C CONTAINING DATA ADRESS AND D BYTE PTR

IFN STANSW!IRCPPN,<
DPYSER:	SKIPE LINSAV		;SKIP IF NO DPY.
	SKIPE DPYHDR+2		;DPY. SKIP IF DD/DM DONE.
	JRST CPOPJ1		;DO NOTHING IF NOT DPY OR DD/DM BUSY
	MOVEI A,1
	MOVEM A,DDDAT		;CLOBBER TEXT AREA TO NULLS
	MOVE A,[DDDAT,,DDDAT+1]
	BLT A,DDDEND
	MOVE D,[POINT 7,DDDAT]	;SET UP BYTE POINTER
	SKIPN MASCOP		;skip if two tapes in use
	TDZA B,B		;only one tape name to show
	MOVE B,OTPNAM		;output tape name during tape copy
	MOVEI A,6
	PUSHJ P,DPYSIX
	SKIPN MASCOP		;master copy?
	JRST DPYSE2		;no
	HLRZ A,MEMSAV+RELABS	;get rel dmp nbr
	PUSHJ P,DPYREL		;print it
DPYSE2:	MOVEI A," "
	IDPB A,D
	SKIPN MASCOP		;doing master tape copy?
	SKIPN RWMODE		;no, skip if writing tape
	SKIPA A,MEMSAV+MT2POS	;display output tape position
	TDZA A,A
	MOVEI B,12		;number of spaces in lieu of output tape footage
	JUMPE A,NODPYO		;no output tape footage if zero
	PUSHJ P,CVFOOT		;convert to feet and display
	MOVEI B,2
NODPYO:	MOVEI A," "
	IDPB A,D
	SOJG B,NODPYO		;maybe output more spaces
	MOVE B,TAPNAM
	MOVEI A,6
	PUSHJ P,DPYSIX
	MOVEI A," "
	IDPB A,D
	SKIPN MEMSAV+MTQPOS	;SKIP IF MTA POSITION IS QUESTIONABLE
	JRST NOQUES
	MOVEI A,"?"		;QUESTIONABLE, prepend question-mark
	IDPB A,D
	MOVEI A,"+"
	IDPB A,D
NOQUES:	SKIPN MASCOP		;doing master tape copy?
	SKIPN RWMODE		;no, skip if writing tape
	SKIPA A,MEMSAV+MTAPOS	;display input tape position
	SKIPA A,MEMSAV+MT2POS	;display output tape position
	SUB A,LSISIZ		;measure from beginning of last record read, not end
	PUSHJ P,CVFOOT		;convert to feet and display
	MOVEI A," "
	IDPB A,D
	HLRZ C,@(P)		;GET DATA ADDRESS
	HRRZ A,@(P)		;GET ROUTINE ADDRESS
	CAIE A,DPYFIL		;displaying filename?
	JRST NODPYF		;no
	HLLZ B,1(C)		;get extension
	CAME B,FAKEFI+1		;is this a new fake filename (current read error)?
	JRST NODPYF		;no, display it (maybe from tape copy output tape)
	MOVE B,3(C)		;yes, get PPN
	CAMN B,FAKEFI+3		;is this a fake filename? (impossible PPN?)
	JRST CPOPJ1		;yes, suppress displaying it
NODPYF:	PUSHJ P,(A)
	UPGIOT DPYHDR		;DISPLAY STUFF
	JRST CPOPJ1		;RETURN

CVFOOT:	ADD A,[6*MXINCH]	;ADD 6 INCHES FOR ROUNDING
	IDIV A,MTFOOT		;GET FEET (REMAINDER IN B)
	JUMPGE A,.+2
	MOVEI A,0		;don't let position be negative
	RADIX 5+5
	CAIL A,9999		;MORE THAN 9999 FEET???
	MOVEI A,9999
	RADIX 4+4
	PUSHJ P,DPYDEC		;PUT OUT POSITION IN DECIMAL
	MOVEI A," "
	IDPB A,D
	MOVEI A,"f"
	IDPB A,D
	MOVEI A,"t"
	IDPB A,D
	POPJ P,

;Type footage for internal position units given in A.
TYFOOT:	ADD A,[6*MXINCH]	;add 6 inches for rounding
	IDIV A,MTFOOT		;get feet (remainder in b)
	PUSHJ P,DECOUT		;type decimal tape position
	TRC FL,LSTON+LSTTTY
	TRCN FL,LSTON+LSTTTY
	CLOSE LST,		;force tty output
	OUTSTR [ASCIZ/ ft/]
	POPJ P,

;Type footage test counts for output tape (here at phys EOT).
TYPFOO:	OUTSTR [ASCIZ/Tape holds: /]
	MOVE A,MEMSAV+MT2WRD	;data word count
	PUSHJ P,DECOUT		;type decimal wd cnt
	OUTSTR [ASCIZ/. words;  /]
	MOVE A,MEMSAV+MT2IRG	;data record count
	PUSHJ P,DECOUT		;type decimal rec cnt
	OUTSTR [ASCIZ/. data records;  /]
	MOVE A,MEMSAV+MT2EOF	;EOF count
	PUSHJ P,DECOUT		;type decimal EOF cnt
	OUTSTR [ASCIZ/. EOFs.
/]
	POPJ P,

DPYFIL:	MOVE B,(C)		;GET FILE NAME
	MOVEI A,6		;NUMBER OF CHARACTERS
	PUSHJ P,DPYSIX
	HLLZ B,1(C)
	MOVEI A,4
	JUMPE B,DPYFL1
	MOVEI A,"."
	IDPB A,D
	MOVEI A,3
DPYFL1:	PUSHJ P,DPYSIX
	ADDI C,3
	PUSHJ P,DPYPPN		;display PPN
	MOVE A,INVERS		;check tape format
	CAIN C,FILINF+DDNAM+3	;make sure filename ptr is as expected
	CAIGE A,IOVER3		;modern format?
	POPJ P,			;no, no rel dmp nbr
	MOVE A,SRCDEV+CONDAR-1	;double check the format
	CAME A,['DART  ']
	POPJ P,			;bad format
	HLRZ A,SRCDEV+LL3DMP-1	;get relative dump nbr
	JUMPE A,CPOPJ		;jump if none
DPYREL:	MOVEI B,"/"
	IDPB B,D
	CAILE A,=99
	MOVEI A,=99
	PUSHJ P,DPYDEC		;display rel dump nbr in decimal
	POPJ P,

DPYPPN:	MOVEI A,"["
	IDPB A,D
IFN IRCPPN,<
	MOVE B,(C)
	TLNE B,777740
	TRNN B,777740
	JRST DPYPPO		;OCTAL PPN
>;IRCPPN
	HLLZ B,(C)
	MOVEI A,3
IFN IRCPPN,<
	TLNE B,770000
	TLO B,400000
>;IRCPPN
	PUSHJ P,DPYSIX
	MOVEI A,","
	IDPB A,D
	HRLZ B,(C)
	MOVEI A,3
IFN IRCPPN,<
	TLNE B,770000
	TLO B,400000
>;IRCPPN
	PUSHJ P,DPYSIX
DPYPPR:	MOVEI A,"]"
	IDPB A,D
	POPJ P,

DPYSIX:	MOVEM A,DPYSXS		;SAVE CHARACTER COUNT.
DPYSX1:	MOVEI A,0
	LSHC A,6
	ADDI A," "
	IDPB A,D
	SOSLE DPYSXS
	JRST DPYSX1
	POPJ P,

DPYDEC:	IDIVI A,12
	HRLM B,(P)
	JUMPE A,.+2
	PUSHJ P,DPYDEC
	HLRZ A,(P)
	ADDI A,"0"
	IDPB A,D
	POPJ P,

IFN IRCPPN,<
DPYPPO:	HLRZ A,(C)
	PUSHJ P,DPYOCT
	MOVEI A,","
	IDPB A,D
	HRRZ A,(C)
	PUSHJ P,DPYOCT
	JRST DPYPPR

DPYOCT:	IDIVI A,10
	HRLM B,(P)
	JUMPE A,.+2
	PUSHJ P,DPYOCT
	HLRZ A,(P)
	ADDI A,"0"
	IDPB A,D
	POPJ P,
>;IRCPPN

>;IFN STANSW!IRCPPN
IFE STANSW!IRCPPN,<
DPYSER:	JRST CPOPJ1
SDEF(DPYFIL,0)
SDEF(DPYPPN,0)
;;THANK YOU, MR. GORIN, FOR THESE UNDEFINED SYMBOLS
>;IFE STANSW!IRCPPN
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    subttl dump a data file to tape	; DUMP DUMP2 DUMP0 DUMP0 DUMP1 DUMP4 DUMP3 DXTAB DUMPX0 DUMPX1 DUMPX2 DUMPX3 DUMPXX DUME TAPHED TAPTAI TAPHD0 NXTOBF TIMDAT WRXINF WRXIN2 COLEAD

COMMENT $
;   FILINF: BLOCK   20      ;SET UP WITH 20 WORDS OF RETRIEVAL INFORMATION
;   WC:     BLOCK   1       ;SET WITH WORD COUNT AVAILABLE IN THIS RECORD
;   FSIZE:  0               ;WILL BE SET TO WORD COUNT OF FILE.

ROUTINE WILL SKIP RETURN UNLESS END OF TAPE IS FOUND.
$

DUMP:	SETOM FSTRT		;indicate ready for file-start record on output
	MOVM B,FILINF+DDLNG	;GET THE FILE WORD COUNT.
	MOVEM B,FSIZE		;SAVE FILE SIZE IN WORDS
	MOVE A,WC		;GET THE WORD COUNT LEFT IN RECORD
;	CAILE A,200+INFOSI+3	;ENOUGH LEFT TO MAKE IT WORTH IT?
	CAILE A,200+WCWD+LLEAD3+LMEDER+CKWD ;enough left to make it worth it?
	JRST DUMP0		;YES. CONTINUE ON THIS TAPE RECORD
;Loop here for each output block, start a new output buffer.
DUMP2:	SETZM TOBUF+2		;ZERO THE BUFFER COUNT
	MOVE A,WRCSZ		;THE WORD COUNT OF SPACE LEFT HERE.
	MOVEM A,WC		;SET UP WC
DUMP0:	SUBI A,WCWD+LLEAD3+LMEDER+CKWD ;file data space is room minus overhead words
	MOVE B,FSIZE		;remaining amount of output file to do
	CAILE B,(A)		;skip if it all fits in current output buffer
	MOVEI B,(A)		;too big, write only amount that fits in buffer
	MOVNM B,FWC		;save neg wd cnt of file words in this record
	AOSE FSTRT		;skip if doing file start block
	TDZA A,A		;doing file continuation, zero the LH of wd ct wd
	MOVSI A,-IOVER		;negative ioversion number
	HRRI A,LLEAD3+LMEDER(B)	;set up wd ct=leader+media error data+file data
repeat 0,<
DUMP0:	SUBI A,INFOSI+3		;WC-OVERHEAD = DATA SPACE COUNT.
	MOVE B,FSIZE		;GET FILE SIZE
	CAILE B,(A)		;IS THE FILE SMALL ENOUGH TO FIT?
	MOVEI B,(A)		;FILE IS TOO BIG. WRITE ONLY THIS MUCH
	MOVNM B,FWC		;SAVE -WC OF FILE IN THIS RECORD
	MOVSI A,-IOVER		;NEGATIVE IOVERSION NUMBER,
	HRRI A,INFOSI+1(B)	;GET -IOVER,,WC.  WC=DATA+RETRIEVAL+1
>;repeat 0
;* NEXT CALL MAY FAIL
	PUSHJ P,TWRITE		;WRITE WORD COUNT.
	 POPJ P,		;RETURN WITH ERROR
repeat 0,<
	MOVNI B,INFOSI+3(B)	;WE WRITE WC+DEVNAM+INFO+FILE+CHECKSUM
	ADDM B,WC		;THIS WILL BE WC WHEN WE'RE THROUGH
	MOVE A,STRUCT		;GET THE DEVICE NAME
	MOVE C,A		;INITIALIZE CHECKSUM
	MOVNI B,INFOSIZE+1	;THIS IS THE OVERHEAD COUNT
	ADDM B,TOBUF+2		;DECREMENT THE OUTPUT COUNT.
>;repeat 0
	MOVNI B,WCWD+LLEAD3+LMEDER+CKWD(B) ;will write wc+leader+media+checksum+FILE
	ADDM B,WC		;reduce output buffer space left after this block
	ADDM B,TOBUF+2		;decrement the output buffer count too
	MOVE A,STRUCT		;get the device name
	MOVE C,A		;initialize checksum
	IDPB A,TOBUF+1		;WRITE ON TAPE.
IFN IRCPPN,<
	MOVE B,FILINF+DDPPN	;TURN IRCAM PPN INTO SAIL PPN
	TLNE B,770000		;FOR TRANSPORTABILITY
	TLO B,400000
	TRNE B,770000
	TRO B,400000
	MOVEM B,FILINF+DDPPN
>;IFN IRCPPN
	MOVSI B,-INFOSI		;MAKE AOBJN POINTER FOR FILINF
DUMP1:	MOVE A,FILINF(B)	;GET A RETRIEVAL WORD
	XOR C,A			;COMPUTE THE CHECKSUM
	IDPB A,TOBUF+1
	AOBJN B,DUMP1		;LOOP
IFN IRCPPN,<
	MOVE B,[400000,,400000]	;PUT BACK IRCAM PPN
	ANDCAM B,FILINF+DDPPN	;IN CASE ANYONE CARES
>;IFN IRCPPN
	SKIPLE FSTRT		;skip if doing file-start block
	SKIPA B,['CON',,IOVER]	;indicate continuation block
	MOVE B,['*FILE*']	;indicate file-start block
	PUSHJ P,WRXINF		;insert extra leader info into output buffer

	MOVE B,FWC		;GET THE WORD COUNT OF DATA WORDS
	ADDM B,FSIZE		;DECREASE FILE SIZE
DUMP4:
;;	ADDM B,TOBUF+2		;DECREMENT THE BUFFER COUNT.
	MOVEI X,3		;
	AND X,B			;PICKUP 2 BITS FROM B
	ASH B,-2		;AND SHIFT B APPROPRIATELY
	MOVE D,TOBUF+1		;PICKUP BYTE POINTER
	TLZE D,770000		;ZERO THE BYTE POSITION
	SUBI D,1		;OOPS WAS A 444400,
	SUBI D,(X)
	JUMPE B,DUMPXX		;IF B IS ZERO, WRITE CHECKSUM ONLY (and media data)
	JRST @DXTAB(X)		;AND JUMP WILDLY INTO THE OPEN CODE

repeat 0,<
DUMP3:	MOVE B,FSIZE		;GET THE SIZE OF THE FILE REMAINDER
	CAMLE B,WRCSZ2		;WILL IT FIT IN A RECORD? (rec size - 2)
	MOVE B,WRCSZ2		;NO. THIS IS HOW MANY TO TAKE
	MOVNI A,(B)		;GET - THE SIZE
	ADDM A,FSIZE		;DECREASE FILE SIZE.
	MOVEM A,FWC		;SAVE AS THE COUNT FOR THIS RECORD.
	ADD A,WRCSZ2		;ADD THE RECORD SIZE minus 2
	MOVEM A,WC		;SAVE AS RECORD REMAINING WC.
	SETZ C,			;ZERO THE CHECKSUM
	MOVEI A,(B)		;GET +THE COUNT
;* THIS ONE CAN FAIL.
	PUSHJ P,TWRITE		;WRITE ON THE FILE.
	 POPJ P,		;RETURN AN ERROR
	MOVE B,FWC		;GET THE DATA COUNT
>;repeat 0

DXTAB:	DUMPX0
	DUMPX1
	DUMPX2
	DUMPX3

DUMPX0:	SOSG FIBUF+2		;IS THERE DATA IN BUFFER?
	PUSHJ P,DFREDX		;READ FROM DISK FILE
	ILDB A,FIBUF+1		;LOAD A WORD FROM THE FILE.
	XOR C,A			;SAVE CHECKSUM
	MOVEM A,1(D)		;SAVE WORD.
DUMPX1:	SOSG FIBUF+2		;IS THERE DATA IN BUFFER?
	PUSHJ P,DFREDX		;READ FROM DISK FILE
	ILDB A,FIBUF+1		;LOAD A BYTE FROM THE FILE.
	XOR C,A			;SAVE CHECKSUM
	MOVEM A,2(D)		;SAVE BYTE.
DUMPX2:	SOSG FIBUF+2		;IS THERE DATA IN BUFFER?
	PUSHJ P,DFREDX		;READ FROM DISK FILE
	ILDB A,FIBUF+1		;LOAD A BYTE FROM THE FILE.
	XOR C,A			;SAVE CHECKSUM
	MOVEM A,3(D)		;SAVE BYTE.
DUMPX3:	SOSG FIBUF+2		;IS THERE DATA IN BUFFER?
	PUSHJ P,DFREDX		;READ FROM DISK FILE
	ILDB A,FIBUF+1		;LOAD A BYTE FROM THE FILE.
	XOR C,A			;SAVE CHECKSUM
	MOVEM A,4(D)		;SAVE BYTE.
	ADDI D,4
	AOJL B,DUMPX0		;LOOP READING/WRITING
	;Here when all the file data has been collected for current output block.
DUMPXX:	MOVSI B,-LMEDE1		;aobjn ptr to previous media error table
	MOVEI A,0		;no previous media errors, since coming from disk
DUME:	IDPB A,D		;output combined error datum
	AOBJN B,DUME		;loop outputting zeroes
	MOVE A,REDERR(B)	;get constant for end of prev media error block
	IDPB A,D		;write it
	XOR C,A			;adjust checksum
	IDPB C,D		;WRITE THE CHECKSUM INTO THE BUFFER
;;	SOS TOBUF+2		;DECREMENT THE COUNT BY ONE MORE
	MOVEM D,TOBUF+1		;POINTS TO LAST BYTE DEPOSITED.
	SKIPLE FSIZE		;any data left in file?
	JRST DUMP2		;yes, write continuation record
	JRST CPOPJ1		;no, all done, file dumped successfully

;WRITE A TAPE HEADER OR TRAILER.

TAPHED:	SETZM TAPWFL
	PUSHJ P,MT2NOP		;NO-OP so status will be available
	GETSTS MTA2,A
	TRNE A,IOBOT		;Front of tape?
	 SETOM TAPWFL		;Yes, set flag to check for write lock
	JRST TAPHD0

TAPTAI:	SETZM TAPWFL
	SKIPA B,['*TAIL*']
TAPHD0:	MOVE B,['*HEAD*']
	SKIPE TELEOF		;skip unless debugging, reporting EOFs
	OUTSTR [ASCIZ/--Writing header or trailer block--/]
	HRLZ A,.JBVER		;GET THE VERSION NUMBER
	HRRI A,HEDLEN		;WORD COUNT FOR HEADER.
	PUSHJ P,TWRITE		;WRITE
	 JFCL
	PUSH P,TOBUF+1		;save ptr to wd cnt wd in buffer
	MOVNI A,HEDLEN
	ADDM A,TOBUF+2
	MOVE A,['DART  ']
	IDPB A,TOBUF+1
	IDPB B,TOBUF+1
	PUSHJ P,COLEAD		;put common leader info into output buffer
	POP P,B			;get ptr to wd cnt wd in output buf, for checksum
	PUSHJ P,ROTCHK		;compute rotated checksum in A, from output buffer
	IDPB A,TOBUF+1		;output it
	PUSHJ P,MT2CLZ		;FORCE HEADER FILE OUT, write EOF
	PUSHJ P,MT2CTS		;skip if EOF written OK, remember where written
	 JFCL			;end of tape, but we don't care
	SKIPN TAPWFL
	 POPJ P,		;Tape was not rewound or was TAPTAI
IFN DBGSW,<
	SKIPE DBGNTP
	POPJ P,			;no actual tape, so return now
>;IFN DBGSW
; Check tape for write lock if was rewound: ask operator to
;  put in a write ring, and then rewind and retry operation.
	GETSTS MTA2,A
	TRNN A,IOTEND		;Not IOTEND
	TRNN A,IOIMPM		;and IOIMPM implies write locked
	 POPJ P,
	PUSHJ P,FLUSH
	OUTSTR [ASCIZ/
This tape is write-locked!  If you are SURE you want to continue
and write on the tape, put the write ring in and type carriage return: /]
	INCHWL A
	PUSHJ P,FLUSH
	GETSTS MTA2,A
	TRZ A,700000
	SETSTS MTA2,(A)
	PUSHJ P,MT2REW		;Make sure it is rewound
	PUSHJ P,MT2NOP		;Wait for rewind, make status avail.
	PUSHJ P,MT2REL
	PUSHJ P,MTINIW		;Init magtape for writing
	JRST TAPHD0		;try again to write header

IFN DBGSW,<
;FAKE CLOSE OR OUTPUT BY MOVING TO NEXT BUFFER
NXTOBF:	PUSH P,A
	PUSH P,B
	HRRZ A,@TOBUF		;POINT AT NEXT BUFFER
	HRRZM A,TOBUF		;UPDATE BUFFER HEADER BUFFER POINTER
	ADDI A,2		;POINT AT DATA PART OF BUFFER
	HLL A,TOBUF+1		;PICK UP HIGH PART OF BYTE POINTER
	TLZ A,770000		;ZAP POSITION PART
	MOVE B,A
	TLO A,440000		;AND SET IT TO =36
	MOVEM A,TOBUF+1		;STORE NEW BYTE POINTER IN BUFFER HEADER
	LSH B,-30		;GET BYTE SIZE
	MOVEI A,44		;NUMBER OF BITS PER WORD
	SKIPE B
	IDIV A,B		;GET NUMBER OF BYTES PER WORD IN A
	MOVE B,@TOBUF		;GET DATA SIZE+1,,NEXT BUFFER POINTER
	TLZ B,400000		;TURN OFF FLAG BIT
	MOVEM B,@TOBUF		;PUT IT BACK
	HLRZ B,B		;GET DATA SIZE+1
	SOS B			;GET DATA SIZE
	IMUL A,B		;GET BYTE COUNT
	MOVEM A,TOBUF+2		;STORE IT IN BUFFER HEADER
	POP P,B
	POP P,A
	POPJ P,
>;IFN DBGSW

;Set up A with Dart-format time and date.
TIMDAT:	ACCTIM A,		;get date,,time in secs
	HLRZ D,A		;date in RH D
	MOVEI A,(A)		;time in secs
	IDIVI A,74		;time in mins in A, clobber B
	LSH A,14		;shift time left 12 bits (into bits 13:23)
	DPB D,[POINT 12,A,35]	;insert low date field below time field (24:35)
	LSH D,-14		;shift high date to low bits
	DPB D,[POINT 3,A,2]	;insert high date field above time field (0:2)
	MOVEM A,LASTTD		;remember last time and date, for DOMOUNT/Header
	POPJ P,

;Insert extra leader info in output buffer.
;Call w/B containing '*FILE*' for file-start block or 'CON',,IOVER for cont block.
;C contains running checksum.
WRXINF:	MOVE A,['DART  ']
	IDPB A,TOBUF+1		;'DART  '
	XOR C,A			;adjust checksum
	IDPB B,TOBUF+1		;'*FILE*' or 'CON',,IOVER
	XOR C,B			;adjust checksum
	PUSHJ P,COLEAD		;put common leader info into output buffer
	MOVE A,FSIZE		;remaining word count in file, counting
	IDPB A,TOBUF+1		; data to go in current buffer
	XOR C,A			;adjust checksum
	MOVEI B,LLEAD3-LL3FSZ	;number of unused words of leader
	JUMPLE B,CPOPJ		;jump if none
	MOVEI A,0		;fill with zeroes
WRXIN2:	IDPB A,TOBUF+1		;output a zero, which doesn't affect checksum!
	SOJG B,WRXIN2
	POPJ P,

;Stuff common leader info to output buffer, for all tape block types:
;  time&date, PPN, class&tape, rel&abs dump,
;  tape footage, reserved 0 (unused), all 1s, all 0s.
COLEAD:	PUSHJ P,TIMDAT		;get time and date into A (clobbers B and D)
	IDPB A,TOBUF+1		;time and date
	XOR C,A			;adjust checksum
	MOVE A,LOGPPN
	IDPB A,TOBUF+1		;logged-in user name (PPN)
	XOR C,A			;adjust checksum
	HRLZ A,CLASS
	HRR A,TAPNO
	IDPB A,TOBUF+1		;class,,tape nbr
	XOR C,A			;adjust checksum
	MOVE A,MEMSAV+RELABS	;get dump numbers
	IDPB A,TOBUF+1		;relative and absolute dump numbers
	XOR C,A			;adjust checksum
	MOVE A,MEMSAV+MT2POS	;PICK UP output MTA POSITION
	ADD A,[6*MXINCH]	;ADD 6 INCHES FOR ROUNDING
	IDIV A,MTFOOT		;GET FEET (REMAINDER IN B)
	IDPB A,TOBUF+1		;include in header
	XOR C,A			;adjust checksum
	MOVEI A,0
	IDPB A,TOBUF+1		;reserved for use in later tape version
;	XOR C,A			;adjust checksum (unnecessary for 0)
	SETO A,			;insert word of all ones
	IDPB A,TOBUF+1		;include in header
	XOR C,A			;adjust checksum
	SETZ A,			;insert word of all zeroes
	IDPB A,TOBUF+1		;include in header
;	XOR C,A			;adjust checksum (unnecessary for 0)
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                             subttl restore a data file from tape. ; RDFIL RDFI00 RDFIL0 RDHED RDHED6 RDHED9 RDHED7 PRVMTM RDHED8 RDHED5 ISWLUP ISWRNX ISWRN0 CHKPHD ISWRNG WRONGO RDHHAK RDHPRV RDHEDP RDHED2 RDFISS RDFILX RDFILS RDFLX1 RDFLX2 tibufc FMTCHK FMTCH0 FMTBEG FMTBE2 FMTBE3 CPOPJ4 CPOPJ3 FMTBE4 FMTCON FMTCO3 FMTCOE FMTCO2 LENCHK RDERR0 RDER00 RDERR RDERR1 RDER11 RDCON RDERR2 RDERR3 RDERR4 FAKEDV FAKEFI ERREXT MKTURK WRECK1 WRK1 WRECK2 NODART NOHDTR ROTCHK ROTCHL TSTONE TSTZER TSTZE2 MTBFSH RFDB2B RDHED0 RDHED4 RDHED3 PRVMTM

;Examine new tape word-count word looking for a file.
;May see a tape header or trailer.
;Takes DIRECT return if encounters tape header/trailer block, unless RDHACK is on.
;RDHACK bit is cleared when new header/trailer is encountered (not for previous
;media one), w/typeout of header info suppressed.  Previous media header also
;has typeout suppressed by RDHACK, but RDHACK is not cleared.
;Always skips if RDHACK is on.
;Takes SKIP return if not current media header/trailer.
;Takes SKIP return with MTAEOT on if logical EOT seen.
;Returns with IWC holding word count of file data plus any trailer data in buffer.
;SRCDEV/FILINF get set up and CHKSUM gets updated for block words read.
RDFIL:	AOS (P)			;assume won't see header/trailer -- want skip return
RDFI00:	PUSHJ P,CLRCNT		;clear error counts for next file read
	TRZ FL,MTAEOT		;ASSUME NOT AT THE logical END of tape
	PUSHJ P,TREADX		;READ WC WORD FROM TAPE
RDFIL0:	TRNE FL,MTAEOT		;logical EOTAPE NOW?
	POPJ P,			;END OF TAPE TO REPORT.
	JUMPE A,RDHED2		;JUMP IF WC=0, NO DATA LEFT IN THIS magtape record
	PUSHJ P,FMTCHK		;check the word-count word for reasonableness
	 JRST RDERR		;not valid at all, treat as data in fake file
	 JRST RDCON		;file cont block, but MT buffer is short (MT lost)
	 JRST RDCON		;valid continuation block, but no file start!
	 PUSHJ P,MTBFSH		;file start block, but MT buffer is short (MT lost)
	pushj p,iwcdbg		;make sure RH A isn't negative or otherwise bad
	HRRZM A,IWC		;save the word count
	PUSHJ P,DBLOG0		;log wd cnt word in circular buffer for debugging
	JUMPL A,RFIL1		;jump if this is a file-start block
;Looks like we have a tape header/trailer block.
;Enter here only when had wrong tape in tape header in tape copy, found new hdr.
RDHED:	MOVEM A,RHDLEN		;save header info, for TCOPY
	SETZM SVHDAT		;no date from header yet
	HLRZ A,A		;GET VERSION NUMBER ONLY
	MOVEM A,RDVERS		;SAVE VERSION NUMBER
	PUSHJ P,TREAD		;READ ON
	MOVEM A,RHDART		;save header info, for TCOPY
	CAME A,['DART  ']	;IS THIS REASONABLE?
	JRST NODART		;ASSUME ILLEGAL FORMAT
	HRRZ B,RHDLEN		;get word count for header
	CAIGE B,HEDLE0
	MOVEI B,HEDLE0		;gotta be at least this big
	CAILE B,HEDLEN
	MOVEI B,HEDLEN		;can't be bigger than this
	MOVNI B,(B)		;-wd cnt
	ADDM B,IWC		;update WC for wds to be read (is this needed?)
	MOVSI B,1(B)		;-wd cnt in LH (less 'DART' word already read)
	HRRI B,RHTYPE		;make aobjn ptr to header words left to be read
RDHED6:	PUSHJ P,TREAD		;read word of header
	MOVEM A,(B)		;save it
	AOBJN B,RDHED6		;read all of header we expect to see
repeat 0,<
	PUSHJ P,TREAD
	MOVEM A,RHTYPE		;save header type, for TCOPY
	PUSHJ P,TREAD		;READ DATE/TIME
	MOVEM A,RHDATE		;save header info, for TCOPY
	PUSHJ P,TREAD		;get ppn of tape writer
	MOVEM A,RHDPPN		;save header info, for TCOPY
	PUSHJ P,TREAD		;tape number and class word
	MOVEM A,RHDTAP		;save header info, for TCOPY
>;repeat 0
	TLNE FL,RDHACK		;SPECIAL TREATMENT FOR TAPE HEADERS?
	JRST RDHHAK		;yes, don't type it out, maybe flag if not prev med
	MOVEI B,[ASCIZ/DART version /]
	PUSHJ P,STROUT
	MOVE A,RDVERS		;get back version number we just read
	PUSHJ P,TYPOCT		;TYPE VERSION NUMBER.
	MOVE A,RHTYPE		;get header type
	HRROI B,[ASCIZ/  Unknown block /]
	CAMN A,['*HEAD*']
	MOVEI B,[ASCIZ/  Header /]
	CAMN A,['*TAIL*']
	MOVEI B,[ASCIZ/  Trailer /]
	MOVEM B,HEDSTR		;flag whether we saw OK hdr/trailer
	PUSHJ P,STROUT

comment  Typeout formats:

Old --

DART version 6  tape header
 Recorded  15:18 17-Jun-87,  by [ MC,SYS] SYSTEM PERMANENT class
 Tape number P3000/1  Absolute dump 1  Tape position 0 feet.

DART version 6  tape header
 Recorded  15:18 17-Jun-87,  by [ MC,SYS] SYSTEM PERMANENT class
 Tape position 0 feet.

DART version 6  tape header
 Previous media written 11:59  5-Nov-72,  by [DMP,SYS] SYSTEM PERMANENT class
 Tape number P1/1  Absolute dump 1  Tape position 0 feet.

DART version 6  Unknown type of Dart header-trailer block!
 Previous media written 11:59  5-Nov-72,  by [DMP,SYS] SYSTEM PERMANENT class
 Tape number P1/1  Absolute dump 1  Tape position 0 feet.


New --

DART version 6  Header (1230 feet, dump set 323) of tape number P3000/12
 Recorded  15:18 17-Jun-87  by [ MC,SYS] SYSTEM PERMANENT class

If the date just above agrees with the date on the input
tape's label, type GO<return>; otherwise type X<return>:

DART version 6  Header (1230 feet, dump set 323) of tape
 Recorded  15:18 17-Jun-87  by [ MC,SYS] SYSTEM PERMANENT class

DART version 6  Trailer (1230 feet, dump set 323) of previous media tape P2324
 Originally written  11:59  5-Nov-72  by [DMP,SYS] SYSTEM PERMANENT class

DART version 6  Unknown block (1230 feet, dump set 323) of tape number P3000/12
 Originally written  11:59  5-Nov-72  by [DMP,SYS] SYSTEM PERMANENT class



	HRRZ B,RHDLEN
	CAIGE B,RHDNBR-RHDLEN
	JRST RDHED7		;old format header, newer words not present
	MOVEI A,"("
	PUSHJ P,OUT.CH
	HRRZ A,RHDPOS		;get footage of tape position
	PUSHJ P,DECOUT
	MOVEI B,[ASCIZ/ feet/]
	PUSHJ P,STROUT
	SKIPN RHDNBR		;any dump numbers?
	JRST RDHED9		;no
	MOVEI B,[ASCIZ/, dump set /]
	PUSHJ P,STROUT
	HRRZ A,RHDNBR		;type absolute dump number
	PUSHJ P,DECOUT
	HLRZ A,RHDNBR		;get rel dump nbr
	JUMPE A,RDHED9		;jump if none
	MOVEI A,"/"
	PUSHJ P,OUT.CH
	HLRZ A,RHDNBR		;relative dump number
	PUSHJ P,DECOUT		;report it
RDHED9:	MOVEI B,[ASCIZ/) /]
	PUSHJ P,STROUT
RDHED7:	MOVEI B,[ASCIZ/of /]
	PUSHJ P,STROUT
	HLRZ A,RHDTAP		;get back class number
	CAIL A,CLMAX		;is class number within bounds?
	MOVNI A,1		;no, set class to -1
	MOVEM A,TAPCLS		;save tape class.  1=T, 2=P
	HRRZ A,RHDTAP		;get back tape number
	MOVEI B,[ASCIZ/tape number /] ;for system numbered tapes
	TRNN A,-1		;skip if any tape number
	MOVEI B,[ASCIZ/tape./]	;for user unnumbered tapes
PRVMTM__40000	;left half bit in date/time word indicating previous media time
	MOVE A,RHDATE		;see if previous media header
	TLNE A,PRVMTM		;check and clear previous-media bit
	MOVEI B,[ASCIZ/previous media tape /] ;for system or user copied tapes
	PUSHJ P,STROUT
	SETZM THSTAP		;assume current tape is unnumbered (there's no P0)
	HRRZ A,RHDTAP		;get back tape number
	SKIPE A			;skip if this tape is unnumbered
	SKIPG B,TAPCLS		;skip if a System Class tape
	JRST RDHED8		;user tape or no number
	CAIE B,2		;Skip if Permanent
	TRO A,400000		;TEMP FLAG
	MOVEM A,THSTAP		;Tape # of this tape, + 400000 if T tape
	PUSHJ P,MKTURK		;Make a turkey file entry
	MOVE A,THSTAP
	TRNE A,400000
	SKIPA A,["T"]
	MOVEI A,"P"
	PUSHJ P,OUT.CH		;type tape series letter
	HRRZ A,THSTAP
	TRZ A,400000
	PUSHJ P,DECOUT		;type tape number

RDHED8:	MOVE A,RHDATE		;see if previous media header
	MOVEI B,[ASCIZ/
 Recorded  /]
	TLNE A,PRVMTM		;check and clear previous-media bit
	MOVEI B,[ASCIZ/
 Originally written  /]
	PUSHJ P,STROUT
	MOVE A,RHDATE		;get time and date again
	TLZ A,700000!PRVMTM	;CLEAR HIGH DATE DATE75 and prev-media bit
	LSH A,-14		;TIME ONLY (in minutes)
	PUSHJ P,TYTIME		;TYPE TIME
	MOVEI B,[ASCIZ/ /]
	PUSHJ P,STROUT
	MOVE A,RHDATE		;GET DATE AND TIME BACK
	LDB B,[POINT 3,A,2]	;GET HIGH DATE		DATE75
	ANDI A,7777		;LOW DATE ONLY
	DPB B,[POINT 3,A,23]	;STORE HIGH DATE	DATE75
	MOVEM A,SVHDAT		;save header date
	PUSHJ P,TYDATE
	MOVEI B,[ASCIZ/  by /]
	PUSHJ P,STROUT
	MOVE A,RHDPPN		;get back saved PPN
	PUSHJ P,PPNOUT
	MOVE A,TAPCLS		;get tape class.  1=T, 2=P
	MOVE B,CLNAM(A)		;print the class name
	PUSHJ P,STROUT
	MOVEI B,[ASCIZ/class
/]
	PUSHJ P,STROUT
	HRRZ B,RHDLEN		;get hdr wd cnt
	CAIGE B,RHDCHK-RHDLEN	;enough words for following check?
	JRST RDHED5		;no, early format, no checksum or test words
	MOVE A,RHDONE		;get word of ones
	PUSHJ P,TSTONE		;test word for all ones
	MOVE A,RHDZER		;get word of zeroes
	PUSHJ P,TSTZER		;test word for all zeroes
	;Check rotated checksum of header or trailer.
	MOVEI B,RHDCOP		;ptr to data to checksum
	PUSHJ P,ROTCHK		;compute rotated checksum in A
	XOR A,RHDCHK		;is checksum correct?
	JUMPE A,RDHED5		;jump if OK
	PUSH P,A		;save XOR of good and bad
	MOVEI B,[ASCIZ/ Rotated header checksum failed: xor = /]
	PUSHJ P,STROUT
	POP P,A
	PUSHJ P,TYPOCH		;type octal halfwords of XOR of good and bad
	MOVEI B,CRLF
	PUSHJ P,STROUT
	SETZM SVHDAT		;error invalidates header date
RDHED5:	TRC FL,LSTON+LSTTTY
	TRCN FL,LSTON+LSTTTY
	CLOSE LST,		;FORCE TTY OUTPUT
	SKIPGE HEDSTR		;skip unless bad header format
	PUSHJ P,NOHDTR		;tell user about it
	MOVE A,RHDATE		;see if this is really a previous media header
	TLNN A,PRVMTM		;header copied from previous media?
	SKIPGE HEDSTR		;skip unless bad format
	SETZM SVHDAT		;error or previous media invalidates header date
	SKIPLE B,SVHDAT		;skip unless valid date
	CAMLE B,TODAYD		;can't be in future
	CAIA
	SKIPLE MEMSAV+MTIDAT	;don't clobbber verified hdr date with trlr date
	CAIA
	HRROM B,MEMSAV+MTIDAT	;store not-verified date of tape header

	SKIPL TAPCLS		;skip unless bad tape class word
	SKIPGE HEDSTR		;skip unless bad format
	JRST RDHEDP		;don't check tape number if bad format or bad class
	SKIPE A,PREQTP		;ARE WE READING A TAPE FOR PRESTORE?
	CAMN A,THSTAP		;yes.  Do tape numbers match?
	JRST RDHEDP		;Don't care what tape, or they match.
IFN FTDBMC,<
printx RDHED5 allows non-P tapes for MCOPY debugging, for now.
skipn thstap
skipn mascop
JFCL ;caia 	;allow P tapes for other series too
jrst rdhedp	;for debugging, allow use of non-P tapes
>;IFN FTDBMC
	MOVE A,RHDATE		;see if this is really a previous media header
	TLNE A,PRVMTM		;header copied from previous media?
	JRST RDHEDP		;yup, isn't really beginning of new tape, all OK
IFN FTCOPY,<
	SKIPN MASCOP		;are we doing the tape copy?
	JRST ISWRNG		;no, wrong tape for sure
;If saw a T tape header, read a little more of this tape looking for P tape hdr.
	HLRZ A,RHDTAP		;get tape number
	CAIE A,1		;T tape?
	JRST ISWRNG		;no, give up, wrong tape
	PUSH P,[=200]		;number of records to read looking for P tape hdr
ISWLUP:	PUSHJ P,TREAD1		;read another record from the tape
	 JRST CHKPHD		;success
	 JRST ISWRN0		;logical EOT
ISWRNX:	SOSL (P)		;MT read error, skip if looked far enough
	JRST ISWLUP		;read on, looking for P hdr
ISWRN0:	SUB P,[1,,1]		;flush count from stack
	JRST ISWRNG		;didn't find P tape hdr, wrong tape, I guess

CHKPHD:	SKIPG TIBUF+2		;did we see any data?
	JRST ISWRNX
	AOS TIBUF+2		;fix count, haven't read any data yet from buffer
	PUSHJ P,TREADX		;READ WC WORD FROM TAPE
	HLRE B,A		;check left half
	JUMPLE B,ISWRNX		;jump unless looks like header
	PUSHJ P,FMTCHK		;check the word-count word for reasonableness
	 JRST ISWRNX		;not valid at all, treat as data in fake file
	 JRST ISWRNX		;file cont block, but MT buffer is short (MT lost)
	 JRST ISWRNX		;valid continuation block, but no file start!
	 JRST ISWRNX		;file start block, but MT buffer is short (MT lost)
	pushj p,iwcdbg		;make sure RH A isn't negative or otherwise bad
	HRRZM A,IWC		;save the word count
	PUSHJ P,DBLOG0		;log wd cnt word in circular buffer for debugging
	SUB P,[1,,1]		;looks like we win, flush record limit from stack
	OUTSTR [ASCIZ/

(Looking for correct P-tape header.)

/]
	JRST RDHED		;go process the hdr
	
ISWRNG:
>;IFN FTCOPY
IFN STANSW!IRCPPN,<
	MOVNI A,1		;NO, FOO
	BEEP A,
>;IFN STANSW!IRCPPN
	MOVE A,RHTYPE		;get header type
	CAMN A,['*TAIL*']	;better not be end of tape!
	PUSHJ P,WRONGO		;we went through entire wrong tape!
	OUTSTR [ASCIZ /
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! THAT'S NOT THE TAPE I ASKED FOR !!!
!!!      GO GET THE RIGHT TAPE      !!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
/]
IFN STANSW!IRCPPN,<
	BEEP A,
>;IFN STANSW!IRCPPN
	PUSHJ P,MTAREW
	OUTSTR [ASCIZ /
When you get it ready type Y: /]
	PUSHJ P,PYORN0
	 JRST .-2
	SKIPE MASCOP		;skip unless Master Copy
	PUSHJ P,BRANEW		;ask for brand name again
	PUSHJ P,MTAREW
	JRST RDFI00		;LET'S TRY AGAIN FOLKS

WRONGO:	SKIPN MASCOP		;only really matters if master tape copy
	POPJ P,
	OUTSTR [ASCIZ/
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!    This was the WRONG TAPE and now we've read the whole thing!    !!!
!!! The master copy database is now SCREWED UP, so YOU NEED A WIZARD! !!!
!!! Do NOT try to resume the tape copy without consulting a wizard.   !!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
/]
	HALT .

;Here if RDHACK was on when header/trailer encountered (in RDFIL from FIXPOS).
;That means we don't want to type out the header info, but instead just treat
;this header as a normal file.
repeat 0,<
;Clear RDHACK iff this is not a previous media header/trailer.
>;repeat 0
RDHHAK:
	MOVE A,RHDATE		;get time/date word, to check prev media bit
repeat 0,<
	TLNE A,PRVMTM		;check previous-media bit
	SKIPN MASCOP		;bit on, presumably doing tape copy
	SKIPA B,RHTYPE		;prevent match of real file in FIXPOS
	JRST RDHPRV		;previous media header in tape copy
	MOVEM B,FILINF+DDNAM	;give an idea of what we saw
	SETZM FILINF+DDEXT	;clear old junk (for typeout in FIXPOS)
	SETOM FILINF+DDPPN	;really prevent match of real file back in FIXPOS
	TLZ FL,RDHACK		;indicate that we saw a current media hdr
	POPJ P,			;act like we read a file

;Saw previous media tape header/trailer, with RDHACK on, in tape copy.
;This may be the "file" we're looking for in FIXPOS.
RDHPRV:
>;repeat 0
	MOVEM A,FILINF+DDEXT	;RHDATE parallels extension word
	MOVE A,RHTYPE
	MOVEM A,FILINF+DDNAM	;RHTYPE parallels filename word
	MOVE A,RHDTAP
	MOVEM A,FILINF+DDPPN	;RHDTAP parallels PPN word
	SETZM INVERS		;assume early tape format
	HRRZ A,RHDLEN
	CAIGE A,RHDNBR-RHDLEN	;long tape header?
	POPJ P,			;old format header, no rel dump number present
	MOVEI A,IOVER3		;yes, must be at least this tape format
	MOVEM A,INVERS		;let FIXPOS check rel dump nbr
	MOVE A,RHDNBR		;get rel dump nbr
	MOVEM A,SRCDEV+LL3DMP-1	;put it where FIXPOS expects it for normal file
	POPJ P,			;return as if this were a normal file

;Here at end of reading tape header/trailer.
RDHEDP:
;	MOVNI A,4
;	ADDB A,IWC
	SOS (P)			;undo AOS at RDFIL, direct return for header/trailer
;;CLREOF:	
;;This MTACLZ was the wrong thing because it cleared IOEND, which would have been
;;set if the tape header/trailer was followed by an EOF.  In particular, a tape
;;trailer (or header, even) followed by two EOFs would appear to be followed by
;;only one, and hence not by a logical EOT, if this MTACLZ cleared IOEND.
;;	PUSHJ P,MTACLZ
;;Instead we just do the SETZM below.
;;;I don't understand why, but at IRCAM MTACLZ seems to skip over the EOF
;;;so that REOFIL doesn't figure out it's the end of the tape after the
;;;trailer.  Flushing MTACLZ makes it work.  Duh. (--BH)
	SETZM TIBUF+2		;clear input count to get new buffer next
	GETSTS MTA,A
	TRZN A,IOEOF		;CLEAR IODEND (END OF FILE) (shouldn't be on!)
	POPJ P,			;no EOF here
	SETSTS MTA,(A)		;clear EOF bit
	SKIPE TELEOF
	OUTSTR [ASCIZ/-Input tape EOF (hdr-trlr)-
/]
;RDHEDP clears any EOF but doesn't check for logical EOT (two EOFs).
;So an EOF seen here won't cause Dart to notice a logical EOT -- this is a bug.
;Fortunately, we should never get an EOF here, but just in case we do:
	OUTSTR [ASCIZ\(Unexpected EOF in tape header/trailer record!  Continuing.)
\]
	SETOM SAWEOF		;flag that EOF was seen, for TLIST stopping
	SETOM MTFBEG		;we're at beginning of input magtape file
	AOS MEMSAV+MTAFIL	;count an MT file seen on input tape
	POPJ P,

;Here if no more data in magtape record, go on to next one.
RDHED2:	SETZM TIBUF+2		;ignore rest of record
;;	PUSHJ P,CLREOF		;close magtape and clear EOF in case on
	JRST RDFI00		;look for a real block word count

;Here upon unexpected short buffer while skipping a file.
RDFISS:	PUSHJ P,SHRTBF		;report an unexpectedly short buffer (clob A,B,C)
	JRST RDFILS		;continue searching for next disk file

;Here to skip a file on the tape.
;Skip until see logical EOT, a file-start block, or tape trailer/header.
RDFILX:	MOVE A,IWC		;PICKUP THE WORD COUNT REMAINING
	ADD A,PSTDAT		;include trailer words
	ADDM A,TIBUF+1		;INCREMENT THE BYTE POINTER
	pushj p,tibufc		;check tibuf+1 for overflow
	MOVN A,A
	ADDB A,TIBUF+2		;DECREMENT THE BUFFER COUNT
	CAIG A,1		;Record is short if count's not positive
	JRST RDFISS		;Short record, report it (avoid recursion)
	PUSHJ P,TREAD		;READ AHEAD. THIS IS THE CHECKSUM
RDFILS:	PUSHJ P,TREADX		;READ MORE. THIS IS NEXT WC.
	SETZM PSTDAT		;assume no trailer
	TRNE FL,MTAEOT		;logical END OF TAPE?
	POPJ P,			;YES. RETURN.
	JUMPL A,RDFLX1		;jump if this is a file-start block
	JUMPE A,RDFLX2		;JUMP IF NO DATA LEFT IN THIS RECORD
	TLNE A,-1		;SKIP IF LEFT SIDE OF A IS ZERO
	JRST RDFLX1		;this should be a tape trailer or header
	MOVEM A,IFSIZE		;next routine needs something here, make it work
	PUSHJ P,IWCCHK		;make sure continuation word count is reasonable
	 JRST RDFLX2		;bad format, no more room in this buffer
	 MOVEI A,0		;XCT'd by routine upon detecting bad format
	SUB A,PSTDAT		;reduce wd cnt by size of trailer
	JUMPLE A,RDFLX2		;jump if bad format, ignore rest of buffer
	pushj p,iwcdbg		;make sure RH A isn't negative or otherwise bad
	HRRZM A,IWC		;this is a continuation block, save the word count
	PUSHJ P,DBLOG1		;log wd cnt word in circular buffer for debugging
	JRST RDFILX		;AND GO FLUSH MORE.

;end of the tape file.  Put things back so next RDFIL will work
RDFLX1:	SOS TIBUF+1		;DECREMENT BYTE POINTER
	AOS TIBUF+2		;INCREMENT WORD COUNT
	POPJ P,			;RETURN

RDFLX2:	SETZM TIBUF+2		;ZERO REMAINING COUNT
	POPJ P,			;SO NEXT READ WILL GET NEW RECORD

;Bugtrap: check TIBUF+1 for overflow into LH after we've done ADDM X,TIBUF+1.
tibufc:	push p,a
	move a,tibuf+1
	tlnn a,37		;shouldn't be index or indirect bits on
	jrst popaj
	outstr [asciz/%%% TIBUF+1 has overflowed into LH upon ADDM.
/]
	HALT .
	jrst popaj		;hope he fixed it!

;Check word-count word in A for proper format.  Clobbers B.
;(Does not handle case of zero in A, which normally signals no more data in buffer.)
;Direct return if bad format word count word; A has been clobbered.
;Single skip if file-cont block but MT buffer count is shorter than expected.
;Double skip if looks like valid continuation block word count word.
;Triple skip if file-start block but MT buffer count is shorter than expected.
;Quadruple skip if good file-start or header/trailer block.
;In all cases, sets up PSTDAT with number of words
;following file data, if any, before the checksum word.
;For file-start blocks, word count returned in A includes leader info
;words, which have not been read yet.  For continuation blocks, the word
;count has been reduced for any leader words (which have been read and
;stored in CONDEV/CONINF).  For both file-start and continuation blocks,
;the word count has been reduced for any trailer info (media error data).
;Thus, for continuation blocks, the word count counts only file data words.
FMTCHK:	TLNN A,-1		;check for file-continuation block
	JRST FMTCON		;got one, but haven't seen corresponding file-start
FMTCH0:	SETZM PSTDAT		;assume no error data at end of block
	JUMPL A,FMTBEG		;jump if may be a file-start block
;Seems to be a header/trailer block.
	MOVEI B,(A)		;get just the word count
	CAIE B,HEDLE0		;old hdr length
	CAIN B,HEDLEN		;better be what we expect
	TLNE A,VERMSK		;seem to be hdr, make sure reasonable version nbr
	POPJ P,			;bad format (wrong length or version nbr too big!)
	SUBI A,1		;pretend the word count implies a checksum
	PUSHJ P,LENCHK		;make sure length is OK wrt buffer length
	 POPJ P,		;lose, length exceeds buffer space
	 POPJ P,		;lose, length exceeds buffer count, not buf space
	AOJA A,CPOPJ4		;OK, correct word count of header/trailer block

;Seems to be file-start block, LH is negative
FMTBEG:	TLC A,VERMSK		;all these bits should be on, turn them off
	TLCE A,VERMSK		;make sure has reasonable format number
	POPJ P,			;bad format (or format number too big!)
	HLRE B,A		;just negative version number
	CAMLE B,[-IOVER3]	;starting w/format 3, extra data appears in block
	JRST FMTBE2		;earlier format
	MOVEI B,(A)		;copy word count
	CAIGE B,LLEAD3+LMEDER	;must be enough words for leader&trailer
	POPJ P,			;lose
	MOVEI B,LMEDER
	MOVEM B,PSTDAT		;number of words of info following file data
	JRST FMTBE3

FMTBE2:	MOVEI B,(A)		;just the word count
	CAIGE B,INFOSI+DVWD	;better include info block plus devnam
	POPJ P,			;impossible word count is too small, bad format
FMTBE3:	PUSHJ P,LENCHK		;make sure length is OK wrt buffer length
	 POPJ P,		;lose, length exceeds buffer space
	 JRST FMTBE4		;lose (note: PSTDAT may have been set, no harm)
	SUB A,PSTDAT		;reduce word count for any trailer data
CPOPJ4:	AOS (P)			;reasonable file-start, quadruple skip
CPOPJ3:	AOS (P)
	JRST CPOPJ2

;LENCHK failed -- less buffer data than adjusted word count.
;But word count exactly reaches to end of physical buffer.
;Maybe the MT data has been truncated by the hardware.
;If device word has normal value, take "mostly good" file-start return.
;This is a heuristic to keep valid filenames when MT data is truncated
;somewhere after start of a record.
FMTBE4:	MOVE B,TIBUF+1		;get input byte ptr
	MOVS B,1(B)		;get word after wd cnt word
	CAIE B,'DSK'		;this should be device word
	POPJ P,			;no, take bad format return
	HLRE B,A		;get negative tape format number (known negative)
	CAMGE B,[-IOVER2]	;reasonable tape format number (early format)?
	POPJ P,			;no, take bad format return
	PUSHJ P,ZEREND		;zero out end portion of buffer
	 PUSHJ P,ZERERR		;buffer was already full of data, nothing zeroed
	SUB A,PSTDAT		;reduce word count for any trailer data
	JRST CPOPJ3		;triple skip for file-start w/short MT buffer

;Here from FMTCHK, with what seems to be a
;file-continuation record, LH of A is zero.
FMTCON:	SETZM PSTDAT		;assume no error data words at end of this block
	PUSHJ P,LENCHK		;make sure length is OK wrt buffer length
	 POPJ P,		;lose, length exceeds buffer space
	 JRST FMTCO2		;lose, length exceeds buffer count, not buf space
FMTCO3:	HRRZM A,IFSIZE		;next routine expects something for file size
	PUSHJ P,IWCCHK		;check for reasonable count (within buffer size)
	 JRST FMTCOE		;no room in buffer for any data!  read new buffer
	 MOVEI A,0		;XCT'd by routine, indicate bad word count
	JUMPE A,CPOPJ		;jump if bad word count
	SUB A,PSTDAT		;reduce word count for any trailer data
	JRST CPOPJ2		;reasonable word count in continuation block

FMTCOE:	[ASCIZ/
%%% At FMTCON with no room for any data in current buffer.
%%% Find a wizard.
/]
	HALT .

;LENCHK failed -- buffer is shorter than adjusted word count.
;But word count exactly reaches to end of physical buffer.
;Maybe the MT data has been truncated by the hardware.
;Take "mostly good" file-con return.
;This is a heuristic to keep most valid data in place.
FMTCO2:
;	CAIE A,RECSIZ-CKWD-WCWD	;is wd cnt word normal (old value) for file cont?
;	POPJ P,			;no, take bad format return
	PUSHJ P,ZEREND		;zero out end portion of buffer
	 PUSHJ P,ZERERR		;buffer was already full of data, nothing zeroed
	PUSHJ P,FMTCO3		;do rest of check for valid cont block
	 POPJ P,		;lost, take bad format return from FMTCHK
	 HALT .			;can't happen
	JRST CPOPJ1		;take return indicating file-cont with short buffer

;Check length in RH of A against remaining word count in buffer
;Direct return if length is greater than remaining space in buffer.
;Single skip if length is greater than remaining buffer byte count, not buf space.
;Double skips if length is OK.
LENCHK:	TRNE A,400000		;make sure we don't have overflow from negative cnt
	POPJ P,			;impossibly big halfword count
	MOVEI B,CKWD(A)		;just the word count, plus 1 for checksum
	CAMGE B,TIBUF+2		;word count better not go beyond current buffer
	 JRST CPOPJ2		;word count OK
	;The buffer doesn't have enough data to satisfy this "word count",
	;which therefore appears bogus.  But maybe the buffer is missing some
	;data because the drive or DC 136 lost some data unknowingly.
	;So, if this word count doesn't extend beyond the end of the physical
	;buffer, then we'll take a possibly-short-record return in order for
	;someone upstairs to recover as cleanly as possible.
	MOVE B,TIBUF		;get pointer to current buffer
	LDB B,[POINT 17,(B),17]	;get size of buffer in words plus one
	ADD B,TIBUF		;make ptr to last word of buffer
	SUB B,TIBUF+1		;count words in buffer after wd cnt word
	HRREI B,-CKWD(B)	;just 18-bit word count, now signed, less cksum wd
	CAIN B,(A)		;is that the word count we see?
	AOS (P)			;yes, report possible short buffer count
	POPJ P,

;Here from RFIL1 with impossible entry in retrieval data.
; Invalid name or length  DEVICE:FILENA.EXT[PRJ,PRG]  Wd-cnt wd: 123456,,765432
RDERR0:	MOVEI B,[ASCIZ/ Invalid name or length  /]
;	MOVEI B,[ASCIZ/  Invalid filename or file length -- /]
;	MOVEI B,[ASCIZ\  Damaged file w/invalid dev, name, PPN or length.  \]
	PUSHJ P,STROUT
	MOVE B,TIBUF+1		;get byte ptr to wd cnt wd
	MOVE A,WCWD(B)		;get device word, print if not DSK
	CAMN A,['DSK   ']
	JRST RDER00
	PUSHJ P,SIXOUT		;print non-DSK device name
	MOVEI A,":"
	PUSHJ P,OUT.CH
RDER00:	MOVE B,TIBUF+1		;get ptr to wd cnt wd again
	MOVSI D,WCWD+DVWD+DDNAM(B) ;location of filename in buffer, BLT source
	HRRI D,A		;BLT dest
	BLT D,D			;put bad filename into A,B,C,D
	PUSHJ P,OUTFIL		;type filename
	MOVEI B,[ASCIZ/  Wd cnt wd: /]
	JRST RDERR1

;Here from RDFIL when WC word was garbage.
;Treat WC as data in a fake file that we'll cons up.
RDERR:	MOVEI B,[ASCIZ/  Invalid Dart word-count word: /]
;Here from RFIL1 via RDERR0 above if device, filename, PPN or length is bad.
RDERR1:	PUSHJ P,STROUT
	PUSHJ P,TYBWCW		;type the word-count word and CRLF
	SOS TIBUF+1		;back up byte ptr, turning WC word into data
	AOS A,TIBUF+2		;back up buffer count
	SUBI A,2		;use buffer count as word count, allow checksum
	JUMPLE A,RDER11		;jump if there was only one word in the buffer
	pushj p,iwcdbg		;make sure RH A isn't negative or otherwise bad
	HRRZM A,IWC		;save best guess as to valid word count
	PUSHJ P,DBLOG2		;log wd cnt word in circular buffer for debugging
	SETZM CHKSUM		;clear checksum
	SETZM PSTDAT		;treat as old format without extended leader
	AOS BADFMT		;count an error of this type
	AOS TAPERR		;count an error of any type
	JRST RDERR3

RDER11:	MOVEI B,[ASCIZ/
(Ignoring 0- or 1-word buffer.)
/]
	PUSHJ P,STROUT
	PUSHJ P,DBLO14		;log wd cnt word in circular buffer for debugging
	SETZM TIBUF+2		;make sure we ignore rest of this buffer
	JRST RDFI00		;start over looking for a file on tape

;Enter here if looks like a valid file-continuation block, but since there was no
;file-start block, we will pretend we saw one for an imaginary file, setting up
;stuff that RDFIL and RFIL1 set up (IWC, info, FSIZE, SRCDEV, CHKSUM, INVERS).
RDCON:	ADD A,PSTDAT		;include trailer, as if were file-start
	pushj p,iwcdbg		;make sure RH A isn't negative or otherwise bad
	HRRZM A,IWC		;save continuation word count
	PUSHJ P,DBLOG3		;log wd cnt word in circular buffer for debugging
	AOS CONNBG		;count an error of this type
	AOS TAPERR		;count an error of any type
	SKIPN PSTDAT		;is this an early format without a filename?
	JRST RDERR2		;yes, can't tell what file this is part of
	MOVEI B,[ASCIZ/ Continuation block without file-start block,
for file: /]
	PUSHJ P,STROUT
	MOVE D,[CONDEV,,SRCDEV]
	BLT D,SRCDEV+LLEAD3-1	;set up file retrieval from continuation block
	MOVE D,[FILINF,,A]
	BLT D,D			;get filename
	PUSHJ P,TYFIL		;type out filename from ACs
	HRRZ B,FILINF+CONFMT-WCWD-DVWD ;get format number from cont block
	MOVEM B,INVERS		;save it
	MOVE A,FILINF+LL3FSZ-WCWD-DVWD ;get remaining file size from cont block
	MOVEM A,FSIZE		;save it
	PUSHJ P,DBLOG5		;log wd cnt word in circular buffer for debugging
	MOVEI B,CRLF
	PUSHJ P,STROUT
	JRST RDERR4		;finish up output

RDERR2:	MOVEI B,[ASCIZ/ Continuation block for unknown file: /]
	PUSHJ P,STROUT
	PUSHJ P,TYBWCW		;type the word-count word and CRLF
RDERR3:	MOVE B,FAKEDV
	MOVEM B,SRCDEV
	MOVE B,[FAKEFI,,FILINF]	;set up file info from block of fake info
	BLT B,FILINF+INFOSI-1
	SETOM SRCTST+LEDONE	;avoid false error in word of ones
	SETZM SRCTST+LEDZER	;avoid false error in word of zeroes
	SETOM FONYFI		;remember that filename in FILINF is a phony
	SETZM MTFPPN		;prevent STOIFN from saving this place for pickup
;	MOVE A,IWC		;use tape record word count as file length
	MOVSI A,300000		;use very large, very unlikely file size
	MOVEM A,FILINF+DDLNG	;set file length, make all consec cont blocks one file
	MOVEM A,FSIZE		;wherever expected
	PUSHJ P,DBLOG6		;log wd cnt word in circular buffer for debugging
	SETZM INVERS		;set early version number (no file offset)
;	MOVE A,TIBUF+1		;get byte ptr
;	MOVE A,1(A)		;get first data word
;	PUSHJ P,TYPOCH		;print it
RDERR4:	TRC FL,LSTON+LSTTTY
	TRCN FL,LSTON+LSTTTY
	CLOSE LST,		;FORCE TTY OUTPUT
	POPJ P,			;return from RDFIL as if with a real file!

FAKEDV:	' ERROR'		;device, note right justified to avoid real device name
FAKEFI:	'*ERROR'		;filename
	'NEW   '		;extension, indicates a new read error
	0
	'ERROR '		;ppn, note left justfied RH, so can't be real programmer
	REPEAT INFOSI-<.-fakefi>,<0> ; finish off with zeroes

ERREXT:	'ERR   '		;extension that above gets changed to on output tape

;Remember which turkey used this tape last, in case s/he loses it,
;mungs it, or doesn't put it away properly.

MKTURK:	SKIPE MASCOP		;don't touch DSKMSC channel during tape copy!
	POPJ P,			;anyway, tape copy keeps its own log
	MOVEI A,17
	MOVSI B,'DSK'
	MOVEI C,0
	OPEN DSKMSC,A
	PUSHJ P,NODEV
IFN STANSW,<
	MOVE A,['DART  ']
	MOVSI B,'REC'
	MOVEI C,0
	MOVE D,TAPREG		;' SSSYS' OR DBGPPN
	LOOKUP DSKMSC,A
	JRST [SETZB W,X		;ZERO THE WC
		ANDI B,-1	;LOOKUP ERROR CODE ONLY.
		JUMPE B,WRECK1	;JUMP IF FILE NOT FOUND.
		JRST WRECK2]	;JUMP IF OTHER ERROR.
	MOVS D,D
	MOVN W,D
>;IFN STANSW
IFE STANSW,<
	MOVEI A,.RBSIZ		;ARG COUNT = 5
	MOVE B,TAPREG
	MOVE C,['DART  ']
	MOVSI D,'REC'
	MOVEI W,0
	LOOKUP DSKMSC,A
	JRST [SETZB W,X
		 ANDI D,-1
		 JUMPE D,WRECK1
		 JRST WRECK2]
	MOVE W,X
>;IFE STANSW
WRECK1:	MOVE A,['DART  ']
	MOVSI B,'REC'
	MOVEI C,0
	MOVE D,TAPREG		;' SSSYS' OR DBGPPN
	ENTER DSKMSC,A
	JRST WRECK2
	JUMPE W,WRK1		;JUMP IF NO INPUT NEEDED
	IDIVI W,200		;CALCULATE RECORD NUMBER, WORDS IN LAST REC.
	JUMPE X,WRK1		;IF NO WORDS LEFT OVER, WE AVOID READING
	USETI DSKMSC,1(W)	;SET FOR INPUT
	INPUT DSKMSC,[IOWD 200,MEMBLK
			0]
WRK1:	USETO DSKMSC,1(W)
	MOVE A,THSTAP		;Tape number.
	TRZE A,400000		;if T-TAPE
	MOVN A,A		;store negative of the tape number.
	DATE B,			;DATE75-OK
	HRL A,B
	MOVEM A,MEMBLK(X)	;STORE DATE,,TAPE NUMBER.
	MOVE A,LOGPPN
	MOVEM A,MEMBLK+1(X)	;STORE USER NAME
	MOVNI A,2(X)		;INCREASE THE WORD COUNT.
	HRLZ A,A
	HRRI A,MEMBLK-1		;FORM IOWD
	MOVEI B,0
	OUTPUT DSKMSC,A
	CLOSE DSKMSC,
WRECK2:	RELEAS DSKMSC,
	POPJ P,

;Dart header/trailer didn't say 'DART'.
NODART:	OUTSTR [ASCIZ/No 'DART' in apparent header-trailer block, maybe not Dart tape.
/]
	PUSHJ P,GETCON		;get user response, possible GO
	 HRROS DARTHD		;typed GO, don't stop at this error hereafter
;We could try to skip into the record to the next word-count word..
	SOS TIBUF+1		;back up over bad 'DART' word
	AOS TIBUF+2
	JRST RDERR		;assume bad block is part of damaged file

;Dart header/trailer didn't say *HEAD* or *TAIL*.
NOHDTR:	OUTSTR [ASCIZ/Dart header-trailer block specifies neither *HEAD* nor *TAIL*!
/]
;	PUSHJ P,GETCON		;get user response, possible GO
;	 HRROS BADHTR		;typed GO, don't stop at this error hereafter
	AOS BADHTR		;count error
	POPJ P,

;Add up rotated checksum for header or trailer, return checksum in A.
;Call with B pointing to first word, containing VERSION,,WD.CNT.
;We trust the WD.CNT as being valid, so we add up that many words, minus 1
;(we don't add in the last word, as it will become the rotated checksum).
ROTCHK:	MOVN A,(B)		;get negative wd count
	HRLI B,1(A)		;make aobjn ptr, don't include the checksum word
	TDZA A,A		;add checksum up here
ROTCHL:	ROT A,1			;rotate previously computed checksum
	ADD A,1(B)		;add in new data
	AOBJN B,ROTCHL		;loop through data
	POPJ P,

TSTONE:	AOJE A,CPOPJ		;jump if word is valid
	PUSH P,B
	MOVEI B,[ASCIZ/  Test word of one-bits is not all ones: /]
	SOJA A,TSTZE2		;type error msg

TSTZER:	JUMPE A,CPOPJ
	PUSH P,B
	MOVEI B,[ASCIZ/  Test word of zero-bits is not all zeroes: /]
TSTZE2:	AOS TSTERR		;count an error of this type
	AOS TAPERR		;count an error of any type
	PUSH P,A		;preserve bad datum
	PUSHJ P,STROUT		;type error msg
	POP P,A
	PUSHJ P,TYPOCH		;type octal halfwords of failing test word
	MOVEI B,CRLF
	PUSHJ P,STROUT		;type crlf
	POP P,B
	POPJ P,

;Here if found file-start block but MT buffer is short (MT error?).
MTBFSH:	OUTSTR [ASCIZ\  File-start\]
RFDB2B:	OUTSTR [ASCIZ\ block is in too-short MT buffer, extending w/zeroes.
\]
	AOS MTRSHR		;count an error of this type
	AOS TAPERR		;count an error of any type
	POPJ P,

repeat 0,<	;all the way to end of page
	HRRZ A,RHDNBR		;absolute dump number
	JUMPE A,RDHED4
RDHED0:	MOVEI B,[ASCIZ/  Dump set /]
	PUSHJ P,STROUT
RDHED4:	MOVEI B,[ASCIZ/  Tape position /]
	PUSHJ P,STROUT
;	PUSHJ P,TREAD		;tape position in feet
;	MOVEM A,RHDPOS		;save it in case of tape copy
;	ANDI A,-1		;ignore left half (reserved)
repeat 0,<
	PUSHJ P,TREAD		;read reserved word (0)
	MOVEM A,RHDRES		;remember it in case of tape copy
	PUSHJ P,TREAD		;read word of all ones
	MOVEM A,RHDONE		;save it for tape copy
	PUSHJ P,TSTONE		;test word for all ones
	PUSHJ P,TREAD		;read word of all zeroes
	MOVEM A,RHDZER		;save it for tape copy
	PUSHJ P,TSTZER		;test word for all zeroes
	PUSHJ P,TREAD		;read header rotated checksum word
	MOVEM A,RHDCHK		;save it
>;repeat 0

	MOVE A,RHDONE		;get word of ones
	PUSHJ P,TSTONE		;test word for all ones
	MOVE A,RHDZER		;get word of zeroes
	PUSHJ P,TSTZER		;test word for all zeroes
	;Check rotated checksum of header or trailer.
	MOVEI B,RHDCOP		;ptr to data to checksum
	PUSHJ P,ROTCHK		;compute rotated checksum in A
	XOR A,RHDCHK		;is checksum correct?
	JUMPE A,RDHED5		;jump if OK
	PUSH P,A		;save XOR of good and bad
	MOVEI B,[ASCIZ/  Rotated header checksum failed: xor = /]
	PUSHJ P,STROUT
	POP P,A
	PUSHJ P,TYPOCH		;type octal halfwords of XOR of good and bad
	SETZM SVHDAT		;error invalids header date

RDHED3:

	MOVE A,RHDATE		;save header info, for TCOPY
	TLZ A,700000		;CLEAR HIGH DATE DATE75
	MOVEI B,[ASCIZ/
 Recorded  /]
PRVMTM__40000	;left half bit in date/time word indicating previous media time
	TLZE A,PRVMTM		;check and clear previous-media bit
	MOVEI B,[ASCIZ/
 Previous media written /]	;previous media time
	PUSH P,A
	PUSHJ P,STROUT
	POP P,A
	LSH A,-14		;TIME ONLY (in minutes)
	PUSHJ P,TYTIME		;TYPE TIME
	MOVEI B,[ASCIZ/ /]
	PUSHJ P,STROUT
	MOVE A,RHDATE		;GET DATE AND TIME BACK
	LDB B,[POINT 3,A,2]	;GET HIGH DATE		DATE75
	ANDI A,7777		;LOW DATE ONLY
	DPB B,[POINT 3,A,23]	;STORE HIGH DATE	DATE75
	MOVEM A,SVHDAT		;save header date
	PUSHJ P,TYDATE
	MOVEI B,[ASCIZ/,  by /]
	PUSHJ P,STROUT
	MOVE A,RHDPPN		;get back saved PPN
	PUSHJ P,PPNOUT
;	PUSH P,A		;save tn and class.
;	HLRZ A,A		;get the class only
	HLRZ A,RHDTAP		;get back class number
	CAIL A,CLMAX		;is class number within bounds?
	MOVNI A,1		;no, set class to -1
	MOVEM A,TAPCLS		;save tape class.  1=T, 2=P
	MOVE B,CLNAM(A)		;print the class name
	PUSHJ P,STROUT
	MOVEI B,[ASCIZ/class
/]
	PUSHJ P,STROUT
;	POP P,A			;get the tape number again
;	HRRZ A,A		;keep only the number
	HRRZ A,RHDTAP		;get back tape number
	SETZM THSTAP		;current tape number (there's no P0)
	SKIPE A			;skip if this tape is unnumbered
	SKIPG B,TAPCLS		;skip if a System Class tape
	JRST [	HRRZ B,RHDLEN
		CAIGE B,RHDNBR-RHDLEN
		JRST RDHED5	;old format header, following words not present
		JRST ...RDHED1]	;new format, read more header words
	CAIE B,2		;Skip if Permanent
	TRO A,400000		;TEMP FLAG
	MOVEM A,THSTAP		;Tape # of this tape, + 400000 if T tape
	PUSHJ P,MKTURK		;Make a turkey file entry
	MOVEI B,[ASCIZ/ Tape number /]
	PUSHJ P,STROUT
	MOVE A,THSTAP
	TRNE A,400000
	SKIPA A,["T"]
	MOVEI A,"P"
	PUSHJ P,OUT.CH
	HRRZ A,THSTAP
	TRZ A,400000
	PUSHJ P,DECOUT

	MOVEI B,CRLF
	PUSHJ P,STROUT
>;repeat 0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          subttl read a file name from the tape. read tape data. ; SRCTST RFIL1 RFIL1A RFIL1B RFIL2 RFDATA RFDT0 UFDWRD NOWRT NENTRY NOTUFD RFDT1 RFDT1A RFDT2 RERDAT RERDAL RERDA2 TYPMER TYPMEL TYPMEX DECOTT RFDTER RFDTCN RFDTEE RFDT3 RFDT3B RFDT5 RFDT6 DDFWRT DDFWR1 DDFWR3 RFDT2L RFDT2S RFDT22 RFDB2S CKPAUS GETCON GETCO1 PPNCHK PPNCHL PPNCH2

SRCTST__SRCDEV+INFOSIZE		;address one before extended file leader starts

RFIL1:	HLROM A,INVERS		;STORE -(IOVERSION NUMBER)
	MOVNS INVERS		;STORE +(IOVERSION NUMBER)
	MOVE B,TIBUF+1		;get byte ptr to sneak a look at buffer
	SKIPE WCWD+DVWD+DDNAM(B) ;make sure filename isn't zero
	SKIPGE WCWD+DVWD+DDLNG(B) ;make sure file length isn't negative
	JRST RDERR0		;file can't have zero name or neg len, bad block
IFN STANSW,<
	TLNE FL,RDHACK		;are we doing this for FIXPOS?
	JRST RFIL1B		;yes, take anything at all
	MOVE A,WCWD(B)		;get device word, make sure it's reasonable
	CAMN A,['DSK   ']	;SAIL always has this name in device word
	JRST RFIL1A
	CAME A,FAKEDV		;maybe this is phony file from tape copy
	JRST RDERR0		;bad device word, this is bad format tape block
	MOVE A,WCWD+DVWD+DDPPN(B) ;fake file, should have fake PPN
	CAME A,FAKEFI+3		;fake PPN?
	JRST RDERR0		;no -- sort of unlikely to get here, though
	JRST RFIL1B		;this is fake filename, pass it through

RFIL1A:	SKIPE A,WCWD+DVWD+DDPPN(B) ;make sure PPN has right aligned halves
	PUSHJ P,PPNCHK		;skip if PPN in A has right aligned letters & digits
	 JRST RDERR0		;bad PPN, treat as bad format tape block
RFIL1B:
>;IFN STANSW
	PUSHJ P,TREAD		;GET DATA FROM TAPE.
	MOVEM A,SRCDEV		;SAVE SOURCE DEVICE NAME
	MOVEM A,CHKSUM		;SAVE CHECKSUM
	SOS IWC
	SETOM SRCTST+LEDONE	;if old format, avoid false error in word of ones
	SETZM SRCTST+LEDZER	;if old format, avoid false error in word of zeroes
	MOVE A,INVERS		;check tape format
	MOVSI B,-INFOSI		;LOAD UP RETRIEVAL DATA
	CAIL A,IOVER3		;skip if early tape format
	MOVSI B,-LLEAD3+DVWD	;later format has more info before file data
RFIL2:	PUSHJ P,TREAD
	MOVEM A,FILINF(B)
	XORM A,CHKSUM
	SOS IWC			;DECREMENT WC
	AOBJN B,RFIL2		;LOOP READING RETRIEVAL
IFN IRCPPN,<
	MOVE A,[400000,,400000]	;TURN SAIL PPN INTO IRCAM PPN
	ANDCAM A,FILINF+DDPPN
>;IFN IRCPPN
	MOVE A,FILINF+DDNAM	;file name for debugging
	PUSHJ P,DBLO13		;log file name in circular buffer for debugging
	MOVE A,FILINF+DDLNG
	MOVEM A,FSIZE		;SAVE FILE SIZE IN WORDS.
	MOVEM A,IFSIZE		;SAVE input FILE SIZE IN WORDS.
	PUSHJ P,DBLOG7		;log wd cnt word in circular buffer for debugging
	POPJ P,

;Here to restore data from a file.
;(A similar routine exists as RFCOMP, for compare file from tape with disk file.)
RFDATA:	MOVE A,SRCTST+LEDONE	;check test word of all ones
	PUSHJ P,TSTONE		;test word for all ones
	SKIPE A,SRCTST+LEDZER	;check test word of all zeroes
	PUSHJ P,TSTZER		;test word for all zeroes
RFDT0:	SOSGE IWC		;READ ONE FILE DATA WORD FROM TAPE
	JRST RFDT1		;WC EXHAUSTED
	PUSHJ P,TREADW		;READ DATA
	XORM A,CHKSUM
IFN FTHELP,<
;Here we compress any UFD being restored, to the size needed to hold files it had.
	SKIPN RSTUFD		;skip unless restoring a UFD
	JRST NOTUFD
	SOSL UFDCNT		;skip if time for new UFD entry
	JRST NENTRY
	SKIPG RSTUFD		;if RM?,SYS, create UFD slot no matter what
	JUMPE A,NOWRT		;don't write entry in new UFD if none in old
;Here if we have a non-empty UFD entry (or any entry in RM?,SYS).
;Write an empty UFD entry for it.
	PUSH P,B
	MOVEI A,0
	MOVEI B,20		;size of a UFD entry, write this many zeroes
UFDWRD:	PUSHJ P,DDFWRT		;write out a word for a UFD entry
	SOJG B,UFDWRD		;loop till written a whole entry
	POP P,B
NOWRT:	MOVEI A,20-1		;remaining words in this UFD entry
	MOVEM A,UFDCNT
NENTRY:	CAIA			;don't write on the disk till see non-zero entry
NOTUFD:
>;IFN FTHELP
	PUSHJ P,DDFWRT		;WRITE ON THE DISK.
	SOS FSIZE		;DECREMENT THE FILE SIZE FROM TAPE
	JRST RFDT0		;continue reading data

RFDT1:	PUSHJ P,RERDAT		;read any error data for this file
	SKIPLE FSIZE		;don't type out prev media data till done
	JRST RFDT1A
	SKIPE TAPERR-REDERR+MEDERR ;see if any previous media errors
	PUSHJ P,TYPMER		;report previous media errors
RFDT1A:	PUSHJ P,TREADW		;read checksum word
	XORB A,CHKSUM
	JUMPE A,RFDT2		;CHECKSUM IS OK.
	PUSHJ P,ICKBAD		;report bad checkum
RFDT2:	SKIPG FSIZE		;ARE WE DONE?
	JRST RFDT3		;YES.
	PUSHJ P,TREADY		;READ THE WC FROM NEXT RECORD
	TRNE FL,MTAEOT		;skip unless hit premature logical EOT
	JRST RFDT3		;already told user, just truncate the file
	PUSHJ P,FMTCHK		;check format of expected file-continuation wd-cnt
	 JRST RFDTER		;bad format, assume data word, try to recover
	 PUSHJ P,RFDB2S		;file cont block, but MT buffer is short (MT lost)
	 JRST RFDTCN		;continuation-block, all OK
	 JFCL			;file start block with too-short buffer
;looks like a new file or hdr/trlr, end file here, prematurely
	PUSHJ P,RDFLX1		;backup the input byte pointer and byte count
	PUSHJ P,CHKFAK		;Skip IF filename is fake generated during tape copy.
	 SKIPE TOOSHR-REDERR+MEDERR ;if prev media file was too short, old error
	CAIA			;file too short is old error
	PUSHJ P,RFDT22		;report new error
	SKIPE TAPERR-REDERR+MEDERR ;see if any previous media errors
	PUSHJ P,TYPMER		;report previous media errors
	JRST RFDT3		;close the file as if normal end

;Read any trailer info into previous-media error table.
RERDAT:	MOVE A,[POINT 36,MEDERR]
	MOVEM A,MEDPTR		;initialize byte ptr for saving media error data
	JRST RERDA2

RERDAL:	PUSHJ P,TREADW		;get media error data
	XORM A,CHKSUM		;adjust checksum
	IDPB A,MEDPTR		;save media error data
RERDA2:	SOSL PSTDAT		;skip if no (more) media error data
	JRST RERDAL
	POPJ P,

;Report any previous media errors for this file.
TYPMER:	OUTSTR [ASCIZ/ Error(s) from Previous Media:
/]
	MOVSI C,-LMEDE1+1	;type previous media error data except TAPERR, PRMERR
TYPMEL:	SKIPN MEDERR+1(C)	;any error data in this slot?
	JRST TYPMEX		;no, ignore it
	OUTSTR [ASCIZ/    /]	;indent all data
	MOVE A,MRGERR+1(C)	;get merge instruction for this type of error
	MOVEI B,DECOTT		;assume decimal print, with following tab
	CAME A,MRGERR		;use decimal if same instruction as TAPERR has
	MOVEI B,TYPOCH		;otherwise type halfword octal data
	MOVE A,MEDERR+1(C)	;get error data for this slot
	PUSHJ P,(B)		;print data
	OUTCHR [11]		;output a tab
	OUTSTR @ERDESC+1(C)	;type error description 
	OUTSTR CRLF
TYPMEX:	AOBJN C,TYPMEL
	SKIPE A,MEDERR+1(C)	;get error data for this slot (zero if original fmt)
	CAMN A,REDERR+1(C)	;should match the constant
	POPJ P,			;normal value, don't print
	OUTSTR [ASCIZ/    /]	;indent all data
	PUSHJ P,SIXOUT		;type data in sixbit
	OUTCHR [11]		;output a tab
	OUTSTR @ERDESC+1(C)	;type error description 
	OUTSTR CRLF
	POPJ P,

DECOTT:	PUSHJ P,DECOUT		;print in decimal
	OUTCHR [11]		;put out extra tab
	POPJ P,

;Here if found garbage instead of expected file-continuation block word count.
RFDTER:	MOVE A,FSIZE		;amount of file still unread from tape
	MOVEM A,IFSIZE		;this is the max size this new data block could be
	MOVSI A,300000		;force an error in next routine with huge wd cnt
	PUSHJ P,IWCCHK		;check validity of the input word count in A
	 JRST RFDTEE		;no room in buffer for any data!  read new buffer
	 PUSHJ P,BADIWC		;XCT'd: not a valid word-count word, try to recover
	;now assume we've got a continuation block
;Here with continuation block for the current file.
RFDTCN:	CAMLE A,FSIZE		;make sure no more data than file supposed to have
	PUSHJ P,RFDT2L		;word count is longer than remaining file size
    pushj p,iwcdbg		;make sure RH A isn't negative or otherwise bad
	HRRZM A,IWC
	PUSHJ P,DBLOG4		;log wd cnt word in circular buffer for debugging
;;;	SETZM CHKSUM	;;;now done by IWCCHK
	JRST RFDT0

RFDTEE:	[ASCIZ/
%%% At RFDTER with no room for any data in current buffer.
%%% Find a wizard.
/]
	HALT .

;Here when input tape's file has been completely read in.
RFDT3:
IFN FTHELP,<
	SKIPN RSTUFD		;skip if restoring a UFD
	JRST RFDT3B		;not a ufd
	PUSH P,A
	PUSH P,B
	MOVEI B,20*20		;allow space for 20 spare ufd entries of 20 wds each
	MOVEI A,0
	PUSHJ P,DDFWRT
	SOJG B,.-1		;loop writing extra ufd entries
	POP P,B
	POP P,A
RFDT3B:
>;IFN FTHELP
	SKIPN TAPERR-REDERR+MEDERR ;skip if any previous media errors
	SKIPE TAPERR		;skip if no errors in this file
	PUSHJ P,CKPAUS		;make sure user knows of errors
IFN UDPSW,<
	TLNE FL,UDPGO		;IS THIS THE UDP?
	JRST RFDT5		;YES. CLOSE IT.
>;IFN UDPSW
	CLOSE FILE,NUPACC
	STATZ FILE,740000
	 PUSHJ P,RFDT6		;ERROR.
	POPJ P,

IFN UDPSW,<
RFDT5:	UCLOSE FILE,
	POPJ P,
>;IFN UDPSW

RFDT6:	OUTSTR [ASCIZ/ Disk write error.   Status = /]
	PUSH P,A
	GETSTS FILE,A
	PUSHJ P,DISLOC
	OUTSTR CRLF
;	MOVEI A,FILE
;	DEVCHR A,		;see if this is a tape
;	TLNN A,DEVMTA	;skip if copying onto magtape
;	JRST RFDT6A
;RFDT6A:
	POP P,A
	POPJ P,
	
DDFWRT:	SOSG FOBUF+2
	PUSHJ P,DDFWR1
	IDPB A,FOBUF+1
	POPJ P,

DDFWR1:
IFN UDPSW,<
	TLNE FL,UDPGO		;ON THE UDP?
	JRST DDFWR3		;YES.
>;IFN UDPSW
	OUTPUT FILE,
	STATZ FILE,740000
	 PUSHJ P,RFDT6
	POPJ P,
	
IFN UDPSW,<
DDFWR3:	UOUT FILE,		;FOR THE UDP
	POPJ P,
>;IFN UDPSW

RFDT2L:	OUTSTR [ASCIZ /  File on input tape doesn't end when expected; resultant output file will
 be extended, probably with data from another file at the end.
/]				;record too long, maybe from error recovery
	AOS TOOLNG		;count an error of this type
	AOS TAPERR		;count an error of any type
	POPJ P,

;Here if found no file-continuation record although some file word count remains
;Maybe this is phony file generated during copy.
;If so, report previous media errors.
RFDT2S:	PUSHJ P,RDFLX1		;backup the input byte pointer and byte count
RFDT22:	OUTSTR [ASCIZ/  File shorter than expected; will truncate.
/]
	AOS TOOSHR		;count an error of this type
	AOS TAPERR		;count an error of any type
	POPJ P,

;Here if found file-continuation record but MT buffer is short (MT error?).
RFDB2S:	OUTSTR [ASCIZ\  Continuation\]
	JRST RFDB2B		;finish the message, count the error

CKPAUS:	SKIPN MASCOP		;milder message for master tape copy
	OUTSTR [ASCIZ/## Please note that the file named above has data errors.
/]
repeat 0,< ;no message for master copy
	SKIPE MASCOP		;milder message for master tape copy, won't pause
	OUTSTR [ASCIZ/## The file named above has data errors.
/]
>;repeat 0
	PUSHJ P,GETCON		;get user response, possible GO
	 HRROS FILERS		;typed GO, no more stops (this cnt is never zeroed)
	POPJ P,

;Routine to get user response and skip unless user says GO.
;Instruction following call should point to auto-continue flag.
;Clobbers only A.
GETCON:	AOS TAPERR		;count a tape error
	HRRZ A,@(P)		;get ptr to auto-continue flag
	AOS A,(A)		;count an error
	JUMPL A,CPOPJ1		;continue automatically, flag already set
	SKIPE MASCOP		;skip unless doing master tape copy
	JRST CPOPJ1		;master tape copy, continue automatically
GETCO1:	CLRBFI
	OUTSTR [ASCIZ/## Type <return> to continue,
## or GO<return> to continue without further pauses for errors of this type: /]
	PUSHJ P,GETGO		;see if want to continue, skip if user says GO
	 JRST GETCO1		;bad response, try again
	 POPJ P,		;take direct return for GO
	JRST CPOPJ1		;skip return for CR

;Check PPN in A and skip if each half is right aligned and contains only
;letters and digits.  Here from RFIL1 to validate the PPN in A.
PPNCHK:	TRNE A,77		;right-most char must be nonzero in programmer
	TLNN A,77		;same for project
	POPJ P,			;right hand char is zero, bad PPN
	TRNN A,7700		;middle char shouldn't be zero unless left char is
	TRNN A,770000		;skip if left char nonzero (middle char zero)
	CAIA
	POPJ P,			;bad PPN, has hole in middle of programmer
	TLNN A,7700		;middle char shouldn't be zero unless left char is
	TLNN A,770000		;skip if left char nonzero (middle char zero)
	CAIA
	POPJ P,			;bad PPN, has hole in middle of project
	;now we check PPN to make sure it has only letters, digits, and spaces
PPNCHL:	MOVEI B,0		;we'll rotate next char of PPN into B
	ROTC A,6		;get a char from PPN into B
	CAIL B,'A'
	CAILE B,'Z'		;skip if this is a letter
	SKIPN B
	JRST PPNCH2		;null or letter is fine
	CAIL B,'0'
	CAILE B,'9'		;skip if this is a digit
	POPJ P,			;not a letter, not a digit -- bad PPN
PPNCH2:	JUMPN A,PPNCHL		;digit is fine, loop unless done checking
	JRST CPOPJ1		;skip return for fine PPN
                                                                                                                                                                                                                                                                                                                                                   subttl	write tape	 ; TWRITE TWRIT0 TWRIT1 TWRIT2 YMTA1 TWREOT TWRIT4 WRLOCK

;Skips unless physical end of tape when IGNEOT is off.
TWRITE:	SOSG	TOBUF+2
	JRST	TWRIT1
TWRIT0:	IDPB	A,TOBUF+1
	AOS	(P)
	POPJ	P,

TWRIT1:	AOS	MTFILN		;COUNT THE TOTAL SIZE OF THIS FILE
	AOS	MTTREC		;COUNT THE TOTAL OF ALL RECORDS
TWRIT2:
IFN DBGSW,<
	SKIPN	DBGNTP
	JRST	YMTA1
	PUSHJ	P,NXTOBF	;IF NOT OUTPUTTING, FAKE OUTPUT
	 JRST TWRIT0
	JRST	TWREOT		;TO FAKE AN EOT (FOR TESTING W/O TAPE)
YMTA1:
>;IFN DBGSW
	PUSHJ	P,MT2OUP
	STATO	MTA2,742000	;LOOK FOR ALL ERROR BITS
	JRST TWRIT0		;no errors
	STATO	MTA2,IOTEND	;END OF TAPE?
	JRST	TWRIT4		;SOME OTHER ERROR
TWREOT:	TLNE	FL,IGNEOT	;HAVE WE TOLD HIM EOT ALREADY?
	JRST	TWRIT0		;YES. HE DOESN'T WANT TO BE BOTHERED AGAIN
	PUSHJ P,MT2CLZ		;DO THE OUTPUT CLOSE, writes EOF
	PUSHJ P,MT2CT2		;report the output EOF written, don't count it
	POPJ	P,		;EOT: LET THE GUY UPSTAIRS WORRY ABOUT IT

TWRIT4:	PUSH	P,A		;SAVE SOME STUFF
	GETSTS	MTA2,A		;GET MT STATUS
	TRNE	A,IOIMPM	;IS THIS ILLEGAL WRITE ON WRITE LOCKED TAPE?
	JRST	WRLOCK		;YES.

;I DON'T WISH TO ATTEMPT TO CORRECT THIS.
	OUTSTR [ASCIZ/Fatal: mag tape WRITE error.  MT Status = /]
	PUSHJ P,DISLOT		;TYPE DISASTER to TTY
	OUTSTR CRLF
	JRST	RESTAR

WRLOCK:	OUTSTR	[ASCIZ/ Write operation on a write-locked tape!
 Put the write ring in, reposition the tape, and retry your command.
/]
	JRST RESTAR

;	OUTSTR	[ASCIZ/Write operation on a write-locked tape!
;Put the write ring in and type carriage return.
;/]
;	INCHWL A
;	CLRBFI
;	GETSTS	MTA2,A
;	TRZ	A,700000
;	SETSTS	MTA2,(A)
;	POP	P,A
;	JRST	TWRIT2
                                                                                                                                                                                                                                                                                       subttl read tape		; TREAD TRELUZ TREADZ TREADX TREADW TREADY TREAD0 TREADU TREAD1 TREAD2 TYRSTA CLNRCK ALNRCK ALNRC2 DECRET DECRE0 DECRE3 DECRES INCRET DECRE2 POPAJ TRLEOT REOTAP REOFIL REOFI2 TAPEND MTAOPT IOBUFH MTINIR MTINIW DENCHK DENSOK NOMTA0 MTINWS MTINRS NOMTAD STFOOT DPMTA DPMTA2 BUFSET BUFSE0 BUFSE1 NMTBFS LBFHDR BU2SET BU2SE0 BU2SE2 BU2SEW MINIT1 MTERR SHRTBF DARTER DOSKIP DOSKI2 DOABOR DOABO2

;There are 4 cases for reading a word from the tape, so there are four routines.
;Each of these routines handles error recovery differently.
;A "new block" here is a data block on the tape beginning with a word-count.
;
;(1) TREAD (may return uplevel) not expecting new block, not reading file data.
;(2) TREADX  expecting new block, not reading file data.
;(3) TREADW  not expecting new block, reading file data.
;(4) TREADY  expecting new block, reading file data.

;Read a word from tape, case (1): not expecting new block, not reading file data.
;Upon error (short buffer), RETURNS UPLEVEL direct to RDFIL0.  Because of this,
;TREAD must be called only from RDFIL and not from any routines called by RDFIL
;nor with any data on the stack in RDFIL.
;Here from RDHED, RDFILX, RFIL1, IWCCOA all of which check for error
;before coming here.
TREAD:	SOSLE TIBUF+2		;decrement buffer word count, should never run out!
	JRST TREADZ		;OK, get a word from tape buffer
;Bad format: input buffer ran out of data prematurely!
;This isn't supposed to happen since our callers check for this possible error.
;So this is a bug in Dart.
	PUSHJ P,DARTER		;this is a bug!
;Begin bug trap, to make sure we can recover reasonably.
	HRRZ A,-1(P)		;get return address of our caller (already AOS'd)
	SOJLE A,TRELUZ		;make sure -1(A) is valid address
	CAMLE A,.JBREL		;make sure in range
	JRST TRELUZ		;PROGRAMMING BUG in DART!
	MOVE A,-1(A)		;get what should be the PUSHJ
	CAME A,[PUSHJ P,RDFIL]	;make sure stack is as expected for uplevel return
TRELUZ:	PUSHJ P,DARTER		;stack isn't what we expected! (caller stacked data)
;End bug trap
	SUB P,[1,,1]		;don't return to caller!
;Since we're not in the middle of reading file data, we'll just try to skip to
;the beginning of the next file and POP back up a level to RDFIL.
	JRST RDFI00		;process next file on tape

TREADZ:	ILDB A,TIBUF+1		;return with word from tape
	POPJ P,

;Read a word from tape, case (2): expecting new block, not reading file data.
;Here from RDFI00 and RDFILX.
TREADX:	SOSG TIBUF+2		;DECREMENT BUFFER COUNT
	PUSHJ P,TREAD1		;HAVE TO ASK SYSTEM (double skip on MT read error)
	 JRST TREADZ		;SUCCESS, get a word and return
	 JRST TRLEOT		;Logical EOT, back up over second EOF and report EOT
	SKIPG TIBUF+2		;did we see any data
	JRST TREADX		;nope, try again
	JRST TREADZ		;yup, return what data there is

;Read a word from tape, case (3): not expecting new block, reading file data.
;Here from RFDT0 and RFDT1.
TREADW:	SOSLE TIBUF+2		;decrement buffer word count, should never run out
	JRST TREADZ		;OK, get a word from tape buffer
;Bad format: input buffer ran out of data prematurely!
;This means the buffer data count was shorter than the Dart block word count.
;Since we ARE in the middle of reading file data, we'll try to continue by
;substituting zeroes for the missing data words, after telling the user.
	SKIPL TIBUF+2		;skip if already reported this short buffer
	PUSHJ P,SHRTBF		;report short buffer to user
	SKIPL TIBUF+2
	OUTSTR [ASCIZ/  Will replace missing data in above file with zeroes.
/]				;we'll no doubt also get a resultant checksum error
	MOVEI A,0		;return zero words until end of Dart word count IWC
	POPJ P,

;Read a word from tape, case (4): expecting new block, reading file data.
;Here only from RFDT2 and TCOPIN.
TREADY:	SOSG TIBUF+2		;time for a new tape record?
TREAD0:	PUSHJ P,TREAD1		;yes, read it
	 JRST TREADZ		;OK, get a word from tape buffer
	 JRST TREADU		;unexpected logical EOT in middle of file
	SKIPG TIBUF+2		;MT read error -- did we see any data?
	JRST TREADY		;nope, try again
	JRST TREADZ		;yup, return what data there is

;Here upon unexpected logical EOT in middle of file.
TREADU:	OUTSTR [ASCIZ/ Unexpected Logical end-of-tape in middle of input file;
 must truncate current output file named above.
/]
	AOS UNEEOT		;count an error of this type
	AOS TAPERR		;count an error of any type
;; We might want to skip past the EOT to see if the tape really goes on, at least
;; during big tape copy, since sometimes a premature EOT gets written early in
;; the tape over some good data.  But it's hard to tell when it's happened.
	JRST TRLEOT		;even for PRESTORE, we just truncate the file
;	JRST @CRESTA		;jumps to TRLEOT normally, or PRUEOT during PRESTORE

;read a magtape record, take direct return on success.
;takes skip return on Logical End of Tape.
;takes double skip return on MT Read Error, having skipped bad record, not read on.
TREAD1:	SKIPE TSKIP		;request to skip fwd? (ESC 7 I)
	PUSHJ P,DOSKIP		;yes, if confirmed, do it, before reading a record
	SKIPE TSLICE		;want to toggle slice level?
	PUSHJ P,TOGSLI		;yes, do it
	PUSHJ P,MTAINP		;read a tape record
	SKIPE TABORT		;request to abort this tape? (ESC 5 I)
	PUSHJ P,DOABOR		;yes, if confirmed, do it (POPs up a level)
TREAD2:	GETSTS MTA,A
	TRNN A,740000!IOEOF	;any real errors or EOF?
	PUSHJ P,INCRET		;no, maybe increment nbr of retries for good tape
	TRNN A,740000!IOEOF!IOTEND ;skip if error, EOF or EOT
	POPJ P,			;return quickly upon success
	TRZE A,IOTEND
	PUSHJ P,REOTAP		;report phys end of tape
	TRZE A,IOEOF		;END OF FILE?
	JRST REOFIL		;YES.
	TRNN A,740000		;any real errors?
	POPJ P,			;no (must have just been phys end of tape)
	SETOM RECERR		;flag that current record got read error
	AOS MTRERR		;count an error of this type in this file
	AOS TAPERR		;count an error of any type
	PUSH P,B
	PUSH P,C
	PUSH P,A		;save MTA status
	OUTSTR [ASCIZ/ MT read error/]
	SKIPLE NRETRY		;skip if doing no retries
	PUSHJ P,TYRSTA		;type out read error (diddles FL)
	PUSHJ P,DECRET		;do less retries, get past bad tape more quickly
	POP P,A
;	PUSHJ P,MTASKR		;SKIP PAST BAD SPOT.
;	JRST TREAD1
	TRZ A,740000
	SETSTS MTA,(A)		;clear error bits
;now we zero any unfilled portion at the end of the buffer, so reader sees zeroes.
;for some reason the system doesn't do this for us!
;our caller handles the error recovery (figuring out what data we have, etc.).
;	PUSH P,TIBUF+2		;don't let buffer count be diddled here
	PUSHJ P,ZEREND		;zero out end portion of buffer, fix buffer cnt
	 JFCL			;buffer was already full of data, nothing zeroed
;	POP P,TIBUF+2		;keep system's buffer cnt
	POP P,C
	POP P,B
	JRST CPOPJ2		;double skip on MT read error

;Type read error status and data.
TYRSTA:	OUTSTR [ASCIZ/, status = /]
	PUSH P,FL		;save flags
	PUSH P,TIBUF+1		;copy byte ptr
	TRZ FL,LSTON		;force typeout to TTY
	PUSHJ P,DISLOC		;type octal half word status
	OUTSTR [ASCIZ/  Data: /]
	ILDB A,(P)		;get 1st datum from buffer
	PUSHJ P,TYPOCH		;type octal half words
	OUTSTR [ASCIZ/; /]
	ILDB A,(P)		;get 2nd datum from buffer
	PUSHJ P,TYPOCH		;type octal half words
	OUTSTR CRLF
	SUB P,[1,,1]		;flush byte ptr
	POP P,FL		;restore flags
	POPJ P,

repeat 0,<
CLNRCK:	TRNN A,IONRCK		;skip if bit was on, will turn it off
	JRST ALNRC2		;bit was already off
ALNRCK:	TRC A,IONRCK		;alter no-re-read mode every so often
	SETSTS MTA,(A)
	TRNN A,IONRCK
	OUTSTR [ASCIZ/  Will re-read upon errors hereafter.
/]
	TRNE A,IONRCK
	OUTSTR [ASCIZ/  Won't re-read upon errors hereafter.
/]
ALNRC2:	SETZM CONERR		;start over counting error records
	POPJ P,
>;repeat 0

;Maybe reduce the number of tape read retries (just saw tape read error).
;We can clobber A,B,C (only clobbers A,B).
DECRET:	SKIPN LRETRY		;skip if we're allowed to limit retries
	POPJ P,			;don't change anything
	MOVNI A,MRETRY/MLBAD	;decrease retry count fraction a little
	ADDB A,NRETRY		;update amount
	ADDI A,MRETRY-1		;force us to round up
	IDIVI A,MRETRY		;figure out actual new number of retries
	JUMPL A,DECRE0		;see if we reached rock bottom
	ADDI A,MNRET		;include minimum number of retries
;;	JUMPN B,CPOPJ		;round up -- any remainder means no reduction
	PUSHJ P,MTARET		;set retry count for input tape from count in A.
	OUTCHR [""]		;tell operator things are getting worse
	POPJ P,

DECRE0:	CAMG A,[-REHARS]	;after this many errors, we do a skip file cmd
	JRST DECRES		;skip file now
repeat 0,<
	SKIPN SKIPFL		;if we retried hard last time, don't this time
	CAMLE A,[-REHARD]	;hit threshold of many consecutive read errors?
	POPJ P,			;no
DECRE3:	SETCMM SKIPFL		;complement the skip/retry flip-flop
	MOVEI A,REHARC		;yes, set up to do small number of retries again
	OUTCHR [""]		;sort of a sideways adjustment to retrying
	PUSH P,A		;make stack right for below
	JRST DECRE2
>;repeat 0
	POPJ P,

DECRES:	OUTSTR [ASCIZ/** Bad section of input tape, skipping to next MT file. **
/]
	;maybe we should skip a few MT files..., but for now just one
	PUSHJ P,MTASKF		;skip a file  (this doesn't affect buffers)
	PUSHJ P,MTABKR		;back up over the filemark so input will see it
	SOS MEMSAV+MTAFIL	;uncount MT file (EOF) we just backed up over
;	JRST DECRE3		;set retry count to small number
	SETZM NRETRY		;no retries until better tape
	POPJ P,

;Maybe increase the number of tape read retries (just read record w/o tape error).
;Preserves all ACs.
INCRET:	SKIPN LRETRY		;skip if we're allowed to limit retries
	POPJ P,			;don't change anything
	PUSH P,A		;preserve all ACs
	MOVE A,TIBUF+2		;get input byte count
	CAIGE A,3		;gotta be at least 3 to hold any data
	JRST POPAJ		;not really a good record, don't increment count
	SETZM SKIPFL		;disable skipping file for now
	MOVEI A,MLGOOD		;increase retry count fraction a little
	SKIPL NRETRY		;if negative, just increase from zero
	ADD A,NRETRY		;new count
	CAILE A,DRETRY		;don't go over max
	MOVEI A,DRETRY		;use only max
	CAMG A,NRETRY		;is count changing?
	JRST POPAJ		;no
	OUTCHR ["^"]		;tell operator things are improving
DECRE2:	MOVEM A,NRETRY		;store new count
	PUSH P,B
	ADDI A,MRETRY-1		;force us to round up
	IDIVI A,MRETRY		;figure out actual new number of retries
	ADDI A,MNRET		;include minimum number of retries
	POP P,B
	PUSHJ P,MTARET		;set retry count for input tape from count in A.
POPAJ:	POP P,A
	POPJ P,

TRLEOT:	PUSHJ P,MTABKF		;BACKSPACE OVER THE 2ND EOF MARK
	TRO FL,MTAEOT		;SET ENDING FLAG
	POPJ P,			;RETURN

REOTAP:	TLON FL,IGNEOT		;TELL HIM ONLY ONCE THAT EOT IS HAPPENING.
	OUTSTR [ASCIZ/Physical end of tape.
/]
	TRZ A,IOIMPM		;clear bit that comes with IOTEND
	POPJ P,

printx Might this MTACLZ also obscure a logical EOT?  (read ahead w/3 buffers?)
REOFIL:	PUSHJ P,MTACLZ		;CLOSE THE MTA
	AOS MEMSAV+MTAFIL	;count an MT file seen on input tape
	SKIPN TELEOF		;want to mention EOFs?
	JRST REOFI2		;no
	PUSH P,A
	PUSH P,B
;printx Debugging aid at REOFIL prints each input EOF number
movei a,"-"
pushj p,out.ch
move a,memsav+mtafil
pushj p,decout
	MOVEI B,[ASCIZ/-Input tape EOF-
/]
	PUSHJ P,STROUT
	TRC FL,LSTON+LSTTTY
	TRCN FL,LSTON+LSTTTY
	CLOSE LST,		;force tty output
	POP P,B
	POP P,A
REOFI2:	SETOM SAWEOF		;flag that EOF was seen, for TLIST stopping
	SETOM MTFBEG		;we're at beginning of input magtape file
	SETSTS MTA,(A)		;RESET END OF TAPE BIT
	PUSHJ P,MTAINP		;READ ANOTHER BUFFER FULL
	STATO MTA,IOEOF		;IS THIS END OF FILE?
	JRST TREAD2		;NO. LET TREAD TAKE CARE OF IT.
;Use DDT to make TREAD2 (or REOFIL) come here in order
;to fake an end of unreadable input tape.
;Used during master tape copy (maybe PRestore someday).
TAPEND:	OUTSTR [ASCIZ/Logical end of tape: /]
	PUSH P,FL		;save state of LSTON bit
	PUSH P,A
	PUSH P,B
	TRZ FL,LSTON		;force output to TTY
	MOVE A,MEMSAV+MTAPOS
	PUSHJ P,TYFOOT		;type footage
	OUTSTR CRLF
	POP P,B
	POP P,A
	POP P,FL
	JRST CPOPJ1		;RETURN

;Indirect tables used in the routines below.
MTAOPT:	MTAOPE			;open routine for MTA
	MT2OPE			;open routine for MTA2

;Buffer header pointers
IOBUFH:	TIBUF			;input hdr
	TOBUF,,0		;output hdr

;Routines to open a magtape device for read or writing.
;Call MTINIR to open MTA for reading, or MTINIW to open MTA2 for writing.
MTINIR:	MOVEI A,DRETRY		;init default retry count for tape read errors
	MOVEM A,NRETRY		;should match system's default (used if MASCOP)
	TDZA A,A		;flag preparing to Read (zero)
MTINIW:	MOVEI A,1		;flag preparing to Write (nonzero)
	MOVEM A,RWMODE		;remember 0 for MTA read, 1 for MTA2 write
	SKIPE REDOPN(A)		;reading, skip if already reading tape on some chan
	PUSHJ P,OPNERR		;bug -- already doing given operation on this chan
	MOVEI A,IMODE
	IOR A,DENMOD		;include mode bits for density desired
IFN FTCOPY,<
;;	IORI A,IONRCK		;no rereading for master copy, to speed things along
>;IFN FTCOPY
	SKIPN B,MTDEV
	MOVE B,['MTA0  ']
	MOVEM B,MTDEV
	DEVCHR B,
	TLNN B,DEVMTA		;skip if device is a magtape
	JRST MTERR
	PUSH P,D
	MOVE B,MTDEV
	MOVE D,RWMODE		;get channel index
	MOVE C,IOBUFH(D)	;get buffer hdr ptr
IFN DBGSW,<
	SKIPE DBGNTP		;SKIP IF REAL TAPE OUTPUT TO BE DONE
	JRST NOMTA0		;IF NO REAL OUTPUT, DON'T OPEN THE MTA
				;FOR NOW, NO OPEN EVEN IF WE JUST WANTED TO READ
				;LATER, MIGHT ALLOW READING ONLY HERE
>;IFN DBGSW
	PUSHJ P,@MTAOPT(D)	;open the magtape device
	 JRST NOMTAD		;failed
;	MOVEM A,LASTDN		;save mode for footage calculations
	LDB A,[POINT 2,A,28]	;just the density bits from IO mode
	SETOM REDOPN(D)		;flag which channel is open
	PUSHJ P,STFOOT		;set up footage parameters (also B_phys dev)
IFN FTSUAI,<
	MOVE D,DENMOD		;warn if non-default density, unless TU-78 reading
	CAIN B,'MTU'		;skip unless TU-78
	SKIPGE RWMODE		;skip if reading (TU-78 always uses proper density)
DENCHK:	CAIN D,DEN800		;default density? (800 same as 6250)
	JRST DENSOK
	OUTSTR [ASCIZ/Non-default /] ;warn of non-default density in use
	PUSH P,B		;save physical device
	MOVE A,MTDEV		;get device name
	PUSHJ P,DENTE0		;report actual density in use, clobs A,B,C
	POP P,B
DENSOK:	MOVEI A,BRCSIZ		;assume TU-78 and 6250 bpi--bigger records
	SKIPGE RWMODE		;skip if reading -- use large buffers even for 1600
	CAIN D,DE6250		;skip if not 6250
	CAIE B,'MTU'		;skip if this device is a TU-78
	MOVEI A,RECSIZ		;not TU-78 or not 6250, use smaller records
>;IFN FTSUAI
IFE FTSUAI,<
	MOVEI A,RECSIZ		;not WAITS, smaller records
>;IFE FTSUAI
	MOVE D,RWMODE		;get MTA/MTA2 flag
NOMTA0:	JUMPN D,MTINWS		;jump if writing
	MOVEM A,RRCSZ		;remember size of records we'll use, for reading
	MOVNM A,NRRCSZ		;remember negated size
	SUBI A,2
	MOVEM A,RRCSZ2		;remember size minus 2, too
IFN FTCOPY,<
	MOVEI A,MXRET		;set maximum retry count
	PUSHJ P,MTARET		;tell system
>;IFN FTCOPY
	JRST MTINRS

;here if writing
MTINWS:	MOVEM A,WC		;initialize word count
	MOVEM A,WRCSZ		;remember size of records we'll use for writing
	MOVNM A,NWRCSZ		;remember negated size
	SUBI A,2
	MOVEM A,WRCSZ2		;remember size minus 2, too
MTINRS:	SETZM MTFILN		;NO RECORDS ON THIS FILE YET
	PUSHJ P,BUFSET
	POP P,D
	POPJ P,

NOMTAD:	POP P,D
	JRST NOMTA		;can't init magtape

;Set up footage parameters.
STFOOT:	MOVEI C,MTDPYD		;assume 7-track drives for footage parameters
IFN FTSUAI,<			;use different record size for different densities on diff drives
	MOVE B,MTDEV		;get device name
	PNAME B,		;get physical device name to distinguish TU-78
	 JFCL			;unknown device, can't happen, we have it open!
	HLRZ B,B		;get just generic device name
	CAIN B,'MTU'		;skip unless TU-78
	MOVEI C,MUDPYD		;set up different footage parameters
>;IFN FTSUAI
	ADDI A,MTLWRD-MTDPYD(C) ;low-order mode bits give density offset in table
	MOVE A,(A)		;get magtape length of one 36-bit word of data
	MOVEM A,REDDEN(D)	;save for either input or output tape
	MOVE A,MTLIRG-MTDPYD(C)	;get magtape length of interrecord gap
	MOVEM A,REDIRG(D)	;save for either input or output tape
	MOVE A,MTLEOF-MTDPYD(C)	;get magtape length of an EOF
	MOVEM A,REDEFL(D)	;save for either input or output tape
	POPJ P,

repeat 0,<
;Skip if chan MTA is the one we're displaying the footage for.
;We display the footage for the last channel INIT'd.
DPMTA:	SKIPN RWMODE		;skip if last init was for writing
	AOS (P)			;last init was reading
	POPJ P,

;Skip if chan MTA2 is the one we're displaying the footage for.
DPMTA2:	SKIPE RWMODE		;skip if last init was for reading
	AOS (P)			;last init was writing
	POPJ P,
>;repeat 0

;Set up input or output buffer headers for a magtape device.
;D is 0 if reading, 1 if writing.
BUFSET:	SKIPN MBUFLG		;skip if particular place for buffers given
	JRST BUFSE0		;no special buffer assignment
	JUMPN D,BUFSE1		;if writing, use compiled in buffers MBUF1,2,3
	JRST BU2SET		;reading, use (smaller) buffers in additional core

BUFSE0:	SKIPE REDOPN		;if both channels are open, we use special buffers
	SKIPN WRTOPN		;otherwise we use the compiled in buffers
	CAIA			;not both channels in use
	JRST BU2SET		;set up buffers for second channel (MTA)
BUFSE1:	MOVE A,[400000,,MBUF1+1] ;use compiled-in space for buffers
	MOVEM A,@[TIBUF
		  TOBUF](D)	;set up buffer header buffer ptr
	MOVSI A,(<POINT 36,0,35>)
	MOVEM A,@[TIBUF+1
		  TOBUF+1](D)	;set up buffer header byte ptr
	SETZM @[TIBUF+2
		TOBUF+2](D)	;zero the byte count
	MOVE A,@[RRCSZ
		 WRCSZ](D)	;get record size for reading or writing
	MOVSI A,1(A)		;record size plus one in LH
	HRRI A,MBUF1+1
IFG NMTBFS-3,<
	MOVEM A,MBUF6+1
	HRRI A,MBUF6+1
	MOVEM A,MBUF5+1
	HRRI A,MBUF5+1
	MOVEM A,MBUF4+1
	HRRI A,MBUF4+1
>;IFG NMTBFS-3
IFG NMTBFS-1,<
	MOVEM A,MBUF3+1
	HRRI A,MBUF3+1
	MOVEM A,MBUF2+1
	HRRI A,MBUF2+1
>;IFG NMTBFS-1
	MOVEM A,MBUF1+1		;set up size field and ptr in each buffer
	POPJ P,

LBFHDR__3 ;number of overhead words per buffer (preceding data area).

;Set up buffers for second magtape channel, using additional core.
;MT2BUF points to beginning of buffer area set up (maybe previously set up).
BU2SET:	MOVE A,.JBFF		;place to put buffers if not already set up
	MOVE B,RRCSZ		;see how much space we need for buffers
	IMULI B,NMTBFS		;number of buffers we'll set up
	ADD B,MT2BUF		;potential end of new buffers - (NMTBFS*LBFHDR)
	CAIL A,NMTBFS*LBFHDR(B) ;ignore old buf area if .JBFF isn't after its end
	SKIPN B,MT2BUF		;skip if buffer area already allocated
	JRST BU2SE0		;need to allocate buffer area starting at .JBFF
	MOVEM B,.JBFF		;force buffers to be set up in same old place
	PUSHJ P,BU2SE2		;set up the buffers
	MOVEM A,.JBFF		;restore free pointer
	POPJ P,

;here if we're NOT going to reuse some old buffer space -- expand core instead.
BU2SE0:	MOVEM A,MT2BUF		;remember where buffers will start
;make the system set up buffers for second magtape (must preserve A).
BU2SE2:	MOVEI B,NMTBFS		;number of buffers we want
	MOVEI C,1		;buffer size for uuo includes extra word
	JUMPN D,BU2SEW		;jump if writing
	ADD C,RRCSZ		;record size for reading
	UINBF MTA,B		;set up buffer ring
	POPJ P,

BU2SEW:	ADD C,WRCSZ		;record size for writing
	UOUTBF MTA2,B		;set up buffer ring
	OUTPUT MTA2,		;set up buffer header
	AOS TOBUF+2		;correct output count, since no word output now
	POPJ P,

;Init magtape for reading with one buffer (for precise tape positioning).
MINIT1:	PUSHJ P,MTINIR		;init magtape for reading
	HRRZ A,TIBUF		;get pointer to first buffer in ring
	HRRM A,(A)		;store in the first buffer, to make one-buffer ring
	POPJ P,

MTERR:	OUTSTR [ASCIZ/Device /]
	MOVE A,MTDEV
	PUSHJ P,SIXOUT
	OUTSTR [ASCIZ/ is not a magtape.
/]
	JRST RESTAR

SHRTBF:	OUTSTR [ASCIZ/  Input tape error: record shorter than expected.
/]
	AOS SHRTGO		;count an error of this type
	AOS TAPERR		;count an error of any type
	POPJ P,

DARTER:	OUTSTR [ASCIZ/
%%% Fatal DART bug! -- called from: /]
	HRRZ A,(P)		;get return address
	PUSHJ P,DISLOT		;print it on TTY
	OUTSTR [ASCIZ/, /]
	HRRZ A,-1(P)		;get higher return address
	PUSHJ P,DISLOT		;print it on TTY
	OUTSTR [ASCIZ/ -- Please tell a wizard!
/]
	HALT .
	POPJ P,			;maybe a wizard will decide to go on

;Operator said ESC 7 I to request skipping some bad portion of input tape.
;Confirm it and do it.
;Reply of GO increments the skip count and then skips that many files.
;Reply of XX resets skip count to zero and doesn't skip anything.
;Reply of plain <return> just keeps reading, without skipping or changing skip cnt.
DOSKIP:	SETZM TSKIP		;don't come back immediately, must request again
;	SKIPN MASCOP		;in master tape copy?
;	POPJ P,			;don't do any tape skip fwd
	OUTSTR [ASCIZ/
%% Tape SKIP FORWARD requested by operator for supposedly unreadable tape spot.
%% Type GO<return> to skip forward past /]
	PUSH P,FL
	TRZ FL,LSTON		;force typeout to TTY
	MOVE A,TSKIPN		;get skip count
	ADDI A,1		;it will be incremented if confirmed
	PUSHJ P,DECOUT		;tell how many we would do
	POP P,FL
	OUTSTR [ASCIZ/ tape files. /]
	PUSHJ P,GETGO		;get answer (clobs only A)
	 SETOM TSKIPN		;unrecognized response, reset skip count
	 AOSG A,TSKIPN		;skip fwd requested, add one to skip count
	POPJ P,			;just <return> typed, keep reading
DOSKI2:	PUSHJ P,MTASKF		;skip forward an MT file
	SOJG A,DOSKI2		;skip as many as we're supposed to
	POPJ P,

;Operator said ESC 5 I to request aborting input tape.  Confirm it and do it.
;Maybe here 2 or 3 times for same aborting.
DOABOR:
;	SKIPN MASCOP		;in master tape copy?
;	POPJ P,			;don't abort
	OUTSTR [ASCIZ/
%% Tape ABORT requested by operator for supposedly unreadable tape.
%% Type GO<return> to pretend we've reached the end of the tape. /]
	PUSHJ P,GETGO		;get answer (clobs only A)
	 CAIA			;unrecognized response, keep reading tape
	 JRST DOABO2		;abort requested, pretend end of tape
	SETZM TABORT		;just <return> typed, keep reading, avoid re-asking
	POPJ P,

DOABO2:	SUB P,[1,,1]		;don't return to TREAD1
	JRST TAPEND		;simulate logical end of input tape, skip ret from TREAD1
                                                                                                                                                                                                                                                                                                                                                subttl low level mta i/o routines ; MTAOPE MT2OPE MTACLZ MT2CLZ MT2CL2 MT2CTS YMTA2 NOMTA2 mt2not MT2CT2 TWRERR MTAINP MTAIN0 MTAIN2 MTAIN3 MT2OUP MTABOT MTANOP MT2NOP MTAREL MT2REL MTAREW MTARE2 MT2REW MT2RE2 MT2FOO MTAUNL MT2UNL MTASKR MTASKF MT2SKF MTABKR MTABKF MTASKT MTARET MOUTUP MOUTU2 MGOTWC MEOFUP MWRDUP SEVTRK

;open input tape device
MTAOPE:	OPEN MTA,A
	 JRST CPOPJ
	JRST CPOPJ1

;open output tape device
MT2OPE:	OPEN MTA2,A
	 JRST CPOPJ
	JRST CPOPJ1

;close input tape
MTACLZ:	CLOSE MTA,
	POPJ P,

;close output tape
;After calling this routine, you should call either MT2CTS or MT2CT2 below.
MT2CLZ:	SKIPGE TOBUF		;SKIP IF OUTPUT BUFFER HASn't BEEN USED
	 JRST MT2CL2		;OUTPUT BUFFER NOT USED, ASSUME no tape movement
	PUSHJ P,MOUTUP		;UPDATE POSITION COUNT FOR ANY OUTPUT IN BUF
	PUSH P,A
	PUSH P,B
	MOVEI B,1		;indicate updating output tape position
	PUSHJ P,MEOFUP		;UPDATE POSITION FOR EOF MARK
	POP P,B
	POP P,A
MT2CL2:
IFN DBGSW,<
	SKIPE DBGNTP
	JRST NXTOBF		;FAKE CLOSE IF NO TAPE, just advance buffer
>;IFN DBGSW
	CLOSE MTA2,		;close output tape (copy)
	POPJ P,

;Here to test for physical end of tape after close output (MT2CLZ) is done.
;Takes direct return on physical EOT.
;SKIPS unless physical EOT.
;Keeps some position and file count information and also reports EOFs attempted.
MT2CTS:
IFN DBGSW,<
	SKIPN DBGNTP
	JRST YMTA2
	SKIPA			;patch here to fake an eot (maybe with a test)
	JRST MT2CT2		;fake an eot (for testing w/o tape)
	JRST NOMTA2		;NO TAPE OPERATIONS IF NOT USING TAPE
YMTA2:
>;IFN DBGSW
	GETSTS MTA2,A		;get status to test for errors
	TRNE A,IOTEND		;SEE THAT THE MTA IS HAPPY.
	 JRST MT2CT2		;presumably end of tape, take direct return
	TRNE A,740000		;SEE THAT THE MTA IS HAPPY.
	JRST TWRERR		;tape output error, fatal!
NOMTA2:	MOVE A,MEMSAV+MT2POS	;remember output tape position after EOF
	MOVEM A,MEMSAV+MTFPOS	;this is potential place for tape trlr or pickup
	AOS MEMSAV+MT2FIL	;count an MT file written out successfully
;printx Debugging aid at MT2CTS prints each output EOF number
skipn teleof
jrst mt2not	;don't tell about EOFs
movei a,"-"
pushj p,out.ch
move a,memsav+mt2fil
push p,b
pushj p,decout
pop p,b
mt2not:
	AOS (P)			;skip for success
MT2CT2:	SKIPE TELEOF		;want to report EOFs on terminal?
	OUTSTR [ASCIZ/-Output tape EOF-
/]
	POPJ P,

;Here upon tape output error other than physical end-of-tape.
;Probably a pickup can be done, assuming the tape error isn't permanent.
TWRERR:	OUTSTR [ASCIZ/%%% Tape output error!  Can't recover.  Find a wizard.
/]
	HALT .

;read record from input tape
MTAINP:	INPUT MTA,
	AOS NREADS		;count a record read
	SETZM RECERR		;assume no read error in this record
;; Save first words of data read if this is first record of magtape file.
	PUSH P,A
	PUSH P,B
	AOSE MTFBEG		;was this first record of magtape file?
	JRST MTAIN0		;no
	MOVE A,TIBUF+1		;get byte ptr
	IBP A			;make it point at first byte
	HRLZ A,A		;that's start of BLT source
	HRRI A,MTFDAT		;BLT dest is special block for magtape file
	BLT A,MTFDAT+LMTFDA-1	;for tape copy, remember disk file starting tape file
	MOVE A,MEMSAV+MTAPOS	;get input tape position before this record
	MOVEM A,MEMSAV+MTEPOS	;and remember it as position after latest input EOF
;; Now update the tape position for amount of space this record takes on tape.
MTAIN0:	GETSTS MTA,A
	SETZM LSISIZ		;assume no EOF here
	TRNN A,IOEOF		;END OF FILE?
	JRST MTAIN2		;no
	MOVEI B,0		;indicate updating input tape position
	PUSHJ P,MEOFUP		;YES, UPDATE POSITION FOR EOF MARK
	MOVEM A,LSISIZ		;remember size of last record read (for DPYSER)
	SKIPG TIBUF+2		;WAS ANY DATA READ THIS TIME?
	JRST MTAIN3		;NO, DON'T COUNT AS EMPTY RECORD TOO
MTAIN2:	MOVEI A,44		;PICK UP WORD SIZE (=36 BITS)
	LDB B,[POINT 6,TIBUF+1,11] ;PICK UP BYTE SIZE
	IDIVM A,B		;GET BYTES PER WORD IN B
	MOVE A,TIBUF+2		;PICK UP BYTE COUNT
	IDIV A,B		;GET NUMBER OF WORDS IN A
	JUMPE B,.+2		;TEST REMAINDER
	AOJ A,			;NUMBER OF WORDS = CEILING(BYTES/BPW)
	MOVEI B,0		;indicate updating input tape position
	PUSHJ P,MWRDUP		;UPDATE POSITION FOR NUMBER OF WORDS
	ADDM A,LSISIZ		;remember size of last record read (for DPYSER)
IFE FTCOPY,<
	SKIPN LRETRY		;print input record size if limiting retries
	JRST MTAIN3
>;IFE FTCOPY
	MOVE A,TIBUF+2		;word count
	CAIE A,BRCSIZ		;standard new word count?
	CAIN A,RECSIZ		;or standard old word count?
	JRST [	OUTCHR [""]	;yes, print one char to indicate record read
		JRST MTAIN3]	; with standard word count
	MOVEI A," "
	PUSHJ P,OUT.CH
	MOVE A,TIBUF+2
	PUSHJ P,TYPOCT		;type octal word count during master tape copy
	MOVEI A," "
	PUSHJ P,OUT.CH
MTAIN3:	POP P,B
	POP P,A
	POPJ P,

;write record on output tape
MT2OUP:	PUSHJ P,MOUTUP		;UPDATE POSITION COUNT FOR ANY OUTPUT IN BUF
	OUTPUT MTA2,
	POPJ P,

;skip if input tape at load point (beg of tape)
MTABOT:	MTNOOP MTA,
	STATZ MTA,IOBOT		;AT BEGINNING OF TAPE ?
	 AOS (P)		;skip for load point
	POPJ P,

;input tape no-op
MTANOP:	PUSHJ P,MTABOT		;skip if at load point (does no-op)
	 POPJ P,		;not at load point
	JRST MTARE2		;set position to zero and not questionable, etc.

;output tape no-op
MT2NOP:	MTNOOP MTA2,
	STATO MTA2,IOBOT	;AT BEGINNING OF TAPE ?
	 POPJ P,		;NO, RETURN
	JRST MT2RE2		;set output tape position to zero

;release input tape
MTAREL:	RELEAS MTA,
	SETZM REDOPN
	POPJ P,

;release output tape
MT2REL:	RELEAS MTA2,
	SETZM WRTOPN
	POPJ P,

;rewind input tape
MTAREW:	REWIND MTA,
MTARE2:	SETOM MTFBEG		;we're at beginning of input magtape file
	SETZM TABORT		;no tape abort requested now
	SETZM TSKIP		;no tape skip fwd requested now
	SETZM MEMSAV+MTAPOS	;SET POSITION TO ZERO FEET INTO TAPE
	SETZM MEMSAV+MTQPOS	;SET POSITION NOT QUESTIONABLE
	SETZM MEMSAV+MTAFIL	;no MT files seen on input tape
	SETZM MEMSAV+MTAIRG	;no records read from tape yet
	POPJ P,

;rewind output tape
MT2REW:	REWIND MTA2,
MT2RE2:	SETZM MEMSAV+MT2POS	;set position to zero feet into tape
	SETZM MEMSAV+MT2FIL	;no MT files seen on output tape
	POPJ P,

;reset output footage test counts
MT2FOO:	SETZM MEMSAV+MT2EOF	;no EOFs written yet
	SETZM MEMSAV+MT2IRG	;no data records written yet
	SETZM MEMSAV+MT2WRD	;no data words written yet
	POPJ P,

;unload input tape
MTAUNL:	UNLOAD MTA,		;rewind and unload tape
	JRST MTARE2		;set position to zero and not questionable, etc.

;unload output tape
MT2UNL:	UNLOAD MTA2,		;rewind and unload tape
	JRST MT2RE2		;set position to zero feet into tape

;skip forward record on input tape
MTASKR:	SKIPR MTA,
	SETZM MTFBEG		;not necessarily at beginning of input magtape file
	SETOM MEMSAV+MTQPOS	;SET POSITION QUESTIONABLE
	POPJ P,

;skip forward file on input tape
MTASKF:	SKIPF MTA,
	SETOM MTFBEG		;we're at beginning of input magtape file
	SETOM MEMSAV+MTQPOS	;SET POSITION QUESTIONABLE
	AOS MEMSAV+MTAFIL	;count an MT file seen on input tape
	POPJ P,

;skip forward file on output tape
MT2SKF:	SKIPF MTA2,
	AOS MEMSAV+MT2FIL	;count an MT file seen on output tape
	POPJ P,

;backup a record on input tape
MTABKR:	BACKR MTA,
	SETZM MTFBEG		;not necessarily at beginning of input magtape file
	SETOM MEMSAV+MTQPOS	;SET POSITION QUESTIONABLE
	POPJ P,

;backup a file on input tape
MTABKF:	BACKF MTA,
	SETZM MTFBEG		;not necessarily at beginning of input magtape file
	SETOM MEMSAV+MTQPOS	;SET POSITION QUESTIONABLE
	SOSGE MEMSAV+MTAFIL	;uncount an MT file seen on input tape
	SETZM MEMSAV+MTAFIL	;don't let file count go negative
	POPJ P,

;skip to logical end of tape on input tape
MTASKT:	SKIPT MTA,
	SETZM MTFBEG		;not necessarily at beginning of input magtape file
	PUSH P,[=3600*MXFOOT]
	POP P,MEMSAV+MTAPOS	;set input tape position to 3600 feet
	SETOM MEMSAV+MTQPOS	;boy, is that ever questionable
	POPJ P,

;set retry count for input tape from count in A.
MTARET:	ANDI A,17		;limit retry count to system limit
	MTAPE MTA,200(A)
	POPJ P,


; LOCAL SUBROUTINES

;Update tape position for record written on output tape.
MOUTUP:	SKIPGE TOBUF		;SKIP IF OUTPUT BUFFER HAS BEEN USED
	POPJ P,
	PUSH P,A
	PUSH P,B
	MOVE A,TOBUF
	HRRZ A,1(A)		;PICK UP WORD COUNT
IFN DBGSW,<
	SKIPE DBGNTP
	JRST MOUTU2		;NO ACTUAL TAPE
>;IFN DBGSW
	STATZ MTA2,IOWC		;SKIP IF NOT USING WORD CNT
	 JRST MGOTWC
MOUTU2:	HRRZ A,TOBUF+1		;BYTE POINTER WORD ADDR
	HLRZ B,TOBUF+1		;BYTE POINTER POSITION AND SIZE
	TRZ B,007777		;ZERO ALL BUT POSITION
	CAIN B,440000		;IS NEXT BYTE (TO IDBP) FIRST IN WORD?
	SOJ A,			;YES, BACK UP WORD ADDR
	SUB A,TOBUF		;MINUS BUFFER POINTER (BUFFER-2)
	SOJ A,			;MINUS ONE = WORD COUNT (IN RIGHT HALF)
	HRRZ A,A
MGOTWC:
;next 3 lines for debugging magtape hardware problems only
	movem a,lstwdc#		;remember word count of last output
	move b,tobuf+1
	movem b,lstbpt#		;remember byte pointer of last output
	MOVEI B,1		;indicate updating output tape position
	PUSHJ P,MWRDUP		;UPDATE POSITION FOR NUMBER OF WORDS
	POP P,B
	POP P,A
	POPJ P,

;Update tape position for EOF read or written.
;Here with B/0 if reading, B/1 if writing.
MEOFUP:	MOVE A,REDEFL(B)	;PICK UP EOF MARK LENGTH
	ADD A,REDIRG(B)		;PLUS ONE IRG LENGTH
	ADDM A,MEMSAV+MTAPOS(B)	;ADD IT INTO POSITION
	AOS MEMSAV+MTAEOF(B)	;count an EOF read or written
	POPJ P,

;Update tape position for record read or written.
;Here with B/0 if reading, B/1 if writing; A/words of data in record.
MWRDUP:	ADDM A,MEMSAV+MTAWRD(B)	;save words read or written
	AOS MEMSAV+MTAIRG(B)	;count an interrecord gap
	IMUL A,REDDEN(B)	;multiply words by tape length per word
IFN IRCPPN,<
	PUSH P,B
	MOVE B,[2,,[	1010
			MTA]]
	TAPOP. B,
	 MOVEI B,0		;DEFAULT TO 9-TRACK IF NO TAPOP
	JUMPN B,SEVTRK		;NONZERO FOR 7-TRACK
	IMULI A,3
	IDIVI A,4
SEVTRK:	POP P,B
>;IFN IRCPPN
	ADD A,REDIRG(B)		;include interrecord gap length
	ADDM A,MEMSAV+MTAPOS(B)	;add to position for input or output tape
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            subttl disk i/o for data files	; DFREAD DFRED1 DFRED2 DFREDQ DFREDX DFRED3 DFRED4 DFWRTX DFWRIT DFWRT1

DFREAD:	SOSG FIBUF+2		;READ DATA FILE
	PUSHJ P,DFRED1
	ILDB A,FIBUF+1
	POPJ P,

DFRED1:	IN FILE,
	 POPJ P,
	STATZ FILE,IOEOF
	 JRST DFREDQ		;be sure to return zero on EOF, for ...
repeat 0,<
IFN STANSW,<
	 POPJ P,
>;IFN STANSW
IFE STANSW,<
	 JRST DFREDQ		;[IRCAM] SEE COMMENT BELOW
>;IFE STANSW
>;repeat 0
DFRED2:	OUTSTR [ASCIZ/ Disk input error.
/]
	GETSTS FILE,A
	SETSTS FILE,IOEOF(A)
	POPJ P,

;; [IRCAM] The Stanford version of this code seems to return whatever happens
;; to be in the buffer even if it gets an end of file indication.  I assume
;; this must have something to do with the setting of IODEND on the reading
;; of a partial record at SAIL, whereas DEC doesn't set it until the first
;; non-record is read.  In any case, for the DEC case it means you get crud
;; returned instead of the 0 Ralph seems to expect; maybe SAIL zeros the
;; buffer and DEC doesn't?  Someone who understands this better than I can
;; look into it.  Meanwhile, I hereby invent a kludge to make sure we return
;; a zero uplevel on EOF:

DFREDQ:	POP P,(P)		;FLUSH RETURN ADDR OF CALL TO DFRED1 (from DFRED)
	MOVEI A,0		;return a 0 -- INDGT1 depends on it!
	POPJ P,			; TO CALLER OF DFREAD

;; By the way, this caused halts at LOCPP4+5 with an empty DART.ARC sometimes.--BH
;; Above is true for WAITS too; same bug, with halts at LOCPP4+5 on empty DART.ARC.
;; So Stanford now has the same fix to return zero on EOF. -- ME

DFREDX:
IFN UDPSW,<
	TLNE FL,UDPGO
	JRST DFRED4
>;IFN UDPSW
	IN FILE,		;CALLED ONLY FROM DUMP!!!
	POPJ P,
	STATO FILE,IOEOF
	PUSHJ P,DFRED2		;CALL ERROR ROUTINE AND RETURN.
DFRED3:	MOVEI A,200
	MOVEM A,FIBUF+2
	MOVE A,FIBUF
	ADD A,[POINT 36,1,35]	;
	MOVEM A,FIBUF+1		;SAVE STUFF.
	POPJ P,

IFN UDPSW,<
DFRED4:	UIN FILE,
	POPJ P,			;WIN
	JRST DFRED3		;END OF FILE.
>;IFN UDPSW

DFWRTX:	AOS DATWC		;(CALLED FROM MERGE. COUNT WORDS)
DFWRIT:	SOSG FOBUF+2		;WRITE DATA FILE
	PUSHJ P,DFWRT1
	IDPB A,FOBUF+1
	POPJ P,

DFWRT1:	OUT FILE,
	POPJ P,
	PUSH P,A
	GETSTS FILE,A
	OUTSTR [ASCIZ/ Disk write error. DSK status = /]
	PUSHJ P,DISLOC
	OUTSTR CRLF
	POP P,A
	JRST RESTAR
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       subttl	disk i/o  - indirect read - directory read - listing write	 ; RINDIR RIND1 RIND2 RIND3 RIND4 LSTSTR LSTST1 LSTOUT LSTOT1 UFDRD UFDRD1 UUFDRD UUFDR1 UUFDR2 INDOUT INDOU1

RINDIR:	SOSLE	INDRBF+2
	JRST	RIND1
	TRNE	FL,INDEOF		;BUFFER EXHAUSTED. HAS EOF BEEN SEEN?
	JRST	RIND4			;EOF SEEN BEFORE
	IN	INDIR,			;READ
	 JRST	RIND1			;WIN
	STATZ	INDIR,IOEOF		;WAS THIS EOF?
	 JRST	RIND3			;YES. SET FLAG AND RETURN A DELIMITER
	GETSTS	INDIR,A
	OUTSTR	[ASCIZ/ Device error while reading indirect command file. Status = /]
	PUSHJ	P,DISLOC
	OUTSTR	CRLF
	JRST	RESTAR	

RIND1:	ILDB	A,INDRBF+1
	MOVE	A,@INDRBF+1
	TRNE	A,1			;IS THERE AN SOS LINE NUMBER?
	JRST	RIND2			;YES. FLUSH IT.
	LDB	A,INDRBF+1		;LOAD DATA AGAIN.
	JUMPE	A,RINDIR
	POPJ	P,

RIND2:	AOS	INDRBF+1		;ADVANCE THE BYTE POINTER
	MOVNI	A,5
	ADDM	A,INDRBF+2
	JRST	RINDIR

RIND3:	TRO	FL,INDEOF
RIND4:	MOVEI	A,12
	POPJ	P,


LSTSTR:	HRLI	B,440700		;PICKUP A BYTE POINTER
LSTST1:	ILDB	A,B
	JUMPE	A,CPOPJ
	PUSH	P,[LSTST1]		;FORCE RETURN TO LSTST1
LSTOUT:	SOSG	LSTBUF+2		;OUTPUT A CHARACTER TO LISTING DEVICE
	OUT	LST,
	 JRST	LSTOT1
	CLOSE	LST,			;ATTEMPT TO CLOSE LISTING DEVICE
	JRST	LSTERR

LSTOT1:	IDPB	A,LSTBUF+1
	SKIPE MASCOP		;doing master tape copy?
	SKIPN MCLOPN		;yes, is log file open
	POPJ P,			;no, forget it
	PUSH P,A
	PUSHJ P,MCLCHL		;log this character
	POP P,A
	POPJ P,

UFDRD:	SOSG	UFDBUF+2		;READ FROM UFD.
	IN	UFD,
	 JRST	UFDRD1
	STATO	UFD,IOEOF		;EOF?
	 JRST	UFDRER			;NO. READ ERROR.
	POPJ	P,

UFDRD1:	ILDB	A,UFDBUF+1
	JRST	CPOPJ1

IFN UDPSW,<
UUFDRD:	SOSG	UFDBUF+2		;HERE TO READ DIRECTORY OF UDP.
	JRST	UUFDR2			;HAVE TO ASK OUR UDP SERVICE
UUFDR1:	ILDB	A,UFDBUF+1
	JRST	CPOPJ1

UUFDR2:	UIN	UFD,
	 JRST	UUFDR1
	POPJ	P,			;END OF FILE.
>;IFN UDPSW

;OUTPUT ON INDIR CHANNEL (REALLY USED IN ARCHIVE ROUTINE)
INDOUT:	SOSG	INDRBF+2
	OUT	INDIR,
	 JRST	INDOU1
	JRST	INDERR

INDOU1:	IDPB	A,INDRBF+1
	POPJ	P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           subttl	check after a lookup - parms in filblk	 ; LCHECK LCTYPE LCTAB LCBUSY LCNAME LCNOLK LCNOOP LCBRET LCUNA LCILPR LCNFL0 LCNFL1 LCEXIS LCEXI0 LCNOFL LCILUS LCILU1 LCILU2 LCILU3 GETGO GETGO0 GETGO1 YORN GETWRD GETWR1 GETWR2 GETWR5 GETWR3

LCHECK:	HRRZ	B,B			;LOOKUP CODE.
	CAIE	B,-1			;IS CODE SPECIAL?
	CAIGE	B,LCTBM			;IS CODE IN BOUNDS?
	JRST	@LCTAB(B)		;YES.
	OUTSTR	[ASCIZ/ Unrecognizable LOOKUP status code = /]
	MOVE	A,B
	PUSHJ	P,TYPOCT
	OUTSTR	[ASCIZ/
 Safety LOOKUP of /]
	JRST	LCTYPE

LCTYPE:	MOVE	D,[FILBLK,,A]
	BLT	D,D
	PUSHJ	P,TYFIL
	OUTSTR	CRLF
	POPJ	P,

	LCEXIS				;FILE ALREADY EXISTS
LCTAB:	LCNOFL				;FILE NOT FOUND IN UFD
	LCILUS				;ILLEGAL USER NAME - NO UFD
	LCILPR				;PROTECTION VIOLATION
	LCBUSY				;FILE IS BUSY NOW.
	LCNAME				;RENAME TO THE SAME NAME.
	LCNOLK				;NO LOOKUP BEFORE RENAME
IFN STANSW,<			;SAIL AND DEC ERROR CODES A BIT DIFFERENT
	LCNOOP				;NO OPEN HAS BEEN DONE YET
	LCNOOP				;ERROR CODE 7 DOESN'T HAPPEN
	LCBRET				;BAD RETRIEVAL - UFD GARBAGED.
>;IFN STANSW
	LCUNA				;UNACESSABLE - BAD RETRIEVAL.
SDEF LCTBM,.-LCTAB

LCBUSY:	OUTSTR	[ASCIZ/File is being referenced. LOOKUP of /]
	JRST	LCTYPE

LCNAME:
LCNOLK:
LCNOOP:	OUTSTR	[ASCIZ/Illegal file status. LOOKUP of /]
	JRST	LCTYPE

LCBRET:
LCUNA:	OUTSTR	[ASCIZ/Bad retrieval. LOOKUP of /]
	JRST	LCTYPE

LCILPR:	TRNE	FL,SAFETY
	OUTSTR	[ASCIZ/Safety /]
	OUTSTR	[ASCIZ/LOOKUP protection violation.  /]
	TRNN	FL,SAFETY
	JRST	LCTYPE			;REAL LOOKUP. TYPE NAME AND RETURN
LCNFL0:	PUSHJ	P,LCTYPE		;TELL NAME
LCNFL1:	OUTSTR	[ASCIZ/Type Y to ignore: /]
	JRST	YORN

LCEXIS:	SKIPN	LCWRNF			;warning.
	TRNN	FL,SAFETY
	JRST	CPOPJ1			;RETURN IF THE FILE EXISTS
	OUTSTR	[ASCIZ/File already exists: /]
	MOVEI A,FILE
	PNAME A,		;get name of device the file is on
	 MOVSI A,'???'		;don't know??
	CAMN A,['DSK   ']	;standard device?
	JRST LCEXI0
	PUSHJ P,SIXOUT		;type device name
	OUTCHR [":"]
LCEXI0:	PUSHJ	P,LCTYPE
	OUTSTR	[ASCIZ/Type Y to replace, or
Type GO to replace and to proceed without future warnings: /]
	CLRBFI
	PUSHJ	P,GETWRD
	CAME	A,['Y     ']
	CAMN	A,['YES   ']
	JRST	CPOPJ1
	CAME	A,['GO    ']
	POPJ	P,
	SETOM	LCWRNF
	JRST	CPOPJ1

LCNOFL:	TRNE	FL,SAFETY
	JRST	CPOPJ1			;FILE IS NOT THERE. SWELL.
	OUTSTR	[ASCIZ/File not found: /]
	JRST	LCTYPE			;TYPE NAME AND RETURN

LCILUS:	OUTSTR	[ASCIZ/UFD not found for user /]
	MOVE	A,FILBLK+3
	PUSHJ	P,PPNOUT
	OUTSTR	CRLF
	TRNN	FL,SAFETY
	POPJ	P,			;CAN'T WIN THIS WAY.
IFN FTHELP,<
	OUTSTR [ASCIZ/Creating UFD for above user.
/]
	MOVE A,FILBLK+3
	PUSHJ P,CTYPPN		;type PPN on CTY, with CRLF
>;IFN FTHELP
IFE FTHELP,<
	OUTSTR	[ASCIZ/Type Y (and return) to create a UFD, or
type return after you've created the UFD.  /]
	PUSHJ	P,YORN
	JRST	LCILU2			;LOOKUP THE UFD.
>;IFE FTHELP
	MOVE	A,FILBLK+3
	MOVSI	B,'UFD'
IFN STANSW,<
	MOVSI	C,005000		;READ ONLY ACCESS FROM THE NETWORK
	MOVE	D,GOD
	ENTER	FILE,A
>;IFN STANSW
IFE STANSW,<
	MOVEM A,UFDEBK+.RBNAM
	MOVEM B,UFDEBK+.RBEXT
	MOVE C,[13,,16]
	GETTAB C,			;SYSTEM DEFAULT UFD PROTECTION
	 MOVSI C,777000			;THIS IS THE IRCAM DEFAULT
	MOVEM C,UFDEBK+.RBPRV
	MOVE D,LOGPPN
	MOVEM D,UFDEBK+.RBAUT
	ENTER FILE,UFDEBK
>;IFE STANSW
	JRST	LCILU1
IFE STANSW,<
	USETO FILE,2			;LOGIN DOES THIS SO IT MUST BE RIGHT
>;IFE STANSW
	CLOSE	FILE,
	JRST	CPOPJ1

LCILU1:	CLOSE	FILE,
	OUTSTR	[ASCIZ/ENTER to create a new UFD lost.
Type Y to skip this file, else, type return after you've made a new UFD: /]
	PUSHJ	P,YORN
	JRST	.+2
	POPJ	P,
LCILU2:	MOVE	A,FILBLK+3
	MOVSI	B,'UFD'
	MOVEI	C,0
	MOVE	D,GOD
	LOOKUP	FILE,A
	JRST	LCILU3
	CLOSE	FILE,
	JRST	CPOPJ1

LCILU3:	OUTSTR	[ASCIZ/UFD still doesn't exist. This file will be skipped.
/]
	CLOSE	FILE,
	POPJ	P,


;Get a response from the user.
;	PUSHJ	P,GETGO
;	 <error - didn't understand what user said >
;	 <User typed the word "GO" and CRLF>
;	<User typed CRLF>
;Clobbers only A.

GETGO:	INCHWL	A
	CAIE	A," "
	CAIN	A,15
	JRST	GETGO
	CAIN	A,12
	JRST	CPOPJ2		;satisfactory, but not "GO"
	CAIE	A,"G"
	CAIN	A,"g"
	JRST	GETGO1
GETGO0:	PUSHJ	P,FLUSH
	POPJ	P,		;unsatisfactory

GETGO1:	INCHWL	A
	CAIE	A,"O"
	CAIN	A,"o"
	AOSA	(P)		;one skip for "GO"
	JRST	GETGO0
	PUSHJ	P,FLUSH
	POPJ	P,


;Get a Yes or No answer from user.  Skips on Yes.
YORN:	CLRBFI
	INCHWL	A
	PUSH	P,A
	PUSHJ	P,FLUSH
	POP	P,A
	CAIE	A,"Y"
	CAIN	A,"Y"+40
	AOS	(P)
	POPJ	P,

;get one Sixbit item from TTY into A
GETWRD:	SETZM	TTYWRD
	PUSH	P,B
	MOVE	B,[POINT 6,TTYWRD]
GETWR1:	INCHWL	A
	CAIN	A," "
	JUMPL	B,GETWR1	;ignore leading, not trailing, blanks
	CAIN	A,15
	JRST	GETWR1		;ignore characters
	CAIL	A,"0"
	CAILE	A,"9"
	SKIPA
	JRST	GETWR2		;digits ok
	CAIL	A,"a"
	CAILE	A,"z"
	SKIPA
	TRZ	A,40		;make uppercase
	CAIL	A,"A"
	CAILE	A,"Z"
	JRST	GETWR3		;not a letter, not a digit.  Stop here
GETWR2:	SUBI	A," "
	TLNE	B,770000	;avoid overflow
	IDPB	A,B
	JRST	GETWR1		;loop

GETWR5:	INCHWL	A
GETWR3:	CAIE	A,12
	CAIN	A,175
	SKIPA
	JRST	GETWR5
	POP	P,B
	MOVE	A,TTYWRD
	POPJ	P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          subttl	some type out routines	 ; DECOUT TYPOCH TYPOCT TYPOC1 OUT.CH STROUT DISLOT DISLOC OCTCOM OCTOUT SIXOUT SIXOT1 SIXFIL SIXFL0 SIXFL1 OUTFIL TYFIL TYFIL1 PPN0 PPN6 PPN61 PPNOUT PPN8 PPN1 PPN2 PPN3 CTYPPN CTYPP2 CTYOUT CTYMES TYTIME TYFDAT TYDATE TYWHEN TYWHE0 TYWHE2 TYTMDT

;Type A in decimal, clobbers B.
DECOUT:	IDIVI	A,12
	HRLM	B,(P)
	JUMPE	A,.+2
	PUSHJ	P,DECOUT
	JRST	TYPOC1

;Type octal in half-words from A, clobbers B.
TYPOCH:	PUSH P,A		;save RH
	HLRZ A,A
	PUSHJ P,TYPOCT		;type LH
	MOVEI B,[ASCIZ/,,/]
	PUSHJ P,STROUT
	POP P,A
	MOVEI A,(A)		;just RH now
	   ;fall into TYPOCT for RH
TYPOCT:	IDIVI	A,10
	HRLM	B,(P)
	JUMPE	A,.+2
	PUSHJ	P,TYPOCT
TYPOC1:	HLRZ	A,(P)
	ADDI	A,"0"
OUT.CH:	SKIPE	REAPLS		;Output to reap-log file?
	JRST	REAPOU		;Yes, do it
	TRNE	FL,LSTON
	JRST	LSTOUT
	OUTCHR A
	POPJ	P,

STROUT:	SKIPE	REAPLS		;Output to reap-log file?
	JRST	REAPSR		;Yes
	TRNE	FL,LSTON
	JRST	LSTSTR
	OUTSTR	(B)
	POPJ	P,

;Type octal halfword to TTY
DISLOT:	PUSH P,FL		;save flags
	TRZ FL,LSTON		;force typeout to TTY
	PUSHJ P,DISLOC		;print PC in octal
	POP P,FL		;restore flags
	POPJ P,

DISLOC:	MOVEI	C,6		;CHARACTER COUNT
	HRLZ	B,A		;DATA IS ADJUSTED LEFT
OCTCOM:	SETZ	A,
	LSHC	A,3
	ADDI	A,"0"
	PUSHJ	P,OUT.CH
	SOJG	C,OCTCOM
	POPJ	P,

OCTOUT:	MOVE	B,A
	MOVEI	C,14
	JRST	OCTCOM

SIXOUT:	MOVE	B,A
SIXOT1:	SETZ	A,
	LSHC	A,6
	ADDI	A," "
	PUSHJ	P,OUT.CH
	JUMPN	B,SIXOT1
	POPJ	P,

SIXFIL:	MOVEI	C,6			;SET COUNT.  TYPES 6 CHARACTERS FROM A
SIXFL0:	MOVE	B,A			;GET THE DATA. CALL HERE WITH C SET
SIXFL1:	SETZ	A,
	LSHC	A,6
	ADDI	A," "
	PUSHJ	P,OUT.CH
	SOJG	C,SIXFL1
	POPJ	P,

;Type filename from A,B,D, printing dot for extension and [...] for PPN.
OUTFIL:	PUSH P,B		;save ext
	PUSHJ P,SIXFIL		;print filename
	MOVEI A,"."
	PUSHJ P,OUT.CH		;print dot
	POP P,A			;ext
	MOVEI C,3		;3 chars in ext
	PUSHJ P,SIXFL0		;print ext
	MOVE A,D		;PPN
	JRST PPNOUT		;print PPN, using brackets

TYFIL:	PUSH	P,B			;TYPE THE FILE FROM A,B,D

repeat 0,<
IFN STANSW,<
PRINTX The Data Disc 24-character Line kludge lives here, still
	PUSH	P,A
	MOVEI	A," "
	PUSHJ	P,OUT.CH
	POP	P,A
>;IFN STANSW
>;repeat 0

	PUSHJ	P,SIXFIL
	MOVEI	A," "
	PUSHJ	P,OUT.CH
	POP	P,A
	HLLZ	A,A
	PUSHJ	P,SIXFIL		;WILL TYPE AT LEAST 3 EXTRA SPACES
TYFIL1:	JUMPE	D,CPOPJ
IFE IRCPPN,<
	PUSH	P,D
	HLRZ	A,D
	MOVEI	C,PPNCHR
	PUSHJ	P,PPN1
	MOVEI	A,","
	PUSHJ	P,OUT.CH
	POP	P,A
	HRRZ	A,A
	MOVEI	C,PPNCHR
	JRST	PPN1
>;IFE IRCPPN
IFN IRCPPN,<
	MOVE A,D
PPN0:	PUSH P,A
	TLNE A,777740
	TRNN A,777740
	JRST PPN8
	TLNN A,77
	JRST PPN8
	HLLZ B,A
	PUSHJ P,PPN6
	MOVEI A,","
	PUSHJ P,OUT.CH
	POP P,B
	HRLZS B
PPN6:	TLNE B,770000
	TLO B,400000
	MOVEI C,3
PPN61:	MOVEI A,0
	LSHC A,6
	ADDI A,40
	PUSHJ P,OUT.CH
	SOJG C,PPN61
	POPJ P,
>;IFN IRCPPN

PPNOUT:	PUSH	P,A			;TYPE THE PPN THAT'S IN A.
	MOVEI	A,"["
	PUSHJ	P,OUT.CH
IFE IRCPPN,<
	HLRZ	A,(P)
	MOVEI	C,PPNCHR		;THIS IS THE CHARACTER COUNT FOR PPN
	PUSHJ	P,PPN1
	MOVEI	A,","
	PUSHJ	P,OUT.CH
	POP	P,A
	HRRZ	A,A
	MOVEI	C,PPNCHR
	PUSHJ	P,PPN1
>;IFE IRCPPN
IFN IRCPPN,<
	POP P,A
	PUSHJ P,PPN0
>;IFN IRCPPN
	MOVEI	A,"]"
	JRST	OUT.CH

IFN IRCPPN,<
PPN8:	HLRZS A
	MOVEI C,3
	PUSHJ P,PPN1
	MOVEI A,","
	PUSHJ P,OUT.CH
	POP P,A
	HRRZS A
	MOVEI C,0		;DROPS THROUGH TO PPN1
>;IFN IRCPPN
PPN1:	IDIVI	A,PPNDIV
	HRLM	B,(P)
	SUBI	C,1
	JUMPE	A,.+2
	PUSHJ	P,PPN1
PPN2:	SOJL	C,PPN3
	MOVEI	A," "
	PUSHJ	P,OUT.CH
	SOJGE	C,.-1
PPN3:	HLRZ	A,(P)
	ADDI	A,PPNADD
	JRST	OUT.CH

IFN FTHELP,<
;Type PPN on CTY, to log UFDs created.  PPN is in A.
CTYPPN:	PUSH P,B
	PUSH P,C
	PUSH P,D
	MOVE C,[POINT 7,CTYMES]
	MOVEI D,6		;char count
CTYPP2:	MOVEI B,0
	ROTC A,6
	ADDI B,40		;make ASCII
	IDPB B,C
	SOJG D,CTYPP2
	MOVEI B,CTYOUT
	TTYMES B,
	 JFCL			;failed -- well, we tried
	POP P,D
	POP P,C
	POP P,B
	POPJ P,

CTYOUT:	'CTY   '		;place to type out
	.+1
	ASCII/Created: [/	;must be multiple of 5 chars
CTYMES:	ASCIZ/PRJPRG]
/				;PRJPRG gets filled in, we omit the comma
>;IFN FTHELP

TYTIME:	IDIVI	A,74			;HOURS IN A, MINUTES IN B
	PUSH	P,B			;SAVE MINUTES
	PUSH	P,A
	MOVE	B,A
	MOVEI	A,"0"
	CAIGE	B,12
	PUSHJ	P,OUT.CH	;leading 0 for hour less than 10
	POP	P,A
	PUSHJ	P,DECOUT
	MOVEI	A,":"
	PUSHJ	P,OUT.CH
	MOVE	B,(P)
	MOVEI	A,"0"
	CAIGE	B,12
	PUSHJ	P,OUT.CH	;leading 0 for hour less than 10
	POP	P,A
	JRST	DECOUT

TYFDAT:	MOVEI A,11
	PUSHJ P,OUT.CH			;output a tab
	LDB A,[POINT 12,FILINF+DDPRO,35] ;low date bits
	LDB B,[POINT 3,FILINF+DDEXT,20]	;high date bits
	DPB B,[POINT 3,A,23]		;combine date fields in A
TYDATE:	IDIVI	A,37			;DAYS IN B
	PUSH	P,A			;SAVE THE REST
	MOVEI	A," "			;BLANK
	CAIG	B,10
	PUSHJ	P,OUT.CH		;leading space for day less than 10
	MOVEI	A,1(B)			;GET THE DAY OF MONTH
	PUSHJ	P,DECOUT
	MOVEI	A,"-"
	PUSHJ	P,OUT.CH
	MOVE	A,(P)
	IDIVI	A,14			;MONTHS IN B
	MOVEM	A,(P)
	MOVEI	B,MONTAB(B)
	PUSHJ	P,STROUT
	POP	P,A
	ADDI	A,100		;=64 for 1964
	JRST	DECOUT

;Here to print current time and date, to document time of finishing various
;aspects of the dump.  Also shows how much time has passed since last time here.
TYWHEN:	OUTSTR [ASCIZ/	Current time is:  /] ;indented with tab
TYWHE0:	PUSHJ P,TYTMDT		;type time and date, return it in A
	EXCH A,LASTIM		;get previous time here, save current time
	JUMPE A,TYWHE2		;jump if no previous time stored
	OUTSTR [ASCIZ/  /]
	MOVN A,A		;negate previous time
	ADD A,LASTIM		;amount of time having passed since here last
	TLZE A,-1		;date change?
	MOVEI A,=24*=60*=60(A)	;yes, increase time change by 24 hrs (assume 1 day)
	IDIVI A,=60		;convert to minutes
	PUSH P,A
	MOVEI B,(A)
	MOVEI A," "		;a space for possible right justification of count
	CAIGE B,=10
	PUSHJ P,OUT.CH		;use at least two cols for number of minutes
	POP P,A
	PUSHJ P,DECOUT		;show number of minutes passed since last pause
	OUTSTR [ASCIZ/ mins/]
TYWHE2:	OUTSTR CRLF
	POPJ P,

;Type time and date, return date,,time in A.
TYTMDT:	ACCTIM A,		;get date,,time in seconds
	PUSH P,A		;save date and time
	MOVEI A,(A)		;flush date from LH, keep time
	IDIVI A,74		;convert time to minutes
	PUSHJ P,TYTIME		;type time of day
	OUTSTR [ASCIZ/  /]
	HLRZ A,(P)		;just date
	PUSHJ P,TYDATE		;type date and return
	POP P,A
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        subttl initialize - command dispatch ; RESTAR START NORAID STARTP STARTX CMD CMD1 CLRCON CLRCNT CMGET NODPY CMGET1 CMGET2 CMGET3 NOTYET AMBIGC ILLCOM ILLCM1 COMTAB COMTB1

RESTAR:	SKIPE MASCOP
	HALT .			;master copy -- stop before we reset things
	MOVE P,[IOWD PDLEN,PDLIST] ;HERE AFTER SOME HORRIBLE ERROR
	TRNE FL,INDON		;are we in an indirect file?
	PUSHJ P,INDFLU		;type rejected parts of @ file
	PUSHJ P,FLUSH
	RESET			;flush any output file open
	SETZM REDOPN		;no magtape open for reading
	SETZM WRTOPN		;no magtape open for writing
	SETZM MT2BUF		;no second set of magtape buffers, jobff reset
IFN STANSW,<
	PUSH P,A		;RESET clears interrupt enablings!
	MOVEI A,INTRPT		;address of interrupt handler
	MOVEM A,.JBAPR
	MOVSI A,INTTTI		;interrupt on ESC I
	INTENB A,		;enable interrupts
	POP P,A
>;IFN STANSW
	PUSHJ P,CLRCON		;clear continuation flags
	PUSHJ P,CLRCNT		;clear error counts
	SETZM MEMSAV+MT2POS	;SET output POSITION TO ZERO FEET INTO TAPE
	SETZM MEMSAV+MTAPOS	;SET input POSITION TO ZERO FEET INTO TAPE
	SETOM MEMSAV+MTQPOS	;SET input POSITION QUESTIONABLE
	SKIPE PUMPCM		;Were we doing PUMPKIN cmd?
	EXIT			;PUMPKIN cmd must come from monitor
	MOVEI FL,0		;clear all flags
	OUTSTR CRLF
	JRST CMD

START:	RESET
	SETZM REDOPN		;no magtape open for reading
	SETZM WRTOPN		;no magtape open for writing
	SETZM MT2BUF		;no second set of magtape buffers, jobff reset
DRAT,<	OUTSTR [ASCIZ/This is the special version, DRAT!  Beware
/]
>;DRAT
IFN FTHELP,<
	OUTSTR [ASCIZ/This is HART, for restoring files to RSK, spreading them around nicely.
/]
>;IFN FTHELP
	MOVEI A,VERSION
	MOVEM A,.JBVER
	MOVE P,[IOWD PDLEN,PDLIST]
	MOVEI A,REENTE		;allow REENTER to force out log file
	MOVEM A,.JBREN		;set dispatch address for monitor REENTER cmd
	PUSHJ P,DBLINI		;initialize circular debugging buffer
	MOVEI A,DEN800
	MOVEM A,DENMOD		;use default tape density (800 or 6250)
	SETZM DENDAM		;don't believe user density for sys class dumps
IFN STANSW,<
	SETZM TLISTC		;don't stop TLIST, etc., unless see ESC I
	MOVEI A,INTRPT		;address of interrupt handler
	MOVEM A,.JBAPR
	MOVSI A,INTTTI		;interrupt on ESC I
	INTENB A,		;enable interrupts

	MOVE B,JOBDDT^		;see if RAID is here
	TLNE B,777740		;skip if no RAID (RAID has version number)
	TRNN B,-1		;skip if real ptr here
	JRST NORAID		;don't have RAID in core, I guess
	MOVEI A,1		;select piece of paper number 1 (not usual PP)
	SKIPE B,-3(B)		;get ptr to $M from DDT-3
	MOVEM A,-2(B)		;set RAID's piece of paper number
NORAID:
>;IFN STANSW
IFE STANSW,<
	MOVE A,[0,,16]
	GETTAB A,
	 MOVE A,[1,,1]
	MOVEM A,GOD
	MOVE A,[1,,16]
	GETTAB A,
	 MOVE A,[1,,4]
	MOVEM A,SYSPPN
	MOVE A,[2,,16]
	GETTAB A,
	 MOVE A,[1,,2]
	MOVEM A,DUMPER
>;IFE STANSW
IFN DBGSW,<
	MOVE A,DBGPPN
	MOVEM A,DUMPER		;MAKE DUMPER = DBGPPN, FOR DEBUGGING
>;IFN DBGSW
IFE IRCPPN,<
	MOVEI A,0
	GETPPN A,
IFE STANSW,<
	 JFCL
>;IFE STANSW
	MOVEM A,LOGPPN		;SAVE LOGGED IN PPN
IFN STANSW,<
	CAME A,DUMPER
IFN FTCOPY,<
	CAMN A,['  1 ME']
	CAIA
	CAMN A,['  1JJW']
	CAIA
>;IFN FTCOPY
	JRST STARTX		;NOT THE DUMPER - DON'T SNARF PRIVS
	HRROI A,[4000,,400+"Z"]
	TTYSET A,		;Do an ESC Z to enable auto beeps when finished
STARTP:	SETZ A,
	GETPRV A,		;GET MY CURRENT PRIVS
	TDO A,DUMPRV		;OR IN THE PRIVS I NEED
	SETPRV A,		;GET THEM
	TDC A,DUMPRV
	TDCN A,DUMPRV
	JRST STARTX		;GOT THEM ALL, A.O.K.
	OUTSTR [ASCIZ /Can't enable privileges needed for system-class!!
/]
IFE DBGSW,<;Just type message and ignore it if debugging
	HALT .+1
	JRST STARTP
>;IFE DBGSW

STARTX:	MOVEI A,0		;GET STANFORD-TYPE ALIAS.
	DSKPPN A,		;GET DISK NAME OF THIS USER
>;IFN STANSW
>;IFE IRCPPN
IFN IRCPPN,<
	HRROI A,2		;USE KLUDGY IRCAM VERSION OF
	GETTAB A,		;ALIAS: GETTAB GETS REAL PPN
	 GETPPN A,
	  JFCL			;SIGH
	MOVEM A,LOGPPN
	GETPPN A,		;GETPPN GETS ALIAS
	 JFCL
>;IFN IRCPPN
	MOVEM A,USRPPN		;SAVE PPN OF THIS USER
	DATE A,
	MOVEM A,THSDAT
	OUTSTR CRLF
	SETZ FL,		;ZERO ALL THE FLAGS
	SETZM MEMSAV+MT2POS	;SET output POSITION TO ZERO FEET INTO TAPE
	SETZM MEMSAV+MTAPOS	;SET input POSITION TO ZERO FEET INTO TAPE
	SETOM MEMSAV+MTQPOS	;SET input POSITION QUESTIONABLE
	RESCAN			;RESCAN THE TTY
	TRO FL,SCANON		;DOING A RESCAN
;;	SETZM NOREAP		;Assume reap-deleting should be enabled for PDUMPs
	JRST CMD1		;SKIP THE *

CMD:	SETZ A,
IFN STANSW,<
	SETZM TLISTC		;don't stop TLIST, etc., unless see ESC I
	JBTSTS A,		;SEE IF NOT LOGGED IN
	TLNN A,10000		;JLOG
	 EXIT
>;IFN STANSW
	OUTSTR [ASCIZ/*/]
IFN STANSW,<
	MOVSI A,0		;ACTIVE
	GETPRV A,
	IOR A,[LUPPRV!LIVPRV]	;LUP AND LIV FREE IF IN PASSIVE
	MOVSI B,1		;PASSIVE
	GETPRV B,
	AND A,B			;KEEP ONLY PASSIVE-ENABLED ONES
	SETPRV A,
>;IFN STANSW
	SETZ FL,		;CLEAR ALL FLAGS.
CMD1:	TRZ FL,MRUNCM		;CLEAR MONITOR RUN COMMAND
	SETZM ARCCMD		;not doing ARCHIVE command
	SETZM MASCOP		;not doing master tape copy yet
	SETZM PUMPCM		;Not doing PUMPKIN command yet
	SETZM SWITOK		;not accepting switches yet
	SETZM REAPLS		;Not outputting to reap log file now
	SETZM REAPOP		;Reap log file is not open yet
	SETZM PREQTP		;no specific tape required yet
	SETZM STATLG		;not logging stats text in tape copy
	PUSHJ P,CLRCON		;clear automatic continuation flags
	PUSHJ P,CLRCNT		;clear error counts
	SETZM MTDEV
	PUSHJ P,CMGET		;READ A COMMAND FROM THE TTY
	TRNN FL,MRUNCM		;WAS THIS A MONITOR COMMAND?
	TRNN FL,SCANON		;WAS A REAL COMMAND. ARE WE RESCANNING?
	JRST CMD		;NOT RESCANNING OR RUN COMMAND. GO DO IT AGAIN
	EXIT			;EXIT AFTER ONE RESCANNED COMMAND.

;Reset all automatic continuation flags for various error conditions,
;without clearing error counts.  Here for every command and from ESC I.
CLRCON:	SETZM LCWRNF		;warn that file exists at Restore
	SETZM PRMOK		;ask about prev-media error files in Pumpkin
	HRRZS FILERS		;pause at file errors
	HRRZS DARTHD		;pause at head-tail rec w/o 'DART'
	HRRZS BADHTR		;pause at head-tail rec w/o *HEAD* or *TAIL*
	POPJ P,

;Clear all tape error counts for various error conditions.  We never
;clear FILERS RH, so it will count total files in error in this core image.
CLRCNT:	SETZM FONYFI		;no phony filename
	HLLZS DARTHD		;no head-tail recs w/o 'DART'
	HLLZS BADHTR		;no head-tail recs w/o *HEAD* or *TAIL*
	PUSH P,A		;preserve all ACs here
	SETZM MEDERR		;clear array of prev media error data read from tape
	MOVE A,[MEDERR,,MEDERR+1]
	BLT A,MEDERR+LMEDER-1	;clear whole array
	SETZM REDERR		;clear array of current media error data
	MOVE A,[REDERR,,REDERR+1]
	BLT A,REDERR+LMEDE1-1	;clear whole array, except constant at end!
	POP P,A
	POPJ P,

CMGET:	TLO FL,L.PUMP!L.SWIT	;ALLOWING SLASH, BUT NOT DOING IT NOW
printx Should we flush this flag diddling at CMGET for switches?
	PUSHJ P,GETSIX		;GET A COMMAND NAME
	TLZ FL,L.PUMP!L.SWIT
	CAIN A,12		;SKIP UNLESS END OF LINE
	JUMPE B,CPOPJ		;NULL COMMAND?
	JUMPE B,ILLCOM		;ILLEGAL COMMAND
	MOVEM A,SAVDEL		;SAVE THE DELIMITER

IFN STANSW!IRCPPN,<
IFN STANSW,<
;	MOVNI D,1
;	GETLIN D		;GET LINE CHARACTERISTICS
	HRROI D,[3000,,D]
	TTYSET D,		;get own line characteristics (not up PTY chain)
	CAME D,[-1]
	TLNN D,DISLIN!DDDLIN!DMLIN ;NOT DETACHED, SKIP IF DPY
	MOVEI D,0		;DETACHED OR NOT DPY
>;STANSW
IFN IRCPPN,<
	MOVE D,[2,,[ .TOTTY  0 ]]
	TRMOP. D,
	 MOVEI D,0
	TLZE D,400000		;TURN IRCAM DISPLAY BIT
	TLO D,DMLIN		; INTO SAIL DM BIT
>;IRCPPN
	MOVEM D,LINSAV		;<0=III, >0=DD, 0=TTY OR DETACHED
	JUMPE D,NODPY
	MOVE A,DDCMD
	TLNN D,DDDLIN		;Skip if DD
	SETZ A,
	MOVEM A,BUFBUF		;First word of display program
	MOVE A,DDBUF		;Assume DD
	TLNE D,DISLIN
	MOVE A,IIIBUF
	TLNE D,DMLIN
	MOVE A,DMBUF
	MOVEM A,BUFBUF+1
NODPY:
>;IFN STANSW!IRCPPN

				;CREATE A MASK FOR THE SEARCH
	SETZB D,AMBIG		;REMEMBER LOCATION OF COMMAND
	TDZ C,[007700,,-1]	;BYTE SIZE SET TO 44. POINTS TO D
	TDO C,[004400,,D]
	SETO A,
	DPB A,C			;SET UP D WITH A MASK
	MOVSI C,-COMTL
	SKIPE PUMWIZ
	MOVSI C,-PCOMTL		;EXTRA COMMANDS FOR PUMPKIN WIZARD
CMGET1:	MOVE A,COMTAB(C)
	CAMN B,A
	JRST CMGET3
	AND A,D
	CAME A,B
	JRST CMGET2
	MOVE A,C
	EXCH A,AMBIG		;REMEMBER THIS COMMAND
	JUMPE A,CMGET2
	MOVNI C,2		;AMBIGUOUS COMMAND
	JRST CMGET3		;
CMGET2:	AOBJN C,CMGET1
	SKIPN C,AMBIG
	MOVNI C,1
CMGET3:	MOVE C,COMTB1(C)
	SKIPE PUMWIZ		;PUMPKIN WIZARD POSITIONING TAPE?
	JUMPGE C,ILLCOM		;YES, ONLY SOME COMMANDS LEGAL
	JRST (C)		;DISPATCH

NOTYET:	OUTSTR [ASCIZ/Unimplemented command "/]
	JRST ILLCM1
AMBIGC:	OUTSTR [ASCIZ/Ambiguous command "/]
	JRST ILLCM1
IFE UDPCSW,<UDPCOP:>
IFE KMCSW,<KMCDMP:>
ILLCOM:	OUTSTR [ASCIZ/Illegal command "/]
ILLCM1:	MOVE A,B
	PUSHJ P,SIXOUT
	OUTSTR [ASCIZ/"
/]
	CLRBFI
	POPJ P,

COMTAB:	'R     '
	'RUN   '
	'START '
	'CONTIN'
	'S     '		;START
	'DDT   '
	'DUMP  '		;DUMP FILES FOR A USER
	'RESTOR'		;RESTORE 
	'MRESTO'		;MAJOR RESTORE  - PRIVILEGED
	'FDUMP '		;FULL DUMP    -   PRIVILEGED
	'TDUMP '		;TEMPORARY DUMP - PRIVILEGED
	'PDUMP '		;PERMANENT DUMP - PRIVILEGED
	'PICKUP'		;PICKUP LAST COMMAND AFTER A CRASH
	'REWIND'		;REWIND
	'UNLOAD'		;rewind and unload
	'ADVANC'		;ADVANCE FILE OR RECORD
	'BACKSP'		;BACKSPACE FILE OR RECORD
	'LIST  '		;LIST THE TAPE
	'TLIST '		;LIST FOR COMPATABILITY
	'EOT   '		;ADVANCE TO END OF TAPE
	'LOCATE'		;LOCATE FILES FROM DART.DAT
	'EXIT  '
	'POSITI'		;POSITION THE TAPE
	'ARCHIV'		;ARCHIVE COMMAND
	'PURGE '		;DO PCLASS DUMP, DELETING FILES
	'UDPCOP'		;COPY OLD UDP TO NEW
	'KMCDMP'
	'NODUMP'		;SET NO-DUMP BIT FOR FILES
	'MAXLEN'		;SET MAX LENGTH FOR SYSTEM DUMPS
	'TURKEY'		;SEE WHO LAST USED A TAPE
	'PUMPKI'		;ASK THE GREAT PUMPKIN TO RESTORE A FILE
	'PRESTO'		;I AM THE GREAT(EST) PUMPKIN!
	'PLIST '		;LIST THE PUMPKIN QUEUE
	'UNPUMP'		;UN-PUMPKIN
	'REAP  '		;CAUSE FILE TO BE DUMPED AND DELETED
	'UNREAP'		;UNDO REAP
	'NOREAP'		;DISABLE DELETION OF REAPED FILES IN THIS CORE IMAGE
	'DENSIT'		;specify density to use reading/writing tapes
	'DENDAM'		;believe user density even if system class dump
	'DENDAX'		;no-op, prevent abbreviation of above
	'IDENSI'		;input density for tape copy
	'COPY  '		;user tape to tape copy
	'TCOPY '		;user tape to tape copy
	'UCOPY '		;user tape to tape copy
	'MCOPY '		;master tape to tape copy
	'EOFON '		;list EOFs in input
	'EOFOFF'		;don't list EOFs in input
	'REENTE'		;reenter, act like Monitor REENTER cmd (PPSAV)
	'COMPAR'		;compare file on tape with file on disk
IFN FTCOPY,<
DRAT,<
	'DTSORT'		;sort DTAPES.DAT
>;DRAT
	'MMERGE'		;merge DTAPES.DAT with DART.DAT via MANMER
>;IFN FTCOPY
	'MANMER'		;MANMERGE command
	'VERIFY'		;VERIFY DART.DAT & DART.ARC
SDEF COMTL,.-COMTAB
;FOLLOWING SPECIAL COMMANDS ACCEPTED ONLY AFTER TAPE ERROR IN PRESTORE
	'RETRY '		;RETRY THIS TAPE
	'FLUSH '		;FLUSH THIS TAPE
SDEF PCOMTL,.-COMTAB

;I think the sign bit means the command is legal after tape error in PRESTORE
	AMBIGC
	ILLCOM
COMTB1:	MONCOM			;R
	MONCOM			;RUN
	MONCOM			;START
	MONCOM			;CONTINUE
	MONCOM			;S(TART)
	400000,,DDTCOM		;DDT
	DUMPGO			;DUMP
	RESTGO			;RESTORE
	MRESTO
	FDUMP
	TDUMP
	PDUMP
	PICKUP
	400000,,REWGO		;REWIND
	UNLGO			;UNLOAD TAPE
	400000,,ADVANC		;ADVANCE
	400000,,BACKSP		;BACKSPACE
	LISTGO			;LIST
	LISTGO			;TLIST
	400000,,EOTGO		;EOT
	DLOCAT			;LOCATE
	[EXIT]			;EXIT
	NOTYET			;POSITION (UNIMPLEMENTED)
	ARCHIV			;ARCHIVE
	0,,PURGE		;PURGE COMMAND
	UDPCOP			;UDP COPY.
	KMCDMP			;KMCDMP
	NODUMP			;SET NO-DUMP BIT FOR FILES
	MAXSET			;SET MAX LENGTH FOR SYSTEM DUMPS
	TURKEY			;FIND OUT WHO DIDN'T PUT THE TAPE AWAY
	PUMPKI			;ASK THE GREAT PUMPKIN TO RESTORE A FILE
	PRESTO			;I AM THE GREAT(EST) PUMPKIN!
	PLIST			;LIST THE PUMPKIN QUEUE
	UNPUMP			;REMOVE A PUMPKIN REQUEST
	REAP			;CAUSE FILE TO BE DUMPED AND DELETED
	UNREAP			;UNDO REAP
	NOREPD			;DISABLE REAP-DELETION IN THIS CORE IMAGE
	DENSIT			;specify density to use reading/writing tapes
	SDENDA			;believe user density even if system class dump
	CPOPJ			;no-op, prevent abbreviation of above
	IDENSI			;input density for tape copy
	UCOPY			;user tape to tape copy
	UCOPY			;user tape to tape copy
	UCOPY			;user tape to tape copy
	MCOPY			;system-class tape copy
	EOFON			;list EOFs in input
	EOFOFF			;don't list EOFs in input
	REENTD			;act like Monitor REENTER cmd (PPSAV)
	COMPGO			;compare file on tape with file on disk
IFN FTCOPY,<
DRAT,<
	DTSOR0			;sort DTAPES.DAT
>;DRAT
	MMERGE			;merge DTAPES.DAT with DART.DAT via MANMER
>;IFN FTCOPY
	MANCMD			;MANMERGE command
	VERIFY			;VERIFY DART.DAT & DART.ARC
;FOLLOWING SPECIAL COMMANDS ACCEPTED ONLY AFTER TAPE ERROR IN PRESTORE
	400000,,RETRY		;RETRY THIS TAPE
	400000,,TFLUSH		;FLUSH THIS TAPE
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  subttl	ddt call and monitor startup	 ; DDTCOM DDTGO NODDT MONCOM FLUSH FLUSH1 MAXSET

DDTCOM:	CLRBFI			;FLUSH TYPE AHEAD
	TRNN	FL,SCANON	;ARE WE RESCANNING?
	JRST	DDTGO		;NO. CALL DDT
	TRO	FL,MRUNCM
	POPJ	P,

DDTGO:	HRRZ	A,.JBDDT	;PICKUP .JBDDT
	JUMPE	A,NODDT
	MOVE	B,[10000,,CPOPJ]
	MOVEM	B,.JBOPC	;make $P work
	OUTSTR	[ASCIZ/(DDT.  Return with $P)
/]
	JRST	(A)		;DO IT.

NODDT:	OUTSTR	[ASCIZ/No DDT
/]
	POPJ	P,

MONCOM:	MOVE	A,SAVDEL	;GET THE DELIMITER
	TRO	FL,MRUNCM	;ANNOUNCE ANOTHER RUN CONTROL COMMAND
	JRST	FLUSH1		;discard command

FLUSH:	INCHRS	A
	POPJ	P,
FLUSH1:	CAIE	A,12
	CAIN	A,ALTMOD
	POPJ	P,
	INCHWL	A
	JRST	FLUSH1		;FLUSH UNTIL LF OR ALTMODE

;CODE FOR DISPATCH TO UNIMPLEMENTED OPERATIONS

	OUTSTR	[ASCIZ/Unimplemented operation "/]
	MOVE	A,B
	PUSHJ	P,SIXOUT
	OUTSTR	[ASCIZ/"
/]
	POPJ	P,

MAXSET:	PUSHJ P,RDNUMB		;READ NUMBER AFTER MAXLEN
	LSH B,7			;RECORDS INTO WORDS
	MOVEM B,MAXLEN
	POPJ P,

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              subttl	rewind, eot, advance, backspace	 ; REWGO UNLGO EOTGO ADVANC BACKSP ADVAN1 ADVAN2 ADVAN3 ADVAN4 ADVGO BACK1 BACK2 ADVCM NUMTST NUMTS1 NUMTSX ADVTO ADVTO2 ADVTO3 POSWIN FIFOOT POSLUZ

REWGO:	PUSHJ	P,DEVSCN		;SCAN FOR A DEVICE, ETC.
	PUSHJ	P,MTINIR		;Init magtape, not writing
	TRZ	FL,MTAEOT
	PUSHJ	P,MTAREW
	PUSHJ	P,MTAREL		;RELEASE DEVICE.
	POPJ	P,

UNLGO:	PUSHJ	P,DEVSCN		;SCAN FOR A DEVICE, ETC.
	PUSHJ	P,MTINIR		;Init magtape, not writing
	TRZ	FL,MTAEOT
	PUSHJ	P,MTAUNL		;unload the tape
	PUSHJ	P,MTAREL		;RELEASE DEVICE.
	POPJ	P,

EOTGO:	PUSHJ	P,DEVSCN
	PUSHJ	P,MTINIR		;Init magtape, just reading
	PUSHJ	P,MTASKT		;SKIP TO END OF TAPE
	PUSHJ	P,MTAREL
	POPJ	P,


ADVANC:	TROA	FL,ADVCOM		;SET ADVANCE COMMAND
BACKSP:	TRZ	FL,ADVCOM		;CLEAR ADVANCE.
	TRO	FL,ABFILE		;ADVANCE/BACKSPACE FILE
	MOVEI	A,1
	MOVEM	A,REPCNT		;ASSUME REPEAT FACTOR OF ONE
	MOVE	A,SAVDEL
	CAIE	A,12
	CAIN	A,ALTMOD
	JRST	ADVGO
	PUSHJ	P,GETSIX		;GET SOMETHING IN SIXBIT
	CAIN	A,":"			;COLON FORCES THE DEVICE NAME
	JRST	ADVAN3			;TREAT THIS AS A DEVICE NAME
	CAMN B,['TO    ']
	JRST ADVTO		;wants to position on particular file
	CAMN	B,['FILE  ']
	JRST	ADVAN1			;ADV/BAK FILE
	CAME	B,['RECORD']
	JRST	ADVAN2			;THIS MUST BE A DEVICE NAME
	TRZ	FL,ABFILE		;CLEAR ADV/BAC FILE FLAG
ADVAN1:	CAIE	A,12
	CAIN	A,ALTMOD
	JRST	ADVGO			;DONE WITH SCAN
	PUSHJ	P,GETSIX
	CAIN	A,":"
	JRST	ADVAN3			;FORCE DEVICE NAME NOW.
ADVAN2:	PUSHJ	P,NUMTST		;TEST SIXBIT IN B FOR BEING A NUMBER
	JRST	ADVAN3			;NOT A NUMBER MUST BE A DEVICE NAME
	JRST	ADVAN4			;PROCESS A NUMBER

ADVAN3:	MOVEM	B,MTDEV			;SAVE DEVICE NAME
	CAIE	A,12
	CAIN	A,ALTMOD
	JRST	ADVGO
	PUSHJ	P,GETSIX
	CAMN B,['TO    ']
	JRST ADVTO		;wants to position on particular file
	JUMPE	B,ADVGO			;IGNORE NULLS.
	PUSHJ	P,NUMTST
	JRST	SYNTAX			;IMPROPER SYNTAX
ADVAN4:	MOVEM	C,REPCNT		;SAVE REPEAT COUNT.
ADVGO:	PUSHJ	P,MTINIR		;Init magtape, just reading
	MOVE	C,REPCNT
	TRNE	FL,ADVCOM		;ADVANCE OR BACKSPACE?
	JRST	ADVCM			;ADVANCE
BACK1:	TRNN	FL,ABFILE
	PUSHJ	P,MTABKR		;BACKSPACE RECORD
	TRNE	FL,ABFILE
	PUSHJ	P,MTABKF		;BACKSPACE FILE
	PUSHJ	P,MTABOT		;WAIT, and skip if at beginning of tape
	 SOJG	C,BACK1			;STILL IN TAPE KEEP ON TRUCKING
	STATZ	MTA,IOBOT		;AT FRONT OF TAPE?
	JRST	BACK2
	TRNE	FL,ABFILE		;SKIP IF BY RECORDS
	PUSHJ	P,MTASKF		;NO. HAVE TO SKIP FORWARD OVER EOF MARK
	TRNN	FL,ABFILE		;SKIP IF BY FILES
	PUSHJ	P,MTASKR		;BY RECORDS, SKIP ONE RECORD.
BACK2:	PUSHJ	P,MTAREL
	POPJ	P,

ADVCM:	TRNN	FL,ABFILE
	PUSHJ	P,MTASKR		;ADVANCE RECORD
	TRNE	FL,ABFILE
	PUSHJ	P,MTASKF		;ADVANCE FILE
	STATO	MTA,IOTEND		;END OF TAPE?
	SOJG	C,ADVCM			;NO. KEEP ON TRUCKING
	PUSHJ	P,MTAREL
	POPJ	P,			;RETURN

NUMTST:	JUMPE	B,CPOPJ			;NULL IS NOT A NUMBER
	PUSH	P,B
	SETZ	D,
NUMTS1:	SETZ	C,
	ROTC	B,6
	SUBI	C,'0'
	JUMPL	C,NUMTSX
	CAILE	C,11
	JRST	NUMTSX
	IMULI	D,12
	ADDI	D,(C)
	JUMPN	B,NUMTS1
	MOVE	C,D
	AOS	-1(P)
NUMTSX:	POP	P,B
	POPJ	P,

;Want to advance or backspace to a particular file on the tape (any one
;of the files listed on the command line).
;If the file is not at the beginning of a magtape file, a warning will
;be issued.
ADVTO:	MOVEM A,SAVDEL		;save delimiter in case is linefeed
	SETOM SWITOK		;rel dump number switch is OK here
	PUSHJ P,SCAN		;scan for filename(s)
	SKIPE DEST		;shouldn't be any destination
	JRST ILLDST		;lose, specified dest
	HRRZ W,TBASE		;GET THE BASE OF ALL TERMS
ADVTO2:	CAML W,FSPTR		;any more source terms?
	JRST ADVTO3		;no
	SKIPE A,FSDEV(W)	;skip if no device here
	EXCH A,MTDEV		;store device, see if old device
	CAME A,MTDEV		;skip if same device
	JUMPN A,ILLMUL		;jump if multiple devices (else no prev dev given)
	ADDI W,FSLEN		;increment W to next term block
	JRST ADVTO2

ADVTO3:	TRNN FL,ADVCOM		;skip if ADVANCE COMMAND
	JRST NOBACK		;sorry, not implemented for backward direction
	MOVEI K,POSRST		;set table pointer for positioning tape to file
	PUSHJ P,MINIT1		;init magtape with one buffer
	JRST RSTG4A		;jump into Restore loop to scan tape

;Here when have just found a sought file on the tape
;Now back up to the beginning of this record.
POSWIN:	MOVE A,TIBUF+1		;get final byte pointer
	SUB A,TIBUF		;see how far into record we went (ignore LH)
	MOVE B,INVERS		;get version number
	CAIGE B,IOVER3		;starting with this version, there was more leader
	SKIPA B,[WCWD+DVWD+INFOSIZE+1] ;old version: distance into record if first file
	MOVEI B,WCWD+LLEAD3+1	;newer version: distance into record if first file
	CAIE B,(A)		;exact position means file is at beginning of record
	OUTSTR [ASCIZ/Warning: file found isn't first thing in magtape record:
/]
	PUSHJ P,MTABKR		;backspace record
	PUSHJ P,MTAREL
	MOVE D,[FILINF,,A]
	BLT D,D
	PUSHJ P,TYFIL		;report file found
	PUSHJ P,TELDMP		;type relative dump number, if any
	PUSHJ P,FIFOOT		;type file's footage position on the tape
	OUTSTR CRLF
	POPJ P,

;Type current file's position on the tape, if included in format.
FIFOOT:	MOVE A,INVERS		;see if this format has extended data
	CAIGE A,IOVER3		;more data if this version or later
	POPJ P,			;no footage info available on tape
	MOVEI A,11
	PUSHJ P,OUT.CH		;output tab
	MOVE A,SRCDEV+LL3FT-1	;get tape position in feet
	PUSHJ P,DECOUT		;type footage position
	MOVEI B,[ASCIZ/ ft/]
	JRST STROUT		;type string and return from routine

;Here when reached end of tape and didn't find sought file.
POSLUZ:	PUSHJ P,MTAREL
	OUTSTR [ASCIZ/Failed to find given file(s) on tape.
/]
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          subttl	tlist, list commands	 ; LSTINI LSTIN0 LSTIN1 LSTIN2 LSTBIN LSTBI0 LISTGO LSTLP LSTLP1 NEWDT0 LSTLP1 LSTLPY LSTLPX STOPIT LSTLP2 LSTLP3 LSTFIN TELDMP TELDM0 TEMDMP DALISC DALIST DALIS0 DALISF DALISE DALISX NEWDTA DTAEXT DRADMP

LSTINI:	TRZ	FL,LSTON+LSTTTY		;ZERO SOME BITS
	SETZM	LSTDEV-1		;KLUGE
	SKIPN	R,DEST			;WAS THERE ANY DESTINATION GIVEN
	MOVEI	R,LSTDEV-1		;KLUGE TO ZERO RSTDEV BLOCK
	MOVSI	R,(R)			;SOURCE OF BLT
	HRRI	R,LSTDEV		;DESTINATION
	BLT	R,LSTPPN		;DO THE TRANSFER
	MOVSI	A,'TTY'			;ASSUME TTY IF NO EXPLICIT DEST.
	SKIPN	DEST			;WAS THERE EXPLICIT DEST TERM
	MOVEM	A,LSTDEV		;NO. SET *.* FLAGS
	SKIPN	A,LSTDEV		;IF THIS IS ZERO
	MOVSI	A,'DSK'			;THERE WAS EXPLICT DEST AND NO DEV.
	MOVEM	A,LSTDEV		;SAVE AS RESTORE DEVICE.
	HRRZ	B,LSTEXT		;GET ANY WILD BITS
	TRNE	B,ALLMSK		;ARE ANY SET?
	JRST	ALLLST			;YES. *'S ILLEGAL IN LIST TERM
	MOVEI	A,0			;LISTING IN MODE 0
	MOVE	B,LSTDEV		;PICKUP THE LISTING DEVICE
	MOVSI	C,LSTBUF		;BUFFER HEADER.
	OPEN	LST,A			;OPEN THE DEVICE
	PUSHJ	P,NODEV			;LOSE.
	OUTBUF	LST,2			;MAKE SOME BUFFERS.
	MOVE	A,LSTDEV		;GET THE NAME OF THE LISTING DEVICE
	DEVCHR	A,			;GET CHARACTERISTICS
	TRO	FL,LSTON		;ANNOUNCE WE ARE LISTING
	TLNE	A,TTYBIT		;IS THIS A TTY?
	TRO	FL,LSTTTY		;MARK AS BEING LISTING ON A TTY
	TLNN	A,DIRBIT		;IS THIS A DIRECTORY DEVICE?
	POPJ	P,			;NO.  ENTER IS UNNECESSARY
	SKIPE	A,LSTNAM		;GET A FILE NAME
	JRST	LSTIN1
	MOVE	A,['DART  ']		;
	MOVSI	B,'LST'
LSTIN0:	SETZB	C,D
	JRST	LSTIN2

LSTIN1:	HLLZ	B,LSTEXT		;GET THE EXTENSION.
	SETZ	C,
	SKIPN	D,LSTPPN
LSTIN2:	MOVE	D,USRPPN
	ENTER	LST,A
	 JRST	NOENT
	POPJ	P,

DRAT,<
LSTBIN:	TRZ	FL,LSTON+LSTTTY		;ZERO SOME BITS.  Initialize BINARY OUT
	MOVSI	A,'DSK'			;THERE WAS EXPLICT DEST AND NO DEV.
	MOVEM	A,LSTDEV		;SAVE AS RESTORE DEVICE.
	MOVEI	A,10			;LISTING IN MODE 0
	MOVE	B,LSTDEV		;PICKUP THE LISTING DEVICE
	MOVSI	C,LSTBUF		;BUFFER HEADER.
	OPEN	LST,A			;OPEN THE DEVICE
	 PUSHJ	P,NODEV			;LOSE.
	OUTBUF	LST,2			;MAKE SOME BUFFERS.
IFE FTCOPY,<
	MOVSI	B,'BIN'
	SKIPE	A,LSTNAM
	JRST	LSTIN1
>;IFE FTCOPY
IFN FTCOPY,<
LSTBI0:	AOS B,DTAEXT		;use new extension
	MOVSI B,(B)		;in LH please
>;IFN FTCOPY
	MOVE	A,['DRAT  ']
	JRST	LSTIN0
>;DRAT
	

LISTGO:
;;	SETOM	TLISTC			;set TLIST count to infinity
	PUSHJ	P,SCAN			;SCAN THE WORLD
	HRRZ	W,TBASE			;GET THE BASE OF ALL TERMS
	CAML	W,FSPTR			;ARE THERE ANY SOURCE TERMS AT ALL?
	PUSHJ	P,GETBLK		;NO. MAKE A TERM BLOCK
	SKIPN	A,FSDEV(W)		;LOOK FOR A DEVICE
	MOVE A,FSNAM(W)		;maybe no colon after device, so try file name
	MOVEM	A,MTDEV			;SAVE MT DEVICE.
	PUSHJ	P,MTINIR		;Init magtape, just reading
	PUSHJ	P,MTANOP		;DO A MTA NO-OP TO DETECT FRONT OF TAPE

NODRAT,<
	PUSHJ	P,LSTINI		;Text listing
>;NODRAT


DRAT,<	MOVE	A,['TLIST ']		;Special binary listing of tape.
	MOVSI	B,'BIN'
	MOVEM	A,LSTNAM
	MOVEM	B,LSTEXT
	SETZM	LSTPPN
	PUSHJ	P,LSTBIN		;Make binary, not text listings
	SETZM	DRATPP#			;no previous ppn
	;fall into LSTLP
>;DRAT
LSTLP:	SETZM SAWEOF		;haven't seen eof yet
	PUSHJ P,RDFIL		;READ A FILE HEADER
	 JRST LSTLPX		;saw a tape header/trailer, no file to type out
	TRNE FL,MTAEOT		;logical END OF TAPE?
	JRST LSTLP2		;YES. WE'RE DONE

NODRAT,<
	SKIPE FONYFI		;is the filename in FILINF a fake (not on tape)?
	JRST LSTLPY		;yes, don't type filename that isn't really on tape
	MOVE	A,SRCDEV
	JUMPE	A,LSTLP1
	CAMN	A,['DSK   ']
	JRST	LSTLP1
	PUSHJ	P,SIXOUT
	MOVEI	A,":"
	PUSHJ	P,LSTOUT
	MOVEI	A,11
	PUSHJ	P,LSTOUT		;SOME SPACE.
LSTLP1:	MOVE	A,FILINF+DDNAM		;GET FILE NAME
	MOVE	B,FILINF+DDEXT
	MOVE	D,FILINF+DDPPN
	PUSHJ	P,TYFIL			;TYPE A FILE NAME FROM A,B,D
	SKIPE TELEOF		;reporting lots of data?
	PUSHJ P,TELDMP		;yes, type rel dump number, if any
	SKIPE TELDAT		;reporting date?
	PUSHJ P,TYFDAT		;yes, type out tab and file's date
	SKIPE TELEOF		;reporting lots of data?
	PUSHJ P,FIFOOT		;yes, type file's footage position on the tape
;;Can't do this here since we haven't read the previous media error block yet,
;;and in fact RDFILX (called below) will just skip over that data anyway.
;;	MOVEI B,[ASCIZ/ (previous media errors)/]
;;	SKIPE TAPERR-REDERR+MEDERR	;skip if no previous media errors
;;	PUSHJ P,LSTSTR			;warn user
	MOVEI	B,CRLF
	PUSHJ	P,LSTSTR
	TRNE	FL,LSTTTY		;SKIP UNLESS LISTING ON A TTY
	CLOSE	LST,			;FORCE EACH LINE OUT TO THE TTY
>;NODRAT

DRAT,<
;This listing format is the same as is made for ALLDIR.MEM while a dump
;is in progress.
;	PPN Word
;	File entries for this PPN
;	0
;Where any number of file entries can be made per PPN
;Each file entry is three words:
;	FILE NAME
;	EXT,,TAPE+200000		Tape is tape number + 400000 if T-class
;	File Creation Date		200000 signals that a date word is present
;
;The actual ALLDIR.MEM file contains two word file entries also, but we don't
;have any of those here.
;
IFN FTCOPY,<
	MOVE D,FILINF+DDPPN	;get PPN
	CAME D,FAKEFI+3		;fake PPN?
	PUSHJ P,TCOPAD		;skip unless file is ALLDIR.DAT[DMP,SYS]
	 JRST LSTLPY		;no listing entry for that file
;patch here to start new output file at new rel dump instead of abs dump
NEWDT0:	HRRZ A,SRCDEV+LL3DMP-1	;get abs dump nbr from file on tape (assumes iover3)
	CAME A,DRADMP		;same dump?
	PUSHJ P,NEWDTA		;no, close DTAPES and open a new one
>;IFN FTCOPY
	MOVE	A,FILINF+DDPPN
	CAMN	A,DRATPP		;same ppn as previous?
	JRST	LSTLP1			;yes. save work
	MOVEI	A,0
	SKIPE	DRATPP			;is this the first time here?
	PUSHJ	P,LSTOUT		;no. send zero to terminate previous
	MOVE	A,FILINF+DDPPN
	MOVEM	A,DRATPP		;save current ppn
	PUSHJ	P,LSTOUT		;Send PPN
LSTLP1:	MOVE	A,FILINF+DDNAM
	PUSHJ	P,LSTOUT
IFN FTCOPY,<
	JRST DALIST		;special code for reading back copied tape
>;IFN FTCOPY
IFE FTCOPY,<
	HLLZ	A,FILINF+DDEXT
	HRR	A,THSTAP
	TRO	A,200000		;mark that a file date follows
	PUSHJ	P,LSTOUT
	LDB	A,PDATE			;Low date from FILINF+DDPRO 24:35
	LDB	B,PDATEH		;Hi Date from DDEXT 18:20
	DPB	B,[POINT 3,A,23]
	PUSHJ	P,LSTOUT
>;IFE FTCOPY
>;DRAT

LSTLPY:	PUSHJ	P,DPYSER		;DISPLAY NAME, PPN, AND NO. OF FEET
	 FILINF+DDNAM,,DPYFIL
	PUSHJ	P,RDFILX		;FLUSH THE REST OF THE FILE
	TRNE	FL,MTAEOT		;SKIP UNLESS END OF TAPE THERE
	JRST	LSTLP2			;EOT
LSTLPX:	AOSN SAWEOF		;skip if haven't seen eof
	SOSE TLISTC		;want to stop here?
	JRST LSTLP		;LOOP
	PUSHJ P,STOPIT		;stop here
	JRST LSTLP3		;exit loop

STOPIT:	PUSHJ P,MTABKF		;BACKSPACE to beginning of next file already read
	OUTSTR [ASCIZ/Stopped by ESC I.
/]
	POPJ P,

;Here upon logical EOT during TLIST.  (We just reported logical EOT.)
;Some people use TLIST to get to the end of the tape. Don't rewind.
LSTLP2:	TRZ	FL,MTAEOT		;clear end of tape flag.  See RSTG99

DRAT,<	PUSHJ	P,MTAREW		;DRAT wants another tape
>;DRAT

	OUTSTR	[ASCIZ/Type altmode to return to command level, or
mount another tape and type return to continue in TLIST
/]
	CLRBFI
	INCHWL	A
	PUSHJ P,FLUSH1		;eat input line up to LF of ALT
	CAIN	A,ALTMOD
	JRST	LSTLP3			;he wants out.
	PUSHJ	P,MTAREW		;let's rewind the tape for him
	PUSHJ	P,MTACLZ		;close, so buffers are unconfused.
	JRST	LSTLP			;Go list more

LSTLP3:	PUSHJ	P,MTAREL		;FINISHED WITH MTA

DRAT,<	MOVEI	A,0			;end last PPN with a zero.
	PUSHJ	P,LSTOUT
>;DRAT

LSTFIN:	TRZ	FL,LSTON+LSTTTY
	CLOSE	LST,
	RELEAS	LST,
	POPJ	P,

;Report relative dump number of file from tape, unless early format tape.
TELDMP:	MOVE A,INVERS		;get tape format number
	CAIGE A,IOVER3		;skip unless copying an early tape
	POPJ P,			;doesn't have rel dump number
TELDM0:	MOVEI A,"/"
	PUSHJ P,OUT.CH		;type a slash before rel dump nbr
	HLRZ A,SRCDEV+LL3DMP-1	;get rel dump number from file on tape
	JRST DECOUT		;type it

;Report relative dump number of file going onto tape, from MEMSAV+RELABS.
TEMDMP:	MOVEI A,"/"
	PUSHJ P,OUT.CH		;type slash before rel dump nbr
	HLRZ A,MEMSAV+RELABS	;get rel dump number
	JRST DECOUT		;type it out


DRAT,<
IFN FTCOPY,<
;Come here from LISTGO.
;Make binary file listing of files on a tape.
;Assumes multiple dumps can be on the tape, and makes one DTAPES.DAT-format
;file per dump encountered, incrementing the extension for each dump.
;Omits ALLDIR.DAT[DMP,SYS] from listing.

;This listing format is the same as is made for DTAPES.DAT while tape copy
;is in progress.
;	PPN Word
;	File entries for this PPN
;	0
;Where any number of file entries can be made per PPN
;Each file entry is three words:
;	FILE NAME
;	EXT,,TAPE+PRMERR+high.rel.dmp	Tape is tape number + 400000 if T-class
;	File Date+low.rel.dmp
;
;

;We have to read through the tape to the last continuation block to find
;the final previous-media-error data block for the file on the tape.
DALISC:
    pushj p,iwcdbg		;make sure RH A isn't negative or otherwise bad
	HRRZM A,IWC		;this is a continuation block, save the word count
DALIST:	MOVE A,IWC		;PICKUP THE WORD COUNT REMAINING
;;;	ADD A,PSTDAT		;include trailer words
	ADDM A,TIBUF+1		;INCREMENT THE BYTE POINTER
	pushj p,tibufc		;check tibuf+1 for overflow
	MOVN A,A
	ADDB A,TIBUF+2		;DECREMENT THE BUFFER COUNT
	SUB A,PSTDAT		;must be room for prev media error data and checksum
	CAIG A,1		;Record is short if count's not positive
	HALT .			;Short record, report it (avoid recursion)
	PUSHJ P,RERDAT		;read previous media error data
	PUSHJ P,TREAD		;READ AHEAD. THIS IS THE CHECKSUM
DALIS0:	PUSHJ P,TREADX		;READ MORE. THIS IS NEXT WC.
	TRNE FL,MTAEOT		;logical END OF TAPE?
	JRST DALISE		;yup, end of this file for sure
	JUMPE A,DALIS0		;JUMP IF NO DATA LEFT IN THIS RECORD
	JUMPL A,DALISF		;jump if this is a file-start block
	TLNE A,-1		;SKIP IF LEFT SIDE OF A IS ZERO
	JRST DALISF		;this should be a tape trailer or header
	PUSHJ P,FMTCHK		;check the word-count word for reasonableness
	 HALT .			;not valid at all
	 HALT .			;file cont block, but MT buffer is short (MT lost)
	 JRST DALISC		;valid continuation block
	 HALT .			;file start block, but MT buffer is short (MT lost)
	HALT .			;file start block

DALISF:	PUSHJ P,RDFLX1		;back up the byte pointer and count to reread data
DALISE:	MOVE D,FILINF+DDPPN	;get PPN
	CAME D,FAKEFI+3		;fake PPN?
	PUSHJ P,TCOPAD		;skip unless file is ALLDIR.DAT[DMP,SYS]
	 HALT DALISX		;no listing entry for that file -- SHOULDN'T HAPPEN
	HRRZ A,SRCDEV+LL3TAP-1	;get tape number from extended file leader (iover3)
;;	HRR A,THSTAP	;;has tape number from previous media header
	ANDI A,400000!TAPMSK	;just tape number and T-tape bit if on
printx This is set to work only for P3000 thru P3003 -- see DALISE (assumes iover3+).
	CAIL A,=3000
	CAILE A,=3003		;range check it
	HALT .			;not in range
	HLL A,FILINF+DDEXT	;insert file ext
	SKIPE TAPERR-REDERR+MEDERR ;skip unless any previous media errors
	TRO A,PRMERR		;mark file as having previous media errors
	HLRZ B,SRCDEV+LL3DMP-1	;get rel dump number of file on tape
	LSH B,-RDLBTS		;shift out the low-order bits
	DPB B,[POINT RDHBTS,A,RDHPOS+=18] ;insert high-order bits of rel dmp nbr
	PUSHJ P,LSTOUT
	LDB A,PDATE		;Low date from FILINF+DDPRO 24:35
	LDB B,PDATEH		;Hi Date from DDEXT 18:20
	DPB B,[POINT 3,A,23]
	HLRZ B,SRCDEV+LL3DMP-1	;get rel dump number of file on tape
	DPB B,[POINT RDLBTS,A,RDLPOS] ;insert high-order bits in RH
	PUSHJ P,LSTOUT
DALISX:	PUSHJ P,DPYSER		;DISPLAY NAME, PPN, AND NO. OF FEET
	 FILINF+DDNAM,,DPYFIL
	TRNE FL,MTAEOT		;SKIP UNLESS END OF TAPE THERE
	JRST LSTLP2		;EOT
	JRST LSTLPX		;back to main loop for next file

NEWDTA:	MOVEM A,DRADMP		;save abs dump number
	SKIPN DRATPP		;is this the first time here?
	POPJ P,			;yes, nothing in the file yet, no new file needed
	MOVEI A,0
	PUSHJ P,LSTOUT		;no. send zero to terminate final PPN
	CLOSE LST,		;close file
	PUSHJ P,LSTBI0		;start new file, new extension
	SETZM DRATPP		;no PPN in new file yet
	POPJ P,

DTAEXT:	'   CP@'		;extension in RH, gets AOS'd to CPA, CPB, ...
DRADMP:	-1			;unlikely initial abs dump nbr
>;IFN FTCOPY
>;DRAT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      subttl	dump, nodump, reap, unreap commands	 ; NOREPD UNREAP REAP NODUMP SETCLR DUMPGO SETCL2 DMPG1 DMPG2 DMTERM DMTER1 DMTR1A DMTR1B DMTER3 DMTER2 DMTALL DMTAL1 DUMPG4 DUMPG3 IDENSI IDENS2 DENSIT DENTEL DENTE0 DENLOK DENTE2 DENTEX DENSI0 DENLOP DENILL DENNAM LDENNA DENN78 LDEN78 LDEN SDENDA SDFTDN EOFON EOFOFF

NOREPD:	SETOM NOREAP
	OUTSTR [ASCIZ/OK, reap-deletions are disabled for now.
/]
	POPJ P,

UNREAP:	MOVEI A,UNRPER			;CLEAR REAP BIT
	JRST SETCLR

REAP:	SKIPA A,[REAPER]		;SET REAP BIT
NODUMP:	MOVEI A,NODTHS			;ADDR OF ROUTINE TO SET/CLEAR BIT
SETCLR:	MOVEM A,NODDSP			;SAVE ADDR
	TLO FL,L.NOD			;SET NODUMP COMMAND
	JRST SETCL2

DUMPGO:	TLZ FL,L.NOD			;SET DUMP COMMAND
	SETOM SWITOK		;rel dump number switch is OK here
SETCL2:	PUSHJ	P,SCAN			;SCAN EVERYTHING!
	SETZM	MTDEV-1			;WATCH THIS KLUGE
	SKIPN	R,DEST			;IS THERE A DESTINATION TERM?
	MOVEI	R,MTDEV-1		;NO DESTINATION. MAKE DEFAULTS
	MOVSI	A,(R)
	HRRI	A,MTDEV
	BLT	A,MTPPN
	HRRZ	R,TBASE			;GET THE BASE ADDRESS OF THE SOURCE
	CAME	R,FSPTR			;SAME AS CURRENT POINTER?
	JRST	DMPG1			;NO. AT LEAST 1 TERM.
	PUSHJ	P,GETBLK		;GET A TERM BLOCK.
	MOVEI	A,ALLFIL+ALLEXT		;GET THE FLAGS
	MOVEM	A,FSEXT(R)		;SAVE THEM. SET FOR DSK:*.*[CURRENT AREA]
	TLNN FL,L.NOD			;IS THIS THE REAL DUMP COMMAND?
	JRST DMPG1			;YES, NO EXPLICIT FILE LIST IS OK
	OUTSTR [ASCIZ /You must specify some files explicitly.  ("*.*" is ok.)
/]
	JRST RESTAR

DMPG1:	MOVE	A,FSPTR			;GET THE FREE POINTER
	MOVEM	A,.JBFF			;SET IT AS .JBFF
	MOVE	A,USRPPN		;THIS IS THE STICKY PPN
	MOVEM	A,STKPPN		;SAVE THE STICKY PPN
	MOVSI	A,'DSK'			;THIS IS THE STICKY DEVICE
	MOVEM	A,STKDEV		;SAVE IT.
	TLNE FL,L.NOD			;NO MAGTAPE FOR NODUMP
	JRST DMPG2
	PUSHJ	P,MTINIW		;Init magtape for writing
	SETZM	CLASS			;CLASS = 0 IS USER DUMP
	SETZM	TAPNO			;ASSUME WE DON'T KNOW WHAT TAPE NUMBER
	PUSHJ	P,TAPHED		;MAKE A TAPE HEADER RECORD.
	SETZM	LASSAV			;NO LAST FILE SAVED.

DMPG2:	HRRZ	R,TBASE			;GET THE (RISING) BASE OF TERM LIST
	CAML	R,FSPTR			;ARE WE BENEATH THE FREE POINTER?
	JRST	DUMPG3			;DONE.
	MOVSI	R,(R)			;GET THE BASE ADDRESS
	HRRI	R,FDEV			;GET THE DESTINATION
	BLT	R,FPPN			;STORE THRU THE PPN
	MOVEI	A,FSLEN			;UPDATE TBASE TO POINT TO NEXT TERM
	ADDM	A,TBASE
	PUSH	P,.JBFF			;SAVE .JBFF

					;PROCESS A SINGLE TERMBLOCK IN DUMP COMMAND
DMTERM:	MOVEI	A,10!DMPBIT!GARBIT	;OPEN THE FILE DEVICE. DON'T CHANGE REFTIM
	SKIPN	B,FDEV			;GET THE FILE DEVICE
	MOVE	B,STKDEV		;USE THE STICKY DEVICE INSTEAD
	MOVEM	B,STKDEV		;SAVE LAST DEVICE USED AS STICKY
	MOVEM	B,DEVNAM		;SAVE HERE FOR DUMP
	MOVEI	C,FIBUF			;ADDRESS OF BUFFER HEADER.
	TLZ	FL,UDPGO		;ASSUME NOT UDP

	MOVE	D,B			;GET SOURCE DEVICE
	DEVCHR	D,
	TLNE	D,DEVDSK		;IS IT A DISK?
	JRST	DMTER1			;YES.
IFE UDPSW,<
	JRST	NOTDSK			;NOT DSK AND ONLY DSK IS LEGAL
>;IFE UDPSW
IFN UDPSW,<
	TLNN	D,DEVUDP		;IS IT A UDP?
	JRST	NOTDSK			;NO. AND NOT DSK EITHER.
	TLO	FL,UDPGO		;SET FOR FUTURE UDP OPERATIONS
	INIUDP	B			;INITIALIZE UDP. DEVICE NAME IN B
	UOPEN	FILE,A			;OPEN THE UDP.
>;IFN UDPSW
DMTER1:
IFN STANSW,<
	OPEN	FILE,A			;ATTEMPT TO OPEN THE DEVICE
	PUSHJ	P,NODEV			;DEVICE IS UNAVAILABLE
	TLNE	FL,UDPGO
	JRST	DMTR1B			;JUMP IF THIS IS THE UDP.
	CHNSTS	FILE,A			;GET THE CHANNEL STATUS FROM UUOCON
	TRNN	A,100			;SKIP IF THIS IS DEVICE SYS
	JRST	DMTR1A			;NOT DEVICE SYS.
	MOVSI	A,'DSK'			;THIS IS SYS:  CHANGE TO DSK:[1,3]
	MOVEM	A,DEVNAM		;DEVICE IS REALLY THE DISK
	MOVEM	A,STKDEV		;SET STICKY DEVICE.
	MOVE	A,['  1  3']		;USE SYS AREA PPN.
	MOVEM	A,FPPN			;SET EXPLICIT PPN.
DMTR1A:
;; BH ;;TLNN FL,L.NOD			;NO BUFFERS FOR NODUMP
	INBUF	FILE,NBUFS		;SOME BUFFERS ARE NEEDED
>;IFN STANSW
DMTR1B:
repeat 0,<
	MOVE	A,FEXT			;GET THE MAJIC BITS
	TRNN	A,ALLFIL+ALLEXT		;ANY WILD FILE NAME?
	MOVEI	A,ALLFIL+ALLEXT		;NO WILD NAME. PICKUP WILD BITS
	SKIPN	FNAM			;IS THERE AN EXPLICIT NAME?
	IORM	A,FEXT			;NO EXPLICIT NAME ADD WILD BITS
>;repeat 0
	MOVEI A,FNAM		;ptr to filename and ext/wild bits
	PUSHJ P,STWILD		;make omitted filename wild, and maybe ext too
	HRRZ	A,FEXT			;GET THE MAJIC BITS
	TRNE	A,ALLMSK
	JRST	DMTALL			;GO OFF TO SELECT FILES.
IFE STANSW,<
	MOVEI A,10
	MOVE B,DEVNAM
	MOVEM B,STRUCT
	MOVEI C,FIBUF
	OPEN FILE,A
	PUSHJ P,NODEV
;; BH ;;TLNN FL,L.NOD			;NO BUFFERS FOR NODUMP
	INBUF FILE,NBUFS
>;IFE STANSW
	MOVE	A,FNAM			;DUMP ONE FILE AND POPJ
	HLLZ	B,FEXT
	SETZ	C,
	SKIPN	D,FPPN
	MOVE	D,STKPPN		;DEFAULT TO STICK PPN
	MOVEM	D,STKPPN		;SAVE STICKY PPN
	MOVEM	D,FPPN			;SAVE IT BACK HERE TOO.
	PUSHJ	P,DMTHIS

IFN UDPSW,<
DMTER3:	TLZN	FL,UDPGO
	JRST	DMTER2			;CLOSE NORMAL DISK.
	UCLOSE	FILE,			;CLOSE UDP
	SETZM	USYNC			;TO CATCH ERRORS.
	JRST	DUMPG4
>;IFN UDPSW

DMTER2:	CLOSE	FILE,NUPACC		;DON'T UPDATE ACCESS DATE
	RELEAS	FILE,
	JRST	DUMPG4


DMTALL:
IFN UDPSW,<
	TLNN	FL,UDPGO		;IS THIS A UDP?
	JRST	DMTAL1			;NO
	PUSHJ	P,UDMALL		;YES. DO WILD SPEC FROM UDP.
	JRST	DMTER3			;NOW CLOSE THE UDP ENTIRELY.
>;IFN UDPSW
DMTAL1:	PUSHJ	P,DMALL			;DUMP WILD TERM.

DUMPG4:	POP	P,.JBFF			;RETURN HERE FROM DMALL
	JRST	DMPG2

DUMPG3:	TLNN FL,L.NOD			;NO MTA FOR NODUMP
	PUSHJ P,MT2REL		;release output tape
	POPJ P,

;Here for IDENSITY nnnn command, select density desired.
IDENSI:	PUSHJ P,DENSI0		;check given density
	 JRST IDENS2		;just report density
	 JRST DENILL		;illegal
	MOVE A,(C)		;get I/O mode for this density
	MOVEM A,INPMOD		;store density's mode for MTINIR/W
IDENS2:	MOVE A,INPMOD
	PUSH P,DENMOD
	MOVEM A,DENMOD		;store our density for typeout routine
	OUTSTR [ASCIZ /Input /]
	PUSHJ P,DENTEL		;type density
	POP P,DENMOD		;restore output density
	POPJ P,

;Here for DENSITY nnnn command, select density desired.
DENSIT:	PUSHJ P,DENSI0		;check given density
	 JRST DENTEL		;none given, just report
	 JRST DENILL		;illegal
	MOVE A,(C)		;get I/O mode for this density
	MOVEM A,DENMOD		;store density's mode for MTINIR/W
;Enter here from MTINIR/W to report density.  Clobbers only A,B,C.
DENTEL:	MOVE A,['MTA0  ']
DENTE0:	PNAME A,		;find out what magtape MTA0 would be
	 JFCL			;no such device?
	OUTSTR [ASCIZ/Density for /]
	PUSH P,FL		;save flags
	TRZ FL,LSTON		;force output to TTY
	PUSH P,A		;save physical device name
	PUSHJ P,SIXOUT		;print device name
	POP P,A
	OUTSTR [ASCIZ/ will be /]
	MOVE C,[-LDENNA,,DENNAM] ;assume 7-track drive, this is semi-aobjn ptr
	CAMN A,['MTU0  ']	;is it a TU-78?
	MOVE C,[-LDEN78,,DENN78] ;yes, different mapping between mode and density
	MOVE A,DENMOD		;get current mode
DENLOK:	CAMN A,(C)		;is this the mode we're set to use
	JRST DENTE2		;yes
	ADDI C,1		;must advance RH by extra word per density entry
	AOBJN C,DENLOK		;no, keep looking
	OUTSTR [ASCIZ/ unknown density!!??  This shouldn't have happened!!
/]
	JRST DENTEX

DENTE2:	MOVE A,1(C)		;get actual density in bpi
	PUSHJ P,DECOUT		;type decimal number from A
	OUTSTR [ASCIZ/ bpi.
/]
DENTEX:	POP P,FL		;restore flags
	POPJ P,

;Scan density given.  Direct return if none, skip if bad, else double skip if OK.
DENSI0:	MOVE A,SAVDEL		;get back delimiter
	CAIE A,12
	CAIN A,ALTMOD
	POPJ P,			;report current density
	AOS (P)			;we'll single or double skip now
	PUSHJ P,RDNUMB		;get number into B, skips to end of line (LF)
	MOVE C,[-LDEN,,DENNAM]	;semi-aobjn ptr (RH counts by 2's) to densities
DENLOP:	CAMN B,1(C)		;right density?
	JRST CPOPJ1		;yes, set I/O mode for it
	ADDI C,1		;advance RH of semi-aobjn ptr
	AOBJN C,DENLOP		;loop if any more densities
	POPJ P,			;not in table

DENILL:	OUTSTR [ASCIZ/Illegal density; must be 6250, 1600, 800, 556 or 200./]
	JRST ILLEG1

;The next two tables must be consecutive.
;Each table contains two-word entries consisting of:
; (1) I/O mode for given density; (2) density.
RADIX 5+5
DENNAM:	DEN200		;7-track magtape densities
	200
	DEN556
	556
	DEN800
	800
LDENNA==.-DENNAM	;7-track magtape densities
DENN78:	DE1600		;TU-78 densities
	1600
	DE6250
	6250
	DE1601		;alternate form (from DEN 200) for 1600 bpi
	1600
LDEN78==.-DENN78	;TU-78 densities
LDEN==.-DENNAM		;all possible densities (both table above)
RADIX 4+4

SDENDA:	SETOM DENDAM
	OUTSTR [ASCIZ/OK, but you better not be doing this for SU-AI!
/]
	POPJ P,

;Here from PDUMP1 and PICKUP to select default density for system-class dump,
;unless user said he really wanted non-default density (DENDAM cmd).
SDFTDN:	SKIPE DENDAM		;skip unless really want specified density
	POPJ P,			;use any density user specified!
	MOVEI B,DEN800
	EXCH B,DENMOD		;set default tape density (800 or 6250)
	CAME B,DENMOD		;see if user had asked for a different one
	OUTSTR [ASCIZ/
*** Ignoring non-default density request, since this is a system-class dump. ***
*** If you really need non-default density, see a wizard. ***

/]
	POPJ P,

EOFON:	SETOM TELEOF		;report input EOFs hereafter
	POPJ P,

EOFOFF:	SETZM TELEOF		;don't report input EOFs hereafter
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     subttl	dump one file to tape	 ; DMTHIS DMPLKP DMTHIX DMTHX0 DMTHIY NOMTA5 NODTHS STANOD NSTNOD NSTNO1 REAPER UNRPER DMRED0 DMREDO DMRED1 DMRED2 DMRED3 NOMTA7

DMTHIS:	MOVEM	A,FILINF+DDNAM		;HERE FROM DMALL TO DUMP ONE FILE.
	MOVEM	B,FILINF+DDEXT
	MOVEM	D,FILINF+DDPPN
	MOVE	X,[A,,FILBLK]
	BLT	X,FILBLK+3
	TRZ	FL,SAFETY
IFN UDPSW,<
	TLNE	FL,UDPGO
	ULOOK	FILE,A
>;IFN UDPSW
IFE STANSW,<
	PUSHJ P,DMPLKP			;MAKE SUBR OF LOOKUP CODE SO
	 POPJ P,			;SYSTEM DUMPS CAN USE IT TOO
	JRST DMTHIX

DMPLKP:	MOVEM A,LKBLK+.RBNAM
	MOVEM B,LKBLK+.RBEXT
	MOVEM D,LKBLK+.RBPPN
	LOOKUP FILE,LKBLK
>;IFE STANSW
IFN STANSW,<
	LOOKUP	FILE,A			;ATTEMPT TO FIND FILE.
>;IFN STANSW
	JRST	[PUSHJ P,LCHECK		;CANNOT BE FOUND
		JFCL
		POPJ P,]		;FLUSH THIS TERMBLOCK
IFE STANSW,<
	MOVE B,LKBLK+.RBEXT
	MOVEM B,FILINF+DDEXT
	MOVE C,LKBLK+.RBPRV
	MOVEM C,FILINF+DDPRO
	MOVE D,LKBLK+.RBSIZ
	MOVEM D,FILINF+DDLNG
	ANDI B,77777
	MOVEM B,FILINF+DREFTM
	MOVEI B,1
	MOVEM B,FILINF+DDOFFS
	MOVE B,LKBLK+.RBNCA
	MOVEM B,FILINF+DDMPTM
	MOVE B,LKBLK+.RBDEV
	MOVEM B,FILINF+DSATID
	MOVE B,LKBLK+.RBAUT
	MOVEM B,FILINF+DQAUT
	MOVE B,LKBLK+.RBVER
	MOVEM B,FILINF+DQVER
	JRST CPOPJ1
>;IFE STANSW
IFN STANSW,<
	MOVEM	C,FILINF+DDPRO
	MOVS	D,D
	MOVMM	D,FILINF+DDLNG
	TLNE	FL,UDPGO		;CAN'T GET THIS FROM THE SYSTEM IF UDP.
	JRST	DMTHIX			;SO AVOID THIS SHIT.
	MTAPE	FILE,['GODMOD'
			   14
		      IOWD 20,FILINF]
	JFCL				;CAN'T LOSE. IT SAYS HERE
	MTAPE	FILE,RDOFFS		;READ OFFSET FROM THE OFFSET BLOCK.
	MOVE	A,RDOFFS+2		;GET THE OFFSET NUMBER.
	MOVEM	A,FILINF+DDOFFS		;SAVE IT IN THE RETRIEVAL.
>;IFN STANSW
DMTHIX:	MOVE	D,[FILINF+DDNAM,,A]	;PICK UP THE FILE NAME AGAIN
	BLT	D,D
	PUSHJ	P,TYFIL			;TYPE THE FILE NAME - NO CR
	TLNN FL,L.NOD
	JRST DMTHX0			;JUMP IF DUMP COMMAND
	OUTSTR CRLF			;IF NOT DUMP COMMAND, TYPE CRLF
	MOVE	D,[FILINF+DDNAM,,A]	;PICK UP THE FILE NAME AGAIN
	BLT	D,D
	JRST @NODDSP			;PROCESS NODUMP COMMAND

DMTHX0:	PUSHJ P,DPYSER			;DISPLAY NAME, PPN, AND NO. OF FEET
	 FILINF+DDNAM,,DPYFIL
	TLZ	FL,IGNEOT
IFN STANSW,<
	TLNE	FL,UDPGO		;UDP?
	JRST	DMTHIY			;YES. WE SKIP THE OFFSET STUFF.
	MOVEI	A,2
	SUB	A,FILINF+DDOFFS
	USETI	FILE,(A)		;USETI TO THE FIRST REAL RECORD.
>;IFN STANSW
DMTHIY:	PUSHJ P,DUMP
	 JRST DMRED0			;HAVE TO DO IT OVER ON A NEW TAPE
	PUSHJ P,MT2CLZ		;write an EOF
	MOVE	A,WRCSZ			;get record size
	MOVEM	A,WC
	SETZM	MTFILN
	PUSHJ P,MT2CTS		;skip if EOF written OK, remember where written
	 JRST DMREDO		;physical end of tape
NOMTA5:	MOVE	A,[FILBLK,,LASSAV]
	BLT	A,LASSAV+3		;SAVE THE NAME OF THE FILE WE JUST FINISHED
	OUTSTR	CRLF			;AFTER THE FILE IS OUT, TYPE CR.
	POPJ	P,

NODTHS:
IFN STANSW,<
	TLO C,400000			;THIS IS THE SAIL NO-DUMP BIT
STANOD:	MOVE D,FILINF+DDPPN
	MOVE W,FILINF+DREFTM		;LONG RENAME! BH 7/7/79
	MOVE X,FILINF+DDMPTM		;DITTO
	RENAME FILE,A
	 CAIA				;failed
	POPJ P,
	OUTSTR [ASCIZ/Failed: /]
	PUSH P,A
	PUSH P,B
	PUSH P,C
	PUSH P,D
	PUSHJ P,TYFIL			;type filename
	POP P,D
	POP P,C
	POP P,B
	POP P,A
	OUTSTR [ASCIZ/ (maybe someone is reading the file).
/]
	POPJ P,
>;IFN STANSW
IFE STANSW,<
	MOVSI D,4000			;THIS IS OUR NO-DUMP BIT
NSTNOD:	IORM D,LKBLK+.RBNCA		;IN A DIFFERENT WORD TOO
NSTNO1:	RENAME FILE,LKBLK
	 JFCL
	POPJ P,
>;IFE STANSW

REAPER:	MOVSI D,REAPBT			;DELETE-AFTER-DUMPING BIT
IFN STANSW,<
	IORM D,FILINF+DDMPTM		;SET IT IN DUMP WORD
	JRST STANOD			;JOIN SAIL NODUMP CODE
>;IFN STANSW
IFE STANSW,<
	JRST NSTNOD			;JOIN NON-SAIL CODE
>;IFE STANSW

UNRPER:	MOVSI D,REAPBT
IFN STANSW,<
	ANDCAM D,FILINF+DDMPTM		;CLEAR DELETE-AFTER-DUMPING BIT
	JRST STANOD
>;IFN STANSW
IFE STANSW,<
	ANDCAM D,LKBLK+.RBNCA		;CLEAR BIT
	JRST NSTNO1
>;IFE STANSW

DMRED0:	PUSHJ P,MT2CLZ		;ATTEMPT TO END FILE 
	PUSHJ P,MT2CT2		;report the output EOF written, don't count it
DMREDO:	OUTSTR	[ASCIZ/	Not saved. - Physical end of tape.
/]
IFN DBGSW,<
	SKIPE	DBGNTP
	JRST	NOMTA7			;NO TAPE OPERATIONS IF NOT USING IT
>;IFN DBGSW
	PUSHJ	P,MT2REL		;RELINQUISH THE MAG TAPE
	PUSHJ	P,MINIT1		;INIT MAGTAPE for reading, ONLY ONE BUFFER
DMRED1:	PUSHJ	P,MTABKF
	PUSHJ	P,MTABKF
	PUSHJ	P,MTASKF
	SETZM	TIBUF+2			;ZERO THE DATA COUNT.
	PUSHJ	P,RDFIL			;READ THE FILE NAME OFF THE TAPE.
	 JRST .-1		;saw a tape header/trailer, keep going
	MOVE	A,FILINF+DDNAM
	HLLZ	B,FILINF+DDEXT
	MOVE	C,FILINF+DDPPN
	SKIPN	LASSAV
	JRST	DMRED2
	CAMN	A,LASSAV
	CAME	B,LASSAV+1
	JRST	DMRED1
	MOVE	A,FILINF+DDPPN
	CAME	A,LASSAV+3
	JRST	DMRED1
	JRST	DMRED3

DMRED2:	CAMN	A,FILBLK
	CAME	B,FILBLK+1
	JRST	DMRED3			;LOSE.
	CAME	C,FILBLK+3
	JRST	DMRED3
	PUSHJ	P,MTABKF		;BACKUP TO FRONT
DMRED3:	PUSHJ	P,MTASKF		;SKIP PAST PRESENT MT FILE.
	PUSHJ	P,MTAREL		;
	PUSHJ	P,MTINIW		;INIT WITH 3 BUFFERS AGAIN, for writing
	TLO	FL,IGNEOT		;TURN ON THE IGNORE EOT INDICATOR
	PUSHJ	P,TAPTAI		;WRITE A TAPE TAIL
	TLZ	FL,IGNEOT		;
	PUSHJ	P,MT2REW		;REWIND THE TAPE
NOMTA7:	CLOSE	FILE,NUPACC		;WILL LOOK THIS UP AGAIN, LATER.
	OUTSTR	[ASCIZ/Mount the next tape and type CONTINUE
/]
	EXIT	1,			;CALL THE EXIT FROM WHICH WE CAN CONTINUE
	PUSHJ	P,TAPHED		;WRITE ANOTHER TAPE HEADER.
	MOVE	D,[FILBLK,,A]		;RESTORE FILE NAME TO A,B,D
	BLT	D,D
	JRST	DMTHIS			;AND START FROM THE TOP.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           subttl	process a dump term with wild specification.	 ; DMALL DMALLD DMALL1 DMALL2 DMALL3 DMALL4 DMALL5 DMALL6 DMALL8 DMALL9 DMAL10 DMAL11

IFN STANSW,<
DMALL:
>;IFN STANSW

;;NON-SAIL VERSION THIS IS THE CODE FOR ONE STRUCTURE ONLY

DMALLD:
IFE STANSW,<
	MOVEM B,STRUCT
	MOVEI A,10
	MOVEI C,FIBUF
	OPEN FILE,A			;WE OPEN EACH STR SEPARATELY
	 PUSHJ P,NODEV
	TLNN FL,L.NOD
	INBUF FILE,NBUFS
	HRRZ A,FEXT			;RALPH EXPECTS THIS
>;IFE STANSW
	TRNN	A,ALLPRJ+ALLPRG		;WILD PPN?
	JRST	DMAL11			;NO. PREPARE TO DUMP ONE PPN WILD.
	MOVE	A,GOD			;READ THE MFD ON THE FILE CHANNEL.
	MOVSI	B,'UFD'
	SETZ	C,
	MOVE	D,GOD
	TRZ	FL,SAFETY
	MOVE	X,[A,,FILBLK]
	BLT	X,FILBLK+3
IFE STANSW,<
	MOVEM A,LKBLK+.RBNAM
	MOVEM B,LKBLK+.RBEXT
	SETZM LKBLK+.RBPRV
	MOVEM D,LKBLK+.RBPPN
	LOOKUP FILE,LKBLK
>;IFE STANSW
IFN STANSW,<
	LOOKUP	FILE,A
>;IFN STANSW
	JRST	[PUSHJ P,LCHECK		;LOOKUP FAILURE
		JFCL
		RELEAS	FILE,
		POPJ	P,]		;FLUSH THIS TERM
	MOVE	Q,.JBFF			;PICKUP .JBFF
IFN STANSW,<
	MOVS	D,D			;-WC IN D
	MOVEI	R,UFDN			;SIZE OF ONE MFD/UFD ENTRY
>;IFN STANSW
IFE STANSW,<
	MOVN D,LKBLK+.RBSIZ
	MOVEI R,2
>;IFE STANSW
	IDIVM	D,R			;DIVIDE TO MAKE COUNT OF UFD'S
DMALL1:	PUSHJ	P,DFREAD		;READ.
	JUMPE	A,DMALL3
	CAMG	Q,.JBREL
	JRST	DMALL2
	MOVE	B,.JBREL
	ADDI	B,2000
	CORE	B,
	JRST	NOCORE
DMALL2:	MOVEM	A,(Q)
	PUSHJ	P,DFREAD
	HLRZ	A,A
	CAIE	A,'UFD'
	SUBI	Q,1
	AOJA	Q,DMALL4

DMALL3:	PUSHJ	P,DFREAD
DMALL4:
IFN STANSW,<
	MOVE	D,[-UFDN+2,,2]
DMALL5:	PUSHJ	P,DFREAD		;FLUSH REST OF DIRECTORY ENTRY
	AOBJN	D,DMALL5
>;IFN STANSW
	AOJL	R,DMALL1
	CLOSE	FILE,			;RELEASE THE MFD
	MOVE	A,.JBFF			;GET OLD .JBFF INTO A
	EXCH	Q,.JBFF			;OLD .JBFF IN Q. .JBFF SET RIGHT
	SUB	A,.JBFF			;A HAS -WC.
	HRL	Q,A
	MOVEM	Q,MFDPTR		;-WC,,MA
;;	MOVE	Q,MFDPTR		;OK. HERE WE LOOK FOR MATCHING UFD
;; RE ABOVE: DUH..  -BH
;OK. HERE WE LOOK FOR MATCHING UFD
DMALL6:	HRRZ	D,FEXT			;SET UP WITH THE BITS
	HLRZ	A,FPPN
	HRRZ	B,FPPN
	TRNE	D,ALLPRJ		;WILL ANY PROJECT DO?
	JRST	DMALL8			;YES.
	HLRZ	C,(Q)			;GET A PRJ
	CAIE	C,(A)
	JRST	DMAL10
DMALL8:	TRNE	D,ALLPRG
	JRST	DMALL9
	HRRZ	C,(Q)
	CAIE	C,(B)
	JRST	DMAL10
DMALL9:	MOVE	A,(Q)			;SET UP WITH UFD NAME
	PUSH	P,Q			;DON'T CLOBBER Q
	PUSH	P,.JBFF
	PUSHJ	P,DMONE			;DO ONE USER
	POP	P,.JBFF
	POP	P,Q			;RESTORE Q
DMAL10:	AOBJN	Q,DMALL6		;LOOP - REINTIALIZE A,B,D
	RELEAS	FILE,
	POPJ	P,

DMAL11:	PUSH	P,.JBFF
	PUSHJ	P,D1PPN
	POP	P,.JBFF
	RELEAS	FILE,
	POPJ	P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       subttl	wildcards for non-sail version, does multiple structures	 ; DMALL NXTSTR DMALLA DMALLX DMALS1 DMALLS

IFE STANSW,<
DMALL:	SETZM GOBBLK		;ASSUME SYS: OR ERSATZ U.F.N.
	MOVS B,DEVNAM		;WHAT A BUM
	TLNE B,-1		;** THIS IS NOT STRICTLY GENERAL
	JRST DMALLS		;** ASSUMES 4 OR MORE CHARS IS SINGLE STR
	CAIN B,'DSK'
	SETOM GOBBLK		;MAKE GOBSTR DO JOBSTR
	CAIN B,'ALL'
	JRST DMALLA		;USE SYSSTR WHICH IS DIFFERENT FORMAT OF COURSE
	SETOM GOBBLK+2		;ELSE ASK GOBSTR FOR SYS SEARCH LIST
	PUSHJ P,.+1		;OFFICIAL STANDARD PROGRAMMING TECHNIQUE 87
	MOVEI B,GOBBLK		;WE'LL JRST HERE EACH TIME THROUGH
	GOBSTR B,		;ASK SYS FOR NEXT STRUCTURE
	 JRST DMALS1		;NO UUO, ASSUME SINGLE STR
	SKIPN B,GOBBLK+2	;LOOK AT THE ANSWER
	JRST DMALLX		;STUPID FENCE IS END FOR US
NXTSTR:	AOJE B,DMALLX		;LIKEWISE END OF LIST
	SUBI B,1		;GET BACK STR NAME
	PUSHJ P,DMALLD		;DO WILD STUFF FOR THIS STR
	JRST @(P)		;GET NEXT STR

DMALLA:	SETZM GOBBLK+2		;INITIAL SYSSTR ARG IS ZERO
	PUSHJ P,.+1		;NOT -1 LIKE THE OTHERS, YAY, DEC
	MOVE B,GOBBLK+2		;COME HERE FOR EACH STR
	SYSSTR B,
	 JRST DMALS1
	MOVEM B,GOBBLK+2	;MIGHT AS WELL SAVE IT HERE AS ANYWHERE
	JUMPN B,NXTSTR
DMALLX:	POP P,(P)		;POP OFF LOOP ADDRESS
	POPJ P,

DMALS1:	POP P,(P)		;ABORT FANCY STRUCTURE SEARCH
DMALLS:	MOVE B,DEVNAM		;JUST PASS THE NAME THE USER TYPED
	JRST DMALLD		; ON TO RALPH
>;ENDS IFE STANSW, ENTIRE PAGE
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        subttl	process wild file names inside one ufd	 ; D1PPN DMONE DMONE1 DMONE4 DMONE2 DMONE3

D1PPN:	SKIPN	A,FPPN			;PICKUP THE EXPLICIT PPN.
	MOVE	A,STKPPN		;NONE EXPLICIT. USE THE STICKY ONE.
	MOVEM	A,STKPPN		;STORE NEW STICKY PPN.
DMONE:	MOVEM	A,ONEPPN		;SAVE THE NAME OF THIS USER.
	MOVEI	A,10			;MODE 10
	MOVE	B,STRUCT		;THE CURRENT DEVICE, WHATEVER
	MOVEI	C,UFDBUF		;AN INPUT BUFFER HEADER FOR THE UFD.
	OPEN	UFD,A			;OPEN THE CHANNEL
	PUSHJ	P,NODEV			;THIS PROBABLY DOESN'T EVER HAPPEN
	MOVE	A,ONEPPN
	MOVSI	B,'UFD'
	SETZ	C,
	MOVE	D,GOD
	TRZ	FL,SAFETY		;THIS IS A REAL LOOKUP
	MOVE	X,[A,,FILBLK]
	BLT	X,FILBLK+3
	LOOKUP	UFD,A			;ATTEMPT TO SEEK FILE.
	JRST	[PUSHJ P,LCHECK
		JFCL
		POPJ P,]
DMONE1:	PUSHJ	P,UFDRD			;READ FROM THE UFD.
	JRST	DMONE3			;ALL DONE WITH THIS UFD
	PUSH	P,A			;SAVE FILE NAME
	PUSHJ	P,UFDRD	
	JFCL
IFN STANSW,<
	HLLZ	A,A			;EXTENSION ONLY
	PUSH	P,A			;SAVE EXTENSION
	MOVE	D,[-UFDN+2,,2]
DMONE4:	PUSHJ	P,UFDRD			;FLUSH REST OF DIRECTORY ENTRY
	JFCL
	AOBJN	D,DMONE4
	POP	P,B			;EXTENSION INTO B
>;IFN STANSW
IFE STANSW,<
	HLLZ B,A
>;IFE STANSW
	POP	P,A			;FILE NAME INTO A
	JUMPE	A,DMONE1		;FILES WITH 0 NAMES AREN'T THERE.
IFN STANSW,<
;				;Don't flush RPG any more (09/04/78 EJG)
;	CAMN	B,['RPG   ']		;AT STANFORD DON'T DUMP RPG FILES
;	JRST	DMONE1
>;IFN STANSW
	HRRZ	X,FEXT			;GET THE SPECIAL BITS
	TRNN	X,ALLFIL		;WILL ANY NAME WORK?
	CAMN	A,FNAM			;NO. IS THIS THE RIGHT NAME?
	JRST	.+2			;WE'LL TAKE THIS NAME
	JRST	DMONE1			;FLUSH THIS NAME
	HLLZ	C,FEXT			;GET THE EXTENSION DESIRED.
	TRNN	X,ALLEXT		;ANY EXTENSION?
	CAMN	B,C			;NEED MATCH. DOES IT MATCH?
	JRST	.+2			;WE'LL TAKE THIS FILE
	JRST	DMONE1			;FLUSH THIS FILE.
DMONE2:	MOVE	D,ONEPPN		;HERE TO TAKE NAME FROM A,B,D
	PUSHJ	P,DMTHIS		;DUMP ONE FILE.
IFE STANSW,<
	CLOSE FILE,NUPACC		;DON'T UPDATE ACCESS DATE
>;IFE STANSW
	JRST	DMONE1			;LOOP

DMONE3:	CLOSE	UFD,
	RELEAS	UFD,
	POPJ	P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    subttl	dump wild specification from udp.	 ; UDMALL UDMAL1 UDML1A UDML1B UDMAL2 UDMAL3 UDIRER

IFN UDPSW,<

UDMALL:
	MOVEI	A,10				;HERE WE 'LOOKUP' THE DIRECTORY
	MOVE	B,DEVNAM
	MOVEI	C,UFDBUF
	UOPEN	UFD,A				;OPEN A UDP CHANNEL
	HALT	.+1				;IMPOSSIBLE RETURN
	PUSHJ	P,NODEV				;CAN'T HAPPEN
	ULOOK	UFD,400000+A			;'LOOKUP' THE DIRECTORY
	HALT	.+1				;IMPOSSIBLE RETURN
	JRST	UDIRER				;UDP DIRECTORY ERROR.
UDMAL1:	PUSHJ	P,UUFDRD			;READ FILE NAME
	JRST	UDMAL3				;DIRECTORY EMPTY.
	PUSH	P,A				;SAVE NAME
	PUSHJ	P,UUFDRD
	JFCL
	HLLZ	A,A				;EXTENSION ONLY.
	PUSH	P,A				;SAVE EXTENSION
	PUSHJ	P,UUFDRD			;DATE/TIME.
	JFCL
	PUSHJ	P,UUFDRD			;PPN
	JFCL
	PUSH	P,A				;SAVE PPN
	PUSHJ	P,UUFDRD			;READ WORD COUNT
	JFCL
	PUSHJ	P,UUFDRD			;READ UNUSED WORD
	JFCL
	POP	P,D				;RESTORE THE PPN
	POP	P,B				;RESTORE THE EXT
	POP	P,A				;AND THE FILE NAME
	JUMPE	A,UDMAL1			;FILES WITH 0 NAMES AREN'T
;				;Don't flush RPG any more (09/04/78 EJG)
;	CAMN	B,['RPG   ']			;RPG FILES NEVER
;	JRST	UDMAL1
	HRRZ	X,FEXT				;GET THE MAJIC BITS
	TRNN	X,ALLFIL			;WILL ANY NAME DO?
	CAMN	A,FNAM				;NOT ANY NAME. SKIP UNLESS RIGHT
	JRST	.+2				;THE NAME IS OK
	JRST	UDMAL1				;NAME REJECTED
	HLLZ	C,FEXT				;GET THE EXTENSION
	TRNN	X,ALLEXT			;WILL ANY EXTENSION DO?
	CAMN	B,C				;NOT ANY EXTENSION. MATCHES?
	JRST	.+2				;EXTENSION IS OK
	JRST	UDMAL1				;REJECT EXTENSION.
	TRC	X,ALLPRJ!ALLPRG	
	TRCE	X,ALLPRJ+ALLPRG			;ANY PPN WILL DO?
	CAMN	D,FPPN				;NO. RIGHT PPN?
	JRST	UDMAL2				;PPN IS OK.
	TRNN	X,ALLPRJ!ALLPRG			;ANY WILD PPN AT ALL?
	JRST	UDMAL1				;NO. REJECT FOR PPN.
	TRNN	X,ALLPRJ			;WILD PROJECT?
	JRST	UDML1A				;NO. JUST WILD PROGRAMMER
	HRRZ	C,D				;GET PROGRAMMER
	HRRZ	X,FPPN				;GET PROGRAMMER
	JRST	UDML1B
UDML1A:	HLLZ	C,D				;GET PROJECT PART
	HLLZ	X,FPPN
UDML1B:	CAME	C,X				;MATCHES?
	JRST	UDMAL1				;NO.
UDMAL2:	PUSHJ	P,DMTHIS
	JRST	UDMAL1				;LOOK FOR MORE

UDMAL3:	UCLOSE	UFD,
	POPJ	P,

UDIRER:	OUTSTR	[ASCIZ/ERROR FROM LOOKUP OF UDP DIRECTORY
/]
	HALT	CPOPJ
>;IFN UDPSW
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       subttl	copy old udp to new udp	 ; UDPCOP CUDMAL CUDML1 CUDML3 CDMTHS ECONT RWLOOP RWEOF CMDTHT READ1 WRITE1 ECHECK EFAIL

IFN UDPCSW,<
UDPCOP:	
	PUSH	P,.JBFF			;SAVE .JBFF
	MOVE	B,['UDP1  ']
	MOVSI	C,TOBUF
	MOVEI	A,10
	OPEN	MTA,A
	PUSHJ	P,NODEV
	OUTBUF	MTA,22

	MOVEI	A,10!DMPBIT!GARBIT	;OPEN THE FILE DEVICE. DON'T CHANGE REFTIM
	MOVE	B,['UDP2  ']		;GET THE FILE DEVICE
	MOVEM	B,STKDEV		;SAVE LAST DEVICE USED AS STICKY
	MOVEM	B,DEVNAM		;SAVE HERE FOR DUMP
	MOVEI	C,FIBUF			;ADDRESS OF BUFFER HEADER.
	TLO	FL,UDPGO		;ASSUME UDP
	INIUDP	B			;INITIALIZE UDP. DEVICE NAME IN B
	UOPEN	FILE,A			;OPEN THE UDP.
	JFCL
	PUSHJ	P,NODEV			;DEVICE IS UNAVAILABLE
	PUSHJ	P,CUDMAL		;DO *.*[*,*] FROM UDP INPUT
	UCLOSE	FILE,			;CLOSE UDP
	SETZM	USYNC			;TO CATCH ERRORS.
	POP	P,.JBFF			;RETURN HERE FROM DMALL
	PUSHJ	P,MTAREL		;this isn't really a magtape!
	POPJ	P,

CUDMAL:
	MOVEI	A,10				;HERE WE 'LOOKUP' THE DIRECTORY
	MOVE	B,DEVNAM
	MOVEI	C,UFDBUF
	UOPEN	UFD,A				;OPEN A UDP CHANNEL
	HALT	.+1				;IMPOSSIBLE RETURN
	PUSHJ	P,NODEV				;CAN'T HAPPEN
	ULOOK	UFD,400000+A			;'LOOKUP' THE DIRECTORY
	HALT	.+1				;IMPOSSIBLE RETURN
	JRST	UDIRER				;UDP DIRECTORY ERROR.
CUDML1:	PUSHJ	P,UUFDRD			;READ FILE NAME
	JRST	CUDML3				;DIRECTORY EMPTY.
	PUSH	P,A
	PUSHJ	P,UUFDRD
	JFCL
	HLLZ	A,A				;EXTENSION ONLY.
	PUSH	P,A				;SAVE EXTENSION
	PUSHJ	P,UUFDRD			;DATE/TIME.
	JFCL
	PUSHJ	P,UUFDRD			;PPN
	JFCL
	PUSH	P,A
	PUSHJ	P,UUFDRD			;READ WORD COUNT
	JFCL
	PUSHJ	P,UUFDRD			;READ UNUSED WORD
	JFCL
	POP	P,D				;RESTORE THE PPN
	POP	P,B				;RESTORE THE EXT
	POP	P,A				;AND THE FILE NAME
	JUMPE	A,CUDML1			;FILES WITH 0 NAMES AREN'T
	PUSHJ	P,CDMTHS		;DUMP ONE FILE TO NEW UDP
	JRST	CUDML1				;LOOK FOR MORE

CUDML3:	UCLOSE	UFD,
	POPJ	P,

CDMTHS:	MOVEM	A,FILINF+DDNAM			;HERE TO COPY ONE FILE.
	MOVEM	B,FILINF+DDEXT
	MOVEM	D,FILINF+DDPPN
	MOVE	X,[A,,FILBLK]
	BLT	X,FILBLK+3
	TRZ	FL,SAFETY
	ULOOK	FILE,A
	JFCL	
	JRST	[PUSHJ P,LCHECK		;CANNOT BE FOUND
		JFCL
		POPJ P,]		;FLUSH THIS TERMBLOCK
	MOVEM	C,FILINF+DDPRO
	MOVEM	C,FILBLK+3
	MOVE	D,[FILINF+DDNAM,,A]	;PICK UP THE FILE NAME AGAIN
	BLT	D,D
	PUSHJ	P,TYFIL			;TYPE THE FILE NAME - NO CR

;ENTER THE FILE ON THE 'MTA' AND WRITE IT!
ECONT:	MOVE	D,[FILINF+DDNAM,,A]	;TRY AGAIN AFTER MAKING MFD
	BLT	D,D
	ENTER	MTA,A			;
	JRST	ECHECK			;ERROR CHECK

RWLOOP:
	SOSG	FIBUF+2			;IS THERE DATA IN BUFFER?
	JSR	READ1			;READ FROM DISK FILE
	ILDB	A,FIBUF+1		;LOAD A WORD FROM THE FILE.
	SOSG	TOBUF+2
	JSR	WRITE1
	IDPB	A,TOBUF+1
	SOSG	FIBUF+2			;IS THERE DATA IN BUFFER?
	JSR	READ1			;READ FROM DISK FILE
	ILDB	A,FIBUF+1		;LOAD A WORD FROM THE FILE.
	SOSG	TOBUF+2
	JSR	WRITE1
	IDPB	A,TOBUF+1
	SOSG	FIBUF+2			;IS THERE DATA IN BUFFER?
	JSR	READ1			;READ FROM DISK FILE
	ILDB	A,FIBUF+1		;LOAD A WORD FROM THE FILE.
	SOSG	TOBUF+2
	JSR	WRITE1
	IDPB	A,TOBUF+1
	SOSG	FIBUF+2			;IS THERE DATA IN BUFFER?
	JSR	READ1			;READ FROM DISK FILE
	ILDB	A,FIBUF+1		;LOAD A WORD FROM THE FILE.
	SOSG	TOBUF+2
	JSR	WRITE1
	IDPB	A,TOBUF+1
	JRST	RWLOOP

RWEOF:	UCLOSE	FILE,
	JFCL
	CLOSE	MTA,
	MOVE	D,[FILINF+DDNAM,,A]
	BLT	D,D
	RENAME	MTA,A			;RENAME TO OLD CREATION DATE
	OUTSTR	[ASCIZ/ (RENAME TO UPDATE DATE OF CREATION FAILED) /]
CMDTHT:	OUTSTR	CRLF			;AFTER THE FILE IS OUT, TYPE CR.
	POPJ	P,

READ1:	0
	UIN	FILE,
	JRST	@READ1			;WIN
	JRST	RWEOF			;END OF FILE.

WRITE1:	0
	OUT	MTA,
	JRST	@WRITE1
	OUTSTR	[ASCIZ/OUTPUT ERROR!
/]
	HALT	@WRITE1

ECHECK:
	HRRZ	B,B			;LOOKUP CODE.
	CAIE	B,1			;IS CODE SPECIAL?
	JRST	EFAIL			;ENTER FAILURE
	OUTSTR	[ASCIZ/	MAKING UFD FOR /]
	MOVE	A,FILINF+DDPPN
	PUSHJ	P,PPNOUT
	MOVE	A,FILINF+DDPPN
	MOVSI	B,'UFD'
	MOVSI	C,555000
	MOVE	D,GOD
	ENTER	MTA,A
	JRST	LCILU1			;LOSE MESSAGE
	CLOSE	MTA,
	JRST	ECONT

EFAIL:	OUTSTR	[ASCIZ/ENTER FAILURE CODE = /]
	ADDI	B,"0"
	OUTCHR	B
	OUTSTR	[ASCIZ/TYPE CONTINUE TO TRY NEXT FILE
/]
	HALT	CMDTHT
>;IFN UDPCSW
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      subttl	dump kmc udps ; KMCDMP KMCDM1 KMCDM2 KMCDM4 KMCDM3 DMPKMC KMRED0 KMREDO KMRED1 KMRED2 KMRED3 KMCBUF KMCERR KMCER1

IFN KMCSW,<
KMCDMP:	MOVE	B,['UDP1  ']
	DEVCHR	B,
	TLNE	B,200000		;IS THIS A NEW STYLE?
	JRST	KMCERR
	PUSHJ	P,MTINIW		;Init the magtape for writing
	SETZM	CLASS			;CLASS = 0 IS USER DUMP
	SETZM	TAPNO			;ASSUME WE DON'T KNOW WHAT TAPE NUMBER
	PUSHJ	P,TAPHED		;MAKE A TAPE HEADER RECORD.
	SETZM	LASSAV			;NO LAST FILE SAVED.
	MOVEI	A,17
	MOVE	B,['UDP1  ']
	MOVEI	C,0
	OPEN	FILE,A
	PUSHJ	P,NODEV
;HERE WE READ THE DIRECTORY TRACK
	INPUT	FILE,[-4440,,KMCBUF-1
		1]

	MOVE	A,['KMCDIR']
	MOVEI	B,4440
	MOVEI	C,KMCBUF
	PUSHJ	P,DMPKMC
;NOW SETUP TO DUMP EACH FILE.
	SKIPLE	A,KMCBUF		;THE NUMBER OF FILES
	CAILE	A,2216			;MAX MUMBER
	JRST	KMCER1			;FOO.
	MOVN	A,A			;-NUMBER OF FILES
	MOVSI	A,(A)
	HRRI	A,KMCBUF+4		;ADDRESS OF THE FIRST FILE
KMCDM1:	SKIPN	(A)
	JRST	KMCDM3			;NO NAME THERE
	SKIPG	1(A)
	JRST	KMCDM4
	PUSH	P,A			;SAVE INDEX
	HLRZ	B,1(A)			;+WC INTO B
	MOVN	C,B			;-WC INTO C
	HRLZ	C,C			;-WC INTO LH. OF C
	MOVE	X,.JBFF			;ADDRESS WE CAN START AT
	ADD	X,B			;LAST ADDRESS NEEDED
	CAMGE	X,.JBREL
	JRST	KMCDM2
	CORE	X,
	JRST	NOCORE
KMCDM2:	HRR	C,.JBFF			;-WC,,FIRST ADDRESS
	SUBI	C,1			;ADJUST TO MAKE IOWD
	HRRZ	D,1(A)			;TRACK NUMBER IN D
	INPUT	FILE,C			;READ ENTIRE FILE INTO CORE
	MOVE	A,(A)			;FILE NAME INTO A
	MOVE	C,.JBFF			;FILE ADDRESS INTO C
	PUSHJ	P,DMPKMC
	POP	P,A
	JRST	KMCDM3

KMCDM4:	OUTSTR	[ASCIZ/Illegal file specifier: /]
	PUSH	P,A
	MOVE	A,(A)
	PUSHJ	P,SIXOUT
	MOVE	A,(P)
	MOVE	A,1(A)
	PUSHJ	P,OCTOUT
	POP	P,A

KMCDM3:	ADD	A,[1,,2]
	JUMPL	A,KMCDM1		;LOOP FOR ALL FILES
	RELEAS	FILE,
	PUSHJ	P,MT2REL
	POPJ	P,
	
;DUMP ONE FILE.
;CALL WITH A=FILE NAME, B= FILE LENGTH, C=FIRST ADDRESS
DMPKMC:	PUSH	P,A		;SAVE ARGUMENTS
	PUSH	P,B
	PUSH	P,C
	MOVE	D,[FILINF,,FILINF+1]
	SETZM	FILINF
	BLT	D,FILINF+17
	MOVEM	A,FILINF+DDNAM
	MOVEM	B,FILINF+DDLNG
	ADDI	B,1
	MOVEM	B,FIBUF+2
	HRLI	C,444400
	MOVEM	C,FIBUF+1
	MOVE	A,['KIDKMC']
	MOVEM	A,FILINF+DDPPN
	DATE	A,
	MOVEM	A,FILINF+DDEXT		;DATE
	DPB	A,[POINT 12,FILINF+DDPRO,35]
	LSH	A,-14
	DPB	A,[POINT 3,FILINF+DDEXT,20]
	MOVE	X,[FILINF,,FILBLK]
	BLT	X,FILBLK+3
	MOVE	D,[FILINF+DDNAM,,A]	;PICK UP THE FILE NAME AGAIN
	BLT	D,D
	PUSHJ	P,TYFIL			;TYPE THE FILE NAME - NO CR
	TLZ	FL,IGNEOT
	PUSHJ	P,DUMP
	 JRST	KMRED0			;HAVE TO DO IT OVER ON A NEW TAPE
	PUSHJ	P,MT2CLZ
	MOVE	A,WRCSZ			;get record size
	MOVEM	A,WC
	SETZM	MTFILN
	PUSHJ P,MT2CTS		;skip if EOF written OK, remember where written
	 JRST KMREDO		;physical end of tape, I guess
	MOVE	A,[FILBLK,,LASSAV]
	BLT	A,LASSAV+3		;SAVE THE NAME OF THE FILE WE JUST FINISHED
	OUTSTR	CRLF			;AFTER THE FILE IS OUT, TYPE CR.
	SUB	P,[3,,3]		;FLUSH ARGUMENTS FROM STACK
	POPJ	P,

KMRED0:	PUSHJ P,MT2CLZ		;ATTEMPT TO END FILE 
	PUSHJ P,MT2CT2		;report the output EOF written, don't count it
KMREDO:	OUTSTR	[ASCIZ/	NOT SAVED. - PHYSICAL END OF TAPE.
/]
	PUSHJ	P,MT2REL		;RELINQUISH THE MAG TAPE
	PUSHJ	P,MINIT1		;INIT MAGTAPE for reading, ONLY ONE BUFFER
	HLLZS	LASSAV+1		;EXT ONLY
KMRED1:	PUSHJ	P,MTABKF
	PUSHJ	P,MTABKF
	PUSHJ	P,MTASKF
	SETZM	TIBUF+2			;ZERO THE DATA COUNT.
	PUSHJ	P,RDFIL			;READ THE FILE NAME OFF THE TAPE.
	 JRST .-1		;saw a tape header/trailer, keep going
	MOVE	A,FILINF+DDNAM
	HLLZ	B,FILINF+DDEXT
	MOVE	C,FILINF+DDPPN
	SKIPN	LASSAV
	JRST	KMRED2
	CAMN	A,LASSAV
	CAME	B,LASSAV+1
	JRST	KMRED1
	MOVE	A,FILINF+DDPPN
	CAME	A,LASSAV+3
	JRST	KMRED1
	JRST	KMRED3			;FOUND IT.

KMRED2:	CAMN	A,FILBLK
	CAME	B,FILBLK+1
	JRST	KMRED3			;LOSE.
	CAME	C,FILBLK+3
	JRST	KMRED3
	PUSHJ	P,MTABKF		;BACKUP TO FRONT
KMRED3:	PUSHJ	P,MTASKF		;SKIP PAST PRESENT MT FILE.
	PUSHJ	P,MTAREL		;
	PUSHJ	P,MTINIW		;INIT WITH 3 BUFFERS AGAIN, for writing
	TLO	FL,IGNEOT		;TURN ON THE IGNORE EOT INDICATOR
	PUSHJ	P,TAPTAI		;WRITE A TAPE TAIL
	TLZ	FL,IGNEOT		;
	PUSHJ	P,MT2REW		;REWIND THE TAPE
	CLOSE	FILE,			;WILL LOOK THIS UP AGAIN, LATER.
	OUTSTR	[ASCIZ/MOUNT THE NEXT TAPE AND TYPE CONTINUE
/]
	EXIT	1,			;CALL THE EXIT FROM WHICH WE CAN CONTINUE
	PUSHJ	P,TAPHED		;WRITE ANOTHER TAPE HEADER.
	POP	P,C			;RESTORE ARGUMENTS FROM STACK
	POP	P,B
	POP	P,A
	JRST	DMPKMC			;AND START FROM THE TOP.


KMCBUF:	BLOCK	4440


KMCERR:	OUTSTR	[ASCIZ/Must ASSIGN OLD UDP1
/]
	POPJ	P,

KMCER1:	OUTSTR	[ASCIZ/Can't interpret the directory.
/]
	POPJ	P,

>;KMCSW
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 subttl pumpkin queue format/unpumpkin	 ; UNPUMP PLIST PRESTO PREST1 PLIST0 EUQMSG EUQPLI NOPEUQ DOEUQ PREQLP PREBLK PRDTLP PREDEL PRDTDN PRDTNX NEWTAP PREOF PRNXTT EUQFIX WEDID DIDNT EUQNXT EUQTST IABORT ISKIP ITOGGL INTRPT INTRPX INTRPI INTRPS INTTSL RETRY EUQPRT EUQNIL PRNXT1 RETRY0 PRSTG3 TFLUSH PRUEOT PRPOSN PRPOS2 PRPOS3 PRUSER PMAIL PRUSE0 PRUSE1 PRUFLP PRUFNX PRUTA1 PRUTAP PRUMAI PRUMA1 PRUTRY PRUMER PRUNXT PRUEND PROPRN PRSKPL PRFNDT PRFND1 PRFND2 PRSKLP PRSKDN PRFND2 PRJUMP PRJUGG PRSKPT PRSKNO NOPQUE NOPREQ QUEERR PRUEOF DELEUQ PYORN PYORN0 PYORN1 PRUSTR PRUST1 PRUSIX PRUDEC PRUDE1 PRUDAT PRLFIL PRUFIL PRLFI1 PRUFD0 PRUFI0 PRUF01 PRUF00 PRUFI1 PUX0 PKLU PUXSTR PNOT PTNF PTNR LPUX UNP2QS

COMMENT 
Format of PUMPKI.QUE file:
The file contains one or more request blocks; each block starts on a record
boundary.  Here is the format of a request block:
	0	word count, including this word
	1	date,,PRG of requestor
	2	dest name
	3	dest ext,,flags (flagging wildcards, as usual)
	4	dest ppn
	5-11	source term
	12-16	source term
	...	etc
The file can be parsed ignoring the record alignment, since the padding words will
be zero word counts and can be ignored.  The format of a source term is:
	0	source device (useless)
	1	source name
	2	source ext (sources are never wild)
	3	source PPN
	4	tape number,,date written (sign bit on for T tape)

This file is read into core into a data structure consisting of two
kinds of blocks, a tape block and a term block.  This is a tape block:
	0	tape number (in RH)
	1	term block list header,,next tape block or 0
	2	prev tape block or 0,,number of terms in the list for this tape
The cell TAPES points to the head of the tape list.  This is a term block:
;;old	0	FSDEV	tape number,,next term block or 0
	0	FSDEV	tape number,,dump nbr in bits 18:20 and 2:3
	1	FSNAM	source name
	2	FSEXT	source ext
	3	FSPPN	source PPN
	4	FSPNAM	dest name (note: this word is same as FSTAP)
	5	FSPEXT	dest ext
	6	FSPPPN	dest PPN
	7	FSPREQ	flag,,requestor's PRG
	10	FSPDAT	date of request
	11	FSPNXT	next term block or 0

Here are the possible values for the flag (FSPREQ LH):
	0	request has not been dealt with, or tape was skipped
		invisibly (opr specified no messages to users)
	1	file not found on tape specified in request
	2	tape skipped by operator (tape not found)
	3	tape not readable
	-3	request is in PUMPKI.EUQ (used for UNPUMPKIN only)
	-2	output file already exists
	-1	file restored successfully

Before doing the restore, PRESTORE renames PUMPKI.QUE to PUMPKI.EUQ; if
the file PUMPKI.EUQ already exists when the command is started, DART
thinks that a previously-started PRESTORE was interrupted, e.g., by a
system crash or by the operator CALLing out because the list was too long
to do at once.  In this case the interrupted PRESTORE is resumed.  If an
interrupted PRESTORE is resumed, some special processing is done for each
tape in the list:  before the operator is asked to mount the tape, DART
looks up every output file requested for that tape.  Files which already
exist are marked as restored (at SAIL, they may be marked as already
existed if the file was not last written by [DMP,SYS]) and if no
unrestored files are on the tape, the tape is skipped.  The danger is that
a file which really already existed (at SAIL, it must have been written by
a previous PRESTORE) will be indicated to the user as having been
restored.




UNPUMP:	TLOA FL,L.TURK			;UNPUMPKIN FIRST DOES A SORT OF PLIST
PLIST:	TLZ FL,L.TURK
	TLO FL,L.PUMP			;PLIST COMMAND
	JRST PLIST0

PRESTO:	SETOM LRETRY		;allow limiting retries on errors.
	TLZ FL,L.PUMP			;PRESTORE COMMAND
	TLZ FL,L.TURK			;FLAG NOT REDOING .EUQ FILE
IFE IRCPPN,<
	GETPPN	A,			;GET THE REAL PPN (NOT DSKPPN)
	 JFCL				;DEC NEEDS THIS
>;IFE IRCPPN
IFN IRCPPN,<
	HRROI A,2			;REAL PPN COMES FROM GETTAB
	GETTAB A,
	 GETPPN A,
	  JFCL
>;IFN IRCPPN
	CAME	A,DUMPER		;IS THIS THE RIGHT NAME?
	JRST	NOPRV			;HE IS NOT THE RIGHT GUY.
	PUSH P,.JBFF		;WE'LL RECLAIM THE STORAGE
	PUSHJ P,SCAN		;MAYBE THE PUMPKIN WILL SPECIFY A TAPE drive
	MOVE A,TBASE
	CAML A,FSPTR		;ANY SOURCE?
	JRST PREST1		;NO, NO MTA
	MOVE A,FSDEV(A)		;YES, MAYBE A MTA
	MOVEM A,MTDEV
PREST1:	POP P,.JBFF		;THAT'S ALL WE LET HIM/HER SPECIFY
PLIST0:	SETZM DEST
	SETZM UNP2QF		;CLEAR UNPUMPKIN 2 QUEUES FLAG
	INIT UFD,10		;PREPARE TO READ THE REQUEST FILE
	 'DSK   '
	 UFDBUF			;INPUT BUFFER HEADER
	 PUSHJ P,NODEV		;IT CAN'T HAPPEN HERE?
REPEAT 0,<
	TLNE FL,L.TURK		;UNPUMPKIN?
	JRST NOPEUQ		;YES, USE .QUE REGARDLESS
>;REPEAT 0
	MOVE A,['PUMPKI']
	MOVSI B,'EUQ'
	MOVE D,DUMPER
	LOOKUP UFD,A		;FIRST LOOK FOR AN ABORTED RUN
	 JRST NOPEUQ
	TLNE FL,L.PUMP		;PLIST?
	JRST EUQPLI		;YES, USERS GET DIFFERENT OPTIONS
REPEAT 0,<
EUQMSG:	OUTSTR [ASCIZ /Partially processed PRESTORE file found.  Type Y to try to
continue this file, otherwise you'd better delete it and restart: /]
	PUSHJ P,PYORN		;MUST TYPE Y
	 JRST EUQMSG		;I SAID *MUST* TYPE Y
>;REPEAT 0
	OUTSTR [ASCIZ /(Using partially processed PRESTORE file!!)
/]
IFN STANSW!IRCPPN,<
	MOVNI A,1
	BEEP A,			;AFTER ALL, IT HAS TO BE DONE AGAIN FOR THE QUE FILE.
>;IFN STANSW!IRCPPN
	TLO FL,L.TURK		;OK, FLAG IT
	JRST DOEUQ

EUQPLI:
REPEAT 0,<
	OUTSTR [ASCIZ /There is a partially processed PUMPKIN request queue which
was interrupted by a crash.  Do you want to see that list?  If so, type Y.
Otherwise, we'll look for a new request queue: /]
	PUSHJ P,YORN		;ACCEPT ANYTHING FOR NO HERE
	 JRST NOPEUQ		;NO, WE TRY A .QUE
	JRST DOEUQ		;YES, WE USE THE .EUQ
>;REPEAT 0
	TLNE FL,L.TURK		;UNPUMPKIN?
	JRST UNP2QS		;YES, HAIRY MESS FOR BOTH QUEUES IN
	OUTSTR [ASCIZ /(Partially processed request queue:)
/]				;MUST TELL USER SOME OF THIS ALREADY DONE!
	PUSHJ P,DOEUQ		;FIRST DO THE EUQ LIST
	OUTSTR [ASCIZ /(End of partially processed queue.)
/]				;FALL INTO DOING QUE
NOPEUQ:	MOVE A,['PUMPKI']
	MOVSI B,'QUE'
	MOVE D,DUMPER
	LOOKUP UFD,A		;FIND THE QUEUE FILE
	 JRST NOPQUE
	TLNE FL,L.PUMP		;PLIST COMMAND?
	JRST DOEUQ		;YES, DON'T RENAME QUEUE FILE
	HRLI B,'EUQ'
	MOVE D,DUMPER
	RENAME UFD,A		;CHANGE ITS NAME
	 JRST QUEERR		;SAY WHAT?
DOEUQ:	SETZM TAPES		;NO TAPE LIST TO START WITH
	INBUF UFD,2		;MAKE THE BUFFERS SO JOBFF WILL BE RIGHT
	MOVE W,.JBFF		;THIS IS OUR FREE STORAGE SYSTEM
PREQLP:	PUSHJ P,UFDRD		;READ THE WORD COUNT
	 JRST PREOF		;ALL READ IN
	JUMPE A,PREQLP		;SKIP PADDING WORDS
	MOVE Z,A		;SAVE WORD COUNT
	PUSHJ P,UFDRD		;DATE,,REQUESTOR'S PRG
	 JRST PRUEOF		; THERE BETTER BE ONE
	MOVEM A,RSTDEV		;SAVE IT HERE TEMPORARILY
	PUSHJ P,UFDRD		;DEST NAME
	 JRST PRUEOF
	MOVEM A,RSTNAM		;AS GOOD A PLACE AS ANY
	PUSHJ P,UFDRD
	 JRST PRUEOF
	MOVEM A,RSTEXT
	PUSHJ P,UFDRD
	 JRST PRUEOF
	MOVEM A,RSTPPN
	SUBI Z,PFSLEN+1		;REMOVE THIS HEADER STUFF FROM WC
	IDIVI Z,PSIZE		;TURN WC INTO BLOCK COUNT
PREBLK:	PUSHJ P,PGTBLK		;GET A PRESTORE-SIZE TERM BLOCK
	PUSHJ P,UFDRD		;READ THE SOURCE POOP
	 JRST PRUEOF		;FIRST WE IGNORE THE DEV WORD
	PUSHJ P,UFDRD
	 JRST PRUEOF
	MOVEM A,FSNAM(R)
	PUSHJ P,UFDRD
	 JRST PRUEOF
	MOVEM A,FSEXT(R)
	PUSHJ P,UFDRD
	 JRST PRUEOF
	MOVEM A,FSPPN(R)
	PUSHJ P,UFDRD
	 JRST PRUEOF
	AND A,[400000!RDHMSK!TAPMSK,,RDLMSK] ;keep only tape number fields
	MOVEM A,FSDEV(R)	;TAPE NUMBER GOES HERE
	SKIPN FSNAM(R)		;SKIP UNLESS REQUEST HAS BEEN DELETED
	JRST PREDEL		;FORGET THIS
	MOVE B,RSTEXT		;GET DEST EXT AND FLAGS
	MOVE A,RSTNAM		;DEST NAME
	TRNE B,ALLFIL		;WILD?
	MOVE A,FSNAM(R)		;YES, USE SOURCE NAME
	MOVEM A,FSPNAM(R)	; AS DEST NAME
	TRNE B,ALLEXT		;WILD EXT?
	HLL B,FSEXT(R)		;YES, USE SOURCE
	HLLZM B,FSPEXT(R)
	MOVE A,RSTPPN
	TRNE B,ALLPRJ
	HLL A,FSPPN(R)
	TRNE B,ALLPRG
	HRR A,FSPPN(R)
	MOVEM A,FSPPPN(R)
	MOVE A,RSTDEV		;DATE,,REQUESTOR'S PRG
REPEAT 0,<
	HRRZM A,FSPREQ(R)	; INTO TERM BLOCK
>;REPEAT 0
	HLRZM A,FSPDAT(R)	;DATE INTO TERM BLOCK
	HLL A,UNP2QF		;0 EXCEPT FOR EUQ ENTRIES FOR UNPUMPKIN
	MOVEM A,FSPREQ(R)	;SO UNPUMPKIN KNOWS WHICH QUEUE TO DELETE FROM
	HLRZ A,FSDEV(R)		;GET TAPE NUMBER
;	MOVE A,FSDEV(R)		;get tape and relative dump number
	ANDI A,400000!TAPMSK	;clear extra bits, leaving tape number and P/T bit
	SKIPN X,TAPES		;LOOK FOR PREVIOUS TERM ON SAME TAPE
	JRST NEWTAP		;FIRST TERM IS ALWAYS NEW
PRDTLP:	CAME A,(X)		;SAME TAPE?
	JRST PRDTNX		;NO, TRY ANOTHER
	HLRZ A,1(X)		;YES, GET HEAD OF TERM LIST
	HRRM A,FSPNXT(R)	;LINK BEHIND OUR NEW ONE
	HRLM R,1(X)		;NEW ONE IS NOW LIST HEAD
	AOSA 2(X)		;COUNT HOW MANY TERMS IN THIS TAPE
PREDEL:	SUBI W,FSPLEN		;HERE TO UNMAKE A DELETED REQUEST
PRDTDN:	SOJG Z,PREBLK		;FINISH THIS REQUEST
	JRST PREQLP		;OR GET NEXT REQUEST

PRDTNX:	HRRZ X,1(X)		;GET NEXT TAPE BLOCK
	JUMPN X,PRDTLP		; IF ANY
NEWTAP:	HRLZ X,R		;SAVE NEW TERM
	MOVE Y,A		;SAVE TAPE NUMBER
	PUSHJ P,TGTBLK		;GET A TAPE BLOCK
	MOVEM Y,(R)		;SAVE TAPE NUMBER
	HRR X,TAPES		;LINK OLD TAPE LIST BEHIND IT
	MOVEM X,1(R)
	MOVEI A,1
	MOVEM A,2(R)		;COUNT ONE TERM IN THIS TAPE SO FAR
Printx Add new Pumpkin tapes here at end of list, not start, to do requests in order made.
	HRRZ A,TAPES		;OLD TOP TAPE
	HRLM R,2(A)		;NEW ONE IS NOW ITS BACK POINTER
	HRRZM R,TAPES		;NEW HEAD OF TAPE LIST
	JRST PRDTDN

; Here when the input queue file has been read into core.  If we decide
; to sort the tape numbers, here's where to do it.

PREOF:	SKIPN TAPES		;ANYTHING FOUND?
	OUTSTR [ASCIZ /  (Request queue is empty.)
/]				;QUEUE CONTAINS ONLY DELETED REQUESTS
	SKIPE UNP2QF		;DOING EUQ FOR UNPUMPKIN?
	POPJ P,			;YES, NOT REALLY DONE.  (BACK TO UNP2QS CODE)
	MOVEM W,.JBFF		;SAVE WHERE WE'RE UP TO IN CORE
	MOVSI A,'DSK'
	MOVEM A,RSTDEV		;CONSTANT OUTPUT DEVICE
	MOVE W,TAPES
	MOVEM W,RTAPES		;KEEP FULL TAPE LIST HEAD AROUND FOR REPORTING
	TLNE FL,L.PUMP		;IS THIS PLIST?
	JRST PLIST1		;YES, JUST LIST THE QUEUE
PRNXTT:	SKIPN W,TAPES		;GET TAPE BLOCK
	JRST DELEUQ		;NONE LEFT
	MOVE A,2(W)		;COUNT OF TERMS FOR THIS TAPE
	HRRZM A,TRMCNT		;KEEP FOR RESTORE'S DONE TEST
	TLNN FL,L.TURK		;ARE WE RECOVERING FROM ABORTED RUN?
	JRST PRNXT1		;NO, JUST ASK FOR THE TAPE
	INIT DSKMSC,17		;YES.  LOOK FOR ALREADY RESTORED FILES.
	 'DSK   '
	 0
	 PUSHJ P,NODEV
	TLZ FL,L.PUMP		;THIS WILL FLAG A RESTORED FILE
	HLRZ W,1(W)		;GET TERM LIST
EUQFIX:	JUMPE W,EUQTST		;JUMP IF NO TERMS LEFT
	MOVE A,FSPNAM(W)	;GET DESTINATION FILESPEC
	MOVE B,FSPEXT(W)
	MOVE D,FSPPPN(W)
	LOOKUP DSKMSC,A		;DOES THE FILE EXIST?
	 TRNE B,-1		;ERROR, CODE MUST BE 0 (NO SUCH FILE)
	JRST .+2		;FILE EXISTS
	JRST EUQNXT		;FILE DOESN'T EXIST
	MOVNI X,1		;CODE FOR ALREADY RESTORED
IFN STANSW,<
	MTAPE DSKMSC,PRVMTA	;SEE WHO WROTE THE FILE
	 JRST WEDID		;ERROR, NEVER MIND
	SETZM PASWD		;IN CASE OF INF
	MOVE A,GRPWD		;GET PPN WHICH WROTE FILE
	CAME A,DUMPER		;DID WE WRITE IT?
	JRST DIDNT		;NO, THIS IS A COINCIDENCE
>;IFN STANSW
WEDID:	TLOA FL,L.PUMP		;FLAG SOME TERM ALREADY RESTORED
DIDNT:	MOVNI X,2		;CHANGE CODE TO FILE ALREADY EXISTS
	HRLM X,FSPREQ(W)	;FLAG THIS TERM DONE
	SOS TRMCNT		;ONE FEWER TO DO
EUQNXT:	HRRZ W,FSPNXT(W)	;get next term for this tape
	JRST EUQFIX

EUQTST:	RELEAS DSKMSC,
	MOVE W,TAPES		;RESTORE TAPE POINTER
	TLNN FL,L.PUMP		;ANYTHING ALREADY RESTORED?
	SKIPG TRMCNT		; (MAYBE NOTHING TO DO BECAUSE ALREADY EXISTED)
	JRST .+2
	JRST EUQNIL		;NO, JUST DO THIS TAPE NOW
	MOVE A,(W)		;GET TAPE NUMBER
	MOVEM A,TAPNO		;SAVE IT FOR MRESTORE'S ROUTINES
	OUTSTR [ASCIZ /(Tape /]
	PUSHJ	P,REELMX
	MOVE	A,TAPNAM
	PUSHJ	P,SIXOUT
	SKIPE TRMCNT		;ANY LEFT?
	JRST EUQPRT		;YES, PARTIAL TAPE
	MOVEI B,[ASCIZ / completely restored, will be skipped.)
/]
	TLNN FL,L.PUMP		;SKIP IF REALLY RESTORED SOMETHING
	MOVEI B,[ASCIZ /: all output files already exist; will be skipped.)
/]
	OUTSTR (B)
	MOVE W,TAPES
	HRRZ W,1(W)		;GET NEXT TAPE
	MOVEM W,TAPES
	JRST PRNXTT

SAIL,<
;Here upon ESC I interrupt.  Make various automatic things stop.
IABORT__5	;repeat arg for ESC I that indicates a tape abort request
ISKIP__7	;repeat arg for ESC I that indicates a tape skip request
ITOGGL__9	;repeat arg for ESC I that indicates a tape slice toggle request
INTRPT:	MOVE B,10		;save any datum for this interrupt
	MOVE A,.JBCNI		;get bit indicating interrupt cause
	TLNN A,INTTTI		;ESC I?
	DISMIS			;no, ignore spurious interrupt
	CAIN B,IABORT		;is this ESC 5 I, to abort an input tape?
	JRST INTRPI		;yes, set abort flag
	CAIN B,ISKIP		;is this ESC 7 I, to skip portion of tape?
	JRST INTRPS		;yes, set skip flag
	CAIN B,ITOGGL		;is this ESC 9 I, to toggle input slice level?
	JRST INTTSL		;yes, set toggle-slice flag
	JUMPN B,INTRPX		;if any other argument, ignore it
	SETZM DIFFGO		;but do stop at difference in next file
	SETZM RETRYC		;yes, clear illfmt retry count
	MOVE P,[IOWD IPDL,IPDLEN] ;set up an interrupt level PDL
	PUSHJ P,CLRCON		;clear automatic continuation flags
	MOVEI A,1
	MOVEM A,TLISTC		;make tlist stop soon
INTRPX:	DISMIS

INTRPI:	SETOM TABORT		;indicate that operator requests tape abort
	DISMIS

INTRPS:	SETOM TSKIP		;indicate that operator requests tape skip forward
	DISMIS

INTTSL:	SETOM TSLICE		;indicate that operator requests tape slice toggle
	DISMIS
>;SAIL

;Here from RETRY command to resume a Prestore in middle of tape.
RETRY:	SETOM RETRYC		;assume no automatic retry
	MOVE A,SAVDEL
	CAIE A,12
	CAIN A,ALTMOD
	JRST RETRY0		;no argument present
	PUSHJ P,GETSIX		;GET SOMETHING IN SIXBIT after cmd
	PUSHJ P,NUMTST		;TEST SIXBIT IN B FOR BEING A NUMBER
	 JRST SYNTAX		;NOT A NUMBER, syntax error
	MOVEM C,RETRYC		;remember automatic retry count
	JRST RETRY0		;now go resume Prestore

EUQPRT:	OUTSTR [ASCIZ / partially restored; will continue it now.)
/]
EUQNIL:	MOVE W,TAPES		;RESTORE TAPE POINTER
PRNXT1:	MOVE A,(W)		;GET TAPE NUMBER
	MOVEM A,TAPNO		;SAVE IT FOR MRESTORE'S ROUTINES
	PUSHJ P,DOMT0		;ASK THE OPR FOR IT
	 JRST PROPRN		;S/HE SAYS NO, DEAL WITH THIS
	MOVE A,(W)
	MOVEM A,PREQTP		;SAVE TAPE NUMBER TO TELL RDFIL TO CHECK IT
	PUSHJ P,MTINIR		;Init magtape, just reading
	PUSHJ P,MTAREW
	MOVE A,1(W)		;LINK OUT THIS TAPE NUMBER
	HRRZM A,TAPES		; FROM THE TAPE LIST
	HLRZ W,A		;GET POINTER TO TERM LIST FOR THIS TAPE
	MOVEM W,TBASE		;POINT TO BEGINNING OF LIST FOR THIS TAPE
RETRY0:	SETZM PFDRIP		;no file-data-read in progress
	SETZM PUMWIZ		;ENTRY AFTER REPOSITIONING TAPE ON ILL FMT
	MOVEI K,PUMRST		;POINT TO DATA AREA FOR PUMPKIN RESTORE
;	PUSH P,CRESTA		;SAVE UNEXPECTED EOT TRANSFER ADDR (NORMALLY RESTAR)
;	PUSH P,CREST1		;DITTO ILLFMT ADDR
;	MOVEI A,PRUEOT		;address of place to go on unexpected EOT
;	MOVEM A,CRESTA
;	MOVEI A,PRPOSN		;address of place to go on ill format tape
;	MOVEM A,CREST1
	MOVEM P,PRSAVP		;FOR UNWIND IN CASE OF UNEXPECTED EOT or ILL FMT
	PUSHJ P,RSTG3		;DO THE ACTUAL WORK NOW
PRSTG3:	SETZM PRSAVP		;disallow jumping directly here now
;	POP P,CREST1
;	POP P,CRESTA
IFN STANSW!IRCPPN,<
	MOVNI A,1
	BEEP A,			;HELLO TEST, 1,2,3
>;IFN STANSW!IRCPPN
	SKIPA A,[PNOT]		;CODE FOR FILE UNRESTORED BECAUSE NOT ON TAPE
TFLUSH:	MOVEI A,PTNR		;code for tape not readable
	SETZM PUMWIZ		;ENTRY TO GIVE UP ON THIS TAPE
	SETZM PREQTP		;NO LONGER REQUIRING A TAPE AT RDFIL
	SKIPG TRMCNT		;ON RETURN ALL TERMS SHOULD BE GONE
	JRST PRNXTT		; (SINCE WE CLEVERLY HAVE NO WILD TERMS)
IFN STANSW,<			;ONLY IF MAIL FEATURE
	OUTSTR [ASCIZ /Some unrestored files on this tape, will notify users.
/]
>;IFN STANSW
	MOVE W,TBASE
	PUSHJ P,PRUSER		;NOTIFY USER OF UNRESTORED FILES
	JRST PRNXTT		;NEXT TAPE

repeat 0,<
PRUEOT:	MOVE P,PRSAVP		;HERE ON UNEXPECTED EOT
	PUSHJ P,MTAREL		;release tape before re-initing, avoid bugtrap
	PUSHJ P,MTINIR		;Re-Init magtape, just reading
	PUSHJ P,MTAREW
	JRST PRSTG3
>;repeat 0

PRPOSN:
SAIL,<
	RELEAS FILE,1		;Inhibit closing this open file
>;SAIL
NOSAIL,<
	CLOSE FILE,40		;Inhibit deletion of old version
	RELEAS FILE,
>;NOT SAIL
	MOVE P,PRSAVP		;HERE ON BAD FORMAT TAPE
;	POP P,CREST1
;	POP P,CRESTA
repeat 0,<
;RETRY <number> will automatically continue <number> times from illegal format.
	SOSLE RETRYC		;want to advance and retry automatically?
	JRST PRPOS2		;yes
>;repeat 0
	PUSHJ P,MTAREL		;release the tape
	OUTSTR [ASCIZ/## Use any of ADVANCE, BACKSPACE, REWIND, EOT, and DDT.
Then type RETRY to continue PRESTORE on this tape, or FLUSH to skip this tape.
/]
	SETOM PUMWIZ		;RESTRICT COMMANDS TO THOSE SPECIFIED
	POPJ P,

repeat 0,<
PRPOS2:	PUSHJ P,MTINIR		;INIT THE MAGTAPE DEVICE, just reading
	SKIPE PFDRIP		;skip unless ill fmt occurred in desired file
	JRST PRPOS3		;must backup to read needed file again
	OUTSTR [ASCIZ/Illegal tape format; doing an ADVANCE to skip the bad part.
/]
	PUSHJ P,MTASKF		;ADVANCE FILE, skipping bad spot
	JRST RETRY0		;go on as if user said retry

PRPOS3:	OUTSTR [ASCIZ/Illegal tape format; doing a BACKSPACE to re-read needed file.
/]
	PUSHJ P,MTABKF		;BACKSPACE FILE, so we can reread desired file
	JRST RETRY0		;go on as if user said retry
>;repeat 0

PRUSER:	SKIPL FSPREQ(W)		;IS THIS TERM ALREADY RESTORED?
	HRLM A,FSPREQ(W)	;NO, SAVE REASON
	HRRZ W,FSPNXT(W)	;POINTER TO NEXT TERM
	JUMPN W,PRUSER		;LOOP
	POPJ P,

PMAIL:
IFN STANSW,<			;FIND SOME OTHER WAY TO NOTIFY USERS ELSEWHERE
	INIT DSKMSC,17		;DUMP IT OUT
	 'DSK   '
	 0
	  PUSHJ P,NODEV
PRUSE0:	SKIPN W,RTAPES		;GET A TAPE
	JRST PRUEND		;NONE
	HRRZ X,1(W)		;NEXT TAPE AFTER THIS
	MOVEM X,RTAPES		; IS NEW LIST HEAD
	MOVEM X,TAPES		; AND REST-OF-TAPES HEAD
	HLRZ W,1(W)		;BEGINNING OF TERM LIST FOR THIS TAPE
PRUSE1:	HRRZ X,FSPREQ(W)	;GET PROGRAMMER NAME OF A LUSER
	HLRZ A,FSPREQ(W)	;GET NOTIFICATION CODE
	JUMPE A,PRUNXT		;JUMP IF NOT TO BE NOTIFIED
	MOVE Y,.JBFF		;HERE'S WHERE WE'LL PUT THE MESSAGE
	ADDI Y,1000		;KLUDGE, LEAVE ROOM FOR MESSAGE
	CAMLE Y,.JBREL
	CORE Y,
	 JFCL			;FCK IT
	HRLZ Y,.JBFF
	HRR Y,.JBFF
	ADDI Y,1
	SETZM @.JBFF
	BLT Y,@.JBREL		;ALL THIS TO AVOID SOS BITS -- Clear all free core
	MOVE Y,.JBFF
	HRLI Y,440700		;BPT
	MOVEI B,[ASCIZ \MAIL/SUBJEC/FROM="Great-Pumpkin" \]
	PUSHJ P,PRUSTR		;OUTSTR THAT
	MOVEI B,(X)		;PRG OF LUSER
	PUSHJ P,PRUSIX
	MOVEI B,[ASCIZ /
/]
	PUSHJ P,PRUSTR
	MOVEI A,14		;CAN'T PUT A FORMFEED IN THIS HERE E-FORMAT PROGRAM
	IDPB A,Y
	MOVEI B,[ASCIZ /Restored Files
Here is a status report on your PUMPKIN requests:

Tape	File					Status

/]
	PUSHJ P,PRUSTR
	MOVEI Z,(W)		;GET FIRST BLOCK FOR THIS USER
	HRRZ K,FSPREQ(W)	;SAVE THE PRG HERE
PRUFLP:	PUSHJ P,PRUFIL		;POOT OUT FILE NAME
	HRRZS FSPREQ(Z)		;MAKE SURE WE DON'T TELL ABOUT THIS TWICE
PRUFNX:	HRRZ Z,FSPNXT(Z)	;LOOK FOR MORE TERMS FOR SAME LUSER
PRUTA1:	JUMPE Z,PRUTAP		;NONE IN THIS TAPE, LOOK FOR ANOTHER
	HRRZ B,FSPREQ(Z)	;SAME PERSON?
	CAIN B,(K)
	JRST PRUFLP		;YES
	JRST PRUFNX		;NO

PRUTAP:	SKIPN Z,TAPES		;MORE TAPES TO CHECK?
	JRST PRUMAI		;NO
	HRRZ A,1(Z)		;YES, MARK NEW TAPE SEEN
	MOVEM A,TAPES
	HLRZ Z,1(Z)		;GET TERM LIST
	JRST PRUTA1

PRUMAI:	MOVEI A,0		;NULL IT OUT
PRUMA1:	IDPB A,Y
	TLNE Y,760000		;END OF WORD?
	JRST PRUMA1		;NO
	MOVEI Y,1(Y)		;END ADDR +1
	SUB Y,.JBFF		;LENGTH OF MESSAGE
	MOVNS Y			;NEGATIVE LENGTH
	HRL Y,.JBFF		;SWAPPED WCMA
	MOVSM Y,PRUIOW		;REAL WCMA
	SOS PRUIOW		;IOWD (WCMA-1)
	MSTIME A,		;ORIGINAL WAY TO MAKE UP UNIQUE FN
	HRLI A,(K)		; INCLUDING THE RECIPIENT
	MOVEM A,PRUFNM
	MOVEI L,100		;HOW MANY FNS TO TRY
PRUTRY:	MOVSI B,'FTP'		;PREPARE FOR LOOKUP
	MOVE D,RMDSYS
	LOOKUP DSKMSC,A		;EXISTS?
	 TRNE B,-1		;ERROR MUST BE FILE NOT FOUND TO WIN
	AOSA A,PRUFNM		;THIS NAME LOSES
	SKIPA A,PRUFNM		;THIS NAME WINS
	SOJG L,PRUTRY		;LOSES
	JUMPLE L,PRUMER		;MAIL ERROR
	CLOSE DSKMSC,		;NO HANGING LOOKUP
	MOVSI B,'FTP'		;PREPARE FOR ENTER
	MOVEI C,0
	MOVE D,RMDSYS
	ENTER DSKMSC,A		;DO IT
	 JRST PRUMER		;HUH?
	OUTPUT DSKMSC,PRUIOW	;WRITE IT
PRUMER:	CLOSE DSKMSC,		;SHIP IT
	MOVE A,RTAPES		;GET TAPE WE'RE DOING
	HRRZ A,1(A)		;GET ITS NEXT TAPE
	MOVEM A,TAPES		;SAVE AS LIST TO CHECK
PRUNXT:	HRRZ W,FSPNXT(W)	;GET NEXT TERM BLOCK
	JUMPN W,PRUSE1		; IF ANY
	JRST PRUSE0		;ELSE NEXT TAPE

PRUEND:	RELEAS DSKMSC,
	MOVEI A,RMDWAK		;FIRE UP MAIL
	WAKEME A,
	 JFCL
>;IFN STANSW
	POPJ P,

PROPRN:	SKIPN B,MRTPNO		;OPR DOESN'T LIKE OUR TAPE, DID S/HE GIVE ANOTHER?
	JRST PRSKPT		;NO, JUST SKIP A TAPE
	MOVE W,TAPES		;SKIP AHEAD TO HIS/HER TAPE
	MOVEI X,TAPES-1		;I THINK THIS IS AN UNNECESSARY PRECAUTION
PRSKPL:	MOVE A,(W)		;GET TAPE NUMBER
	CAIN A,(B)		;THERE YET?
	JRST PRFNDT		;FOUND IT
	MOVE X,W		;SAVE BACK POINTER
	HRRZ W,1(W)		;GET NEXT TAPE
	JUMPN W,PRSKPL		; IF ANY
	OUTSTR [ASCIZ /But, we don't need that one!  Try again:
/]
	JRST PRNXTT

PRFNDT:	OUTSTR [ASCIZ /Forget about intervening tapes?  (Otherwise we'll do them
after this one.) /]
PRFND1:	PUSHJ P,PYORN		;MUST BE Y OR N, NO DEFAULT
	 JRST PRJUGG		;NO, JUST JUGGLE THE LIST
IFN STANSW,<			;ONLY IF WE HAVE THE MAIL FEATURE
PRFND2:	OUTSTR [ASCIZ /Notify users that requests were not done? /]
	PUSHJ P,PYORN
	 JRST PRJUMP		;THIS IS APPROPRIATE IF DOING A PICKUP
	PUSH P,W		;SAVE TARGET TAPE
	HRRZ W,TAPES		;LOOP THROUGH NOTIFYING USERS
PRSKLP:	HRRZ A,1(W)
	HRRZM A,TAPES		;LINK THIS TAPE OUT
	CAMN W,(P)		;IS THIS THE TARGET?
	JRST PRSKDN		;YES, DONE
	HLRZ W,1(W)		;GET TERM LIST HEAD
	MOVEI A,PTNF		;CODE FOR NOT RESTORED BECAUSE OPR SKIPPED TAPE
	PUSHJ P,PRUSER		;NOTIFY USERS
	SKIPE W,TAPES		;GET NEXT TAPE
	JRST PRSKLP
	SKIPN (P)		;MAYBE WE WEREN'T LOOKING FOR ANYTHING?
	JRST PRSKDN		;RIGHT! (FROM X OF LAST TAPE)
	OUTSTR [ASCIZ /Can't find tape block!/]
	HALT PRSKDN

PRSKDN:	POP P,W
>;IFN STANSW
IFE STANSW,<
PRFND2:
>;IFE STANSW
PRJUMP:	HRRZM W,TAPES		;SKIP AHEAD TO OPR'S TAPE, FLUSHING OTHERS
	JRST PRNXTT

PRJUGG:	HRRZ A,1(W)		;LINK OPR'S TAPE OUT OF LIST
	HRRM A,1(X)
	JUMPE A,.+2		;SKIP IF NEW HEAD WAS OLD TAIL
	HRLM X,2(A)		;BACK PTR TOO
	HRRZ A,TAPES		;NOW PUT OUR LIST AFTER IT
	HRRM A,1(W)
	HLRZ X,2(A)		;GET OLD HEAD'S BACK POINTER
	HRLM W,2(A)		;ITS NEW BACK PTR IS OUR NEW HEAD
	JUMPE X,.+2		;JUMP IF OLD HEAD WAS REAL HEAD, NO BACK PTR
	HRRM W,1(X)		;LINK NEW HEAD INTO FULL LIST
	HRLM X,2(W)		;BACK PTR FOR NEW HEAD
	HRRZM W,TAPES		;MAKE IT HEAD OF LIST
	JUMPN X,PRNXTT		;JUMP UNLESS NEW HEAD IS NEW REAL HEAD
	HRRZM W,RTAPES		;NEW HEAD OF FULL LIST
	JRST PRNXTT		;RECONFIRM USING THAT TAPE

PRSKPT:	SKIPE X,TAPES		;SKIP ONE TAPE
	HRRZ W,1(X)		;THIS IS TARGET TAPE
	JUMPE W,PRSKNO		;NO NEXT TAPE
	OUTSTR [ASCIZ /Forget about that tape?  (Otherwise we'll do it
after the next one.) /]
	JRST PRFND1

PRSKNO:	OUTSTR [ASCIZ /That's the last tape.  Do you want to forget about it? /]
	PUSHJ P,PYORN		;CONFIRM FLUSHING TAPE
	 JRST PRNXTT		;NO CONFIRM, ASK FOR SAME TAPE
	JRST PRFND2		;ASK ABOUT NOTIFYING USERS

NOPQUE:	TRNN B,-1		;WHAT LOOKUP ERROR?
	JRST NOPREQ		;FILE NOT FOUND, NO REQUESTS
	OUTSTR [ASCIZ /Can't read PUMPKI.QUE
/]
	POPJ P,

NOPREQ:	OUTSTR [ASCIZ /Nobody wants the Great Pumpkin today.
/]
	POPJ P,

QUEERR:	OUTSTR [ASCIZ /PUMPKI.EUQ already exists, please check it out.
/]
	JRST RESTAR

PRUEOF:	OUTSTR [ASCIZ /Bad format in PUMPKI.EUQ, get help.
/]
	JRST RESTAR

DELEUQ:
IFN STANSW,<
	OUTSTR [ASCIZ /PRESTORE done, notifying users...
/]
	PUSHJ P,PMAIL
>;IFN STANSW
	INIT DSKMSC,17
	 'DSK   '
	 0
	 PUSHJ P,NODEV
	MOVE A,['PUMPKI']
	MOVSI B,'EUQ'
	MOVE D,DUMPER
	LOOKUP DSKMSC,A
	 JFCL
	MOVE D,DUMPER
	MOVEI A,0
	RENAME DSKMSC,A
	 OUTSTR [ASCIZ /Couldn't delete PUMPKI.EUQ, get help.
/]
	RELEAS DSKMSC,
	OUTSTR [ASCIZ /Thank you, O Great Pumpkin.
/]
IFN STANSW!IRCPPN,<
	MOVNI A,1
	BEEP A,
>;IFN STANSW!IRCPPN
	POPJ P,

PYORN:	OUTSTR [ASCIZ /Type Y or N: /]
PYORN0:	INCHWL A
	SKIPA B,A
PYORN1:	INCHWL A
	CAIE A,12
	JRST PYORN1
	CAIE B,"Y"
	CAIN B,"y"
	JRST CPOPJ1
	CAIE B,"N"
	CAIN B,"n"
	POPJ P,
	JRST PYORN		;MUST TYPE Y OR N, NOT JUST CR

PRUSTR:	HRLI B,440700		;THIS TRIVIAL CODE DESERVES NO COMMENTS
PRUST1:	ILDB A,B
	JUMPE A,CPOPJ
	IDPB A,Y
	JRST PRUST1

PRUSIX:	JUMPE B,CPOPJ
	MOVEI A,0
	LSHC A,6
	JUMPE A,PRUSIX		;NO LEADING BLANKS IN PPN
	ADDI A,40
	IDPB A,Y
	SUBI D,1
	JRST PRUSIX

PRUDEC:	IDIVI B,5+5
	JUMPE B,PRUDE1
	HRLM C,(P)
	PUSHJ P,PRUDEC
	HLRZ C,(P)
PRUDE1:	ADDI C,"0"
	IDPB C,Y
	POPJ P,

PRUDAT:	MOVE A,B			;OUTPUT SYSTEM DATE
	IDIVI	A,37			;DAYS IN B
	PUSH	P,A			;SAVE THE REST
	MOVEI	A," "			;BLANK
	CAIG	B,10
	IDPB A,Y
	MOVEI	B,1(B)			;GET THE DAY OF MONTH
	PUSHJ	P,PRUDEC
	MOVEI	A,"-"
	IDPB A,Y
	MOVE	A,(P)
	IDIVI	A,14			;MONTHS IN B
	MOVEM	A,(P)
	MOVEI	B,MONTAB(B)
	PUSHJ	P,PRUSTR
	POP	P,A
	MOVEI B,100(A)
	JRST PRUDEC

PRLFIL:	HRLZ B,FSPREQ(Z)	;PLIST, TELL WHO REQUESTED IT
	PUSHJ P,PRUSIX
	MOVEI A,11
	IDPB A,Y
	HRRZ B,FSPDAT(Z)	;AND WHEN
	PUSHJ P,PRUDAT
	MOVEI A,11
	IDPB A,Y
	JRST PRLFI1

PRUFIL:	HLRE A,FSPREQ(Z)	;GET STATUS CODE
	JUMPE A,CPOPJ		;DON'T REPORT ON INVISIBLE FILE
	MOVEI A,(Y)		;Make sure there is core for this file's line
	ADDI A,100		;This is enough core for one line
	CAMG A,.JBREL
	JRST PRLFI1		;Already enough core
	HRRZ B,.JBREL		;Remember addr for zeroing core
	CORE A,
	 JFCL			;FCK IT
	SETZM 1(B)		;Clear first new word
	HRLI B,1(B)		;BLT starts with first new word
	ADDI B,2
	BLT B,@.JBREL		;ALL THIS TO AVOID SOS BITS -- Clear new free core
PRLFI1:	HLRZ B,FSDEV(Z)		;ENTRY FOR PLIST, LISTS EVEN INVISIBLE TERMS
	ANDI B,400000!TAPMSK	;clear extra bits, leave tape number plus sign
	MOVEI A,"P"
	TRZE B,400000		;WHICH KIND OF TAPE?
	MOVEI A,"T"
	IDPB A,Y
	PUSHJ P,PRUDEC		;put out the tape number from B
	LDB B,[POINT RDLBTS,FSDEV(Z),RDLPOS] ;get low bits of relative dump nbr
	LDB A,[POINT RDHBTS,FSDEV(Z),RDHPOS] ;get high bits of relative dump nbr
	DPB A,[POINT RDHBTS,B,35-RDLBTS]     ;combine high and low bits
	JUMPE B,PRUFD0		;jump if no relative dump bits
	MOVEI A,"/"
	IDPB A,Y
	PUSHJ P,PRUDEC		;output relative dump number from B
PRUFD0:	MOVEI A,11
	IDPB A,Y		;TAB
	MOVEI D,50		;COUNT CHARS IN FIELD FOR FILENAME(S)
	MOVE C,FSPPPN(Z)	;IS DEST SAME AS SOURCE?
	MOVE B,FSPNAM(Z)
	CAMN C,FSPPN(Z)
	CAME B,FSNAM(Z)
	JRST PRUFI0		;NO, MUST DO OUT_IN
	HLRZ B,FSEXT(Z)
	HLRZ C,FSPEXT(Z)
	CAIN B,(C)
	JRST PRUF00
PRUFI0:	MOVE B,FSPNAM(Z)	;HERE TO PRINT DEST NAME
	PUSHJ P,PRUSIX
	MOVEI A,"."
	HLLZ B,FSPEXT(Z)
	JUMPE B,PRUF01
	IDPB A,Y
	SUBI D,1
	PUSHJ P,PRUSIX
PRUF01:	MOVEI A,"["
	IDPB A,Y
	SUBI D,1
	HLLZ B,FSPPPN(Z)
	PUSHJ P,PRUSIX
	MOVEI A,","
	IDPB A,Y
	SUBI D,1
	HRLZ B,FSPPPN(Z)
	PUSHJ P,PRUSIX
	MOVEI A,"]"
	IDPB A,Y
	SUBI D,1
	MOVEI A,"_"
	IDPB A,Y
	SUBI D,1
PRUF00:	MOVE B,FSNAM(Z)
	PUSHJ P,PRUSIX
	MOVEI A,"."
	HLLZ B,FSEXT(Z)
	JUMPE B,PRUFI1
	IDPB A,Y
	SUBI D,1
	PUSHJ P,PRUSIX
PRUFI1:	MOVEI A,"["
	IDPB A,Y
	SUBI D,1
	HLLZ B,FSPPN(Z)
	PUSHJ P,PRUSIX
	MOVEI A,","
	IDPB A,Y
	SUBI D,1
	HRLZ B,FSPPN(Z)
	PUSHJ P,PRUSIX
	MOVEI A,"]"
	IDPB A,Y
	ADDI D,6		;SUB 1 FOR "]" ADD 7 FOR TAB STOP
	LSH D,-3		;SPACES TO TABS
	MOVEI A,11
	IDPB A,Y
	SOJG D,.-1
	HLRE A,FSPREQ(Z)	;GET STATUS CODE
	JUMPE A,PUX0		;HERE FOR PLIST ONLY, UNPROCESSED TERM
	JUMPGE A,.+2		;JUMP IF NOT RESTORED
	ADDI A,1		;-1 MEANS WAS RESTORED, -2 ALREADY EXISTS
	ADDI A,PKLU		;RANGE -1 TO LPUX-2 CHANGED TO 1 TO LPUX
	CAILE A,LPUX
	MOVEI A,LPUX		;MAX ERROR CODE
PUX0:	MOVE B,PUXSTR(A)	;GET TEXT
	JRST PRUSTR

PKLU__2	;difference between offset in table below and actual code stored
PUXSTR:			[ASCIZ /
/]
			[ASCIZ /Output file already exists
/]
			[ASCIZ /Restored
/]
PNOT__.-PUXSTR-PKLU	[ASCIZ /Not found on tape
/]
PTNF__.-PUXSTR-PKLU	[ASCIZ /Tape not found by operator
/]
PTNR__.-PUXSTR-PKLU	[ASCIZ /Tape unreadable
/]
LPUX__.-1-PUXSTR	;max offset

UNP2QS:	MOVSI A,-3		;SPECIAL CODE, PRINTS NULL IN PUXSTR
	MOVEM A,UNP2QF		;FLAG THAT WE ARE DOING EUQ FILE
	PUSHJ P,DOEUQ		;DO IT
	SETZM UNP2QF		;NOW WE DO QUE IN ADDITION
	MOVE A,['PUMPKI']
	MOVSI B,'QUE'
	MOVE D,DUMPER
	LOOKUP UFD,A		;FIND THE QUEUE FILE
	 JRST PREOF		;NO QUE, WE'RE READY TO GO
	SETZM UFDBUF+2		;ENSURE THAT WE READ A RECORD RIGHT AWAY
	JRST PREQLP		;CONTINUE READING REQUESTS.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         subttl	pumpkin list		; PLIST1 PLIST3 PLIST2 UNPUM1 UNPUM3 UNPUM2 UNPUM5 UNPUM4 UNPUM6 UNPUM8 UNPUM7 UNPUMA UNPUM9 UNPQLP UNPBLK UNPHIT UNPHI1 UNPURD UNPUR1 UNPUIN UNPUI1 UNPEOF UNUEOF UNPLUZ PGETNO PGETN1 PGETN2 PGETN3 DDTKLU DDTENT

PLIST1:	CLOSE UFD,		;LET OTHER PEOPLE AT THE QUEUE
	TLNE FL,L.TURK		;PLIST OR UNPUMPKIN?
	JRST UNPUM1		;UNPUMPKIN
PLIST3:	SKIPN W,TAPES		;LIST QUEUE.  GET A TAPE
	POPJ P,			;NOPE
	HRRZ A,1(W)
	MOVEM A,TAPES		;REMOVE THIS TAPE FROM LIST
	HLRZ Z,1(W)		;GET HEAD OF TERM LIST
PLIST2:	JUMPE Z,PLIST3		;JUMP IF NO MORE TERMS IN THIS TAPE
	MOVE Y,[POINT 7,PLBUF]	;POINTER TO BUFFER FOR OUTPUT LINE
	PUSHJ P,PRLFIL		;LIST THIS TERM
	MOVEI A,0
	IDPB A,Y
	OUTSTR PLBUF
	HRRZ Z,FSPNXT(Z)	;GET NEXT TERM
	JRST PLIST2

UNPUM1:	MOVEI X,0		;COUNT TERMS TYPED
IFE IRCPPN,<
	GETPPN	A,			;GET THE REAL PPN (NOT DSKPPN)
	 JFCL				;DEC NEEDS THIS
>;IFE IRCPPN
IFN IRCPPN,<
	HRROI A,2			;REAL PPN COMES FROM GETTAB
	GETTAB A,
	 GETPPN A,
	  JFCL
>;IFN IRCPPN
	HRRZ R,A		;GET USER'S PRG
UNPUM3:	SKIPN W,TAPES		;LIST QUEUE.  GET A TAPE
	JRST UNPUM6		;NOPE
	HRRZ A,1(W)
	MOVEM A,TAPES		;REMOVE THIS TAPE FROM LIST
	HLRZ Z,1(W)		;GET HEAD OF TERM LIST
UNPUM2:	JUMPE Z,UNPUM3		;JUMP IF NO MORE TERMS IN THIS TAPE
	HRRZ B,FSPREQ(Z)	;GET PRG OF REQUESTOR
	CAIE B,(R)		;IS THIS OUR REQUEST?
	JRST UNPUM4		;NO, FORGET IT
	CAIL X,PUMNUM		;SKIP IF NOT TOO MANY TERMS
	JRST UNPUM8		;OVERFLOW
	JUMPN X,UNPUM5		;JUMP IF WE'VE ALREADY GIVEN HEADER
	OUTSTR [ASCIZ /Here are your PUMPKIN requests:

index	tape	file (or output_input)

/]
UNPUM5:	MOVE Y,[POINT 7,PLBUF]	;POINTER TO BUFFER FOR OUTPUT LINE
	MOVEM Z,UNPUTR(X)	;SAVE POINTER TO TERM BLOCK
	AOS B,X			;NEXT INDEX, READY TO PRINT
	PUSHJ P,PRUDEC
	MOVEI A,11
	IDPB A,Y
	PUSHJ P,PRLFI1		;LIST THIS TERM
	MOVEI A,0
	IDPB A,Y
	OUTSTR PLBUF
UNPUM4:	HRRZ Z,FSPNXT(Z)	;GET NEXT TERM
	JRST UNPUM2

UNPUM6:	JUMPN X,UNPUM7
	OUTSTR [ASCIZ /You have no pending PUMPKIN requests.
/]
	POPJ P,

UNPUM8:	OUTSTR [ASCIZ /That's all I can fit in my buffer!  Complain via GRIPE.
/]
UNPUM7:	OUTSTR [ASCIZ /
To delete a request, type its index number: /]
	PUSHJ P,PGETNO		;GET NUMBER
	 JRST UNPUM7		;BAD FORMAT
	JUMPE B,CPOPJ		;DONE IF NO NUMBER GIVEN
	CAIG B,(X)		;IN RANGE?
	JRST UNPUM9
	OUTSTR [ASCIZ /No such request index.
/]
	JRST UNPUM7

UNPUMA:	OUTSTR [ASCIZ /That request already deleted!
/]
	JRST UNPUM7

UNPUM9:	MOVE S,UNPUTR-1(B)	;GET PATTERN TO MATCH
	SETOM UNPUTR-1(B)	;FLAG IT DONE
	JUMPL S,UNPUMA		;JUMP IF ALREADY DELETED
	INIT UFD,17		;PREPARE TO READ THE REQUEST FILE
	 'DSK   '
	 0
	 PUSHJ P,NODEV		;IT CAN'T HAPPEN HERE?
	MOVE A,['PUMPKI']
	MOVSI B,'QUE'
	SKIPGE FSPREQ(S)	;CHECK WHICH QUEUE THIS IS FROM
	MOVSI B,'EUQ'		; AND OPEN THE RIGHT FILE
	MOVE D,DUMPER
	LOOKUP UFD,A		;FIND THE QUEUE FILE
	 JRST UNPLUZ
	MOVE D,DUMPER
	ENTER UFD,A		;READ/ALTER
	 JRST UNPLUZ
	PUSHJ P,UNPUIN		;READ A RECORD
	 JRST UNUEOF		;HUH? EMPTY FILE
UNPQLP:	PUSHJ P,UNPURD		;READ THE WORD COUNT
	 JRST UNPEOF		;ALL READ IN
	JUMPE A,UNPQLP		;SKIP PADDING WORDS
	MOVE Z,A		;SAVE WORD COUNT
	PUSHJ P,UNPURD		;REQUESTOR'S PPN
	 JRST UNUEOF		; THERE BETTER BE ONE
	MOVEM A,RSTDEV		;SAVE IT HERE TEMPORARILY
	PUSHJ P,UNPURD		;DEST NAME
	 JRST UNUEOF
	MOVEM A,RSTNAM		;AS GOOD A PLACE AS ANY
	PUSHJ P,UNPURD
	 JRST UNUEOF
	MOVEM A,RSTEXT
	PUSHJ P,UNPURD
	 JRST UNUEOF
	MOVEM A,RSTPPN
	SUBI Z,PFSLEN+1		;REMOVE THIS HEADER STUFF FROM WC
	IDIVI Z,PSIZE		;TURN WC INTO BLOCK COUNT
UNPBLK:	MOVEI C,0		;WILL BECOME NONZERO FOR LOSING REQUEST
	PUSHJ P,UNPURD		;READ THE SOURCE POOP
	 JRST UNUEOF		;FIRST WE IGNORE THE DEV WORD
	PUSHJ P,UNPURD
	 JRST UNUEOF
	CAME A,FSNAM(S)		;IS IT THE RIGHT SOURCE NAME?
	MOVNI C,1		;NO
	PUSHJ P,UNPURD
	 JRST UNUEOF
	CAME A,FSEXT(S)
	MOVNI C,1
	PUSHJ P,UNPURD
	 JRST UNUEOF
	CAME A,FSPPN(S)
	MOVNI C,1
	PUSHJ P,UNPURD
	 JRST UNUEOF
;	HLRZS A			;JUST TAPE NUMBER
	TDZ A,[PRMERR,,DATMSK] 	;clear date field & error flag, keep tape/dump nbr
;	HLRZ B,FSDEV(S)		;DITTO FROM TARGET REQUEST
	MOVE B,FSDEV(S)		;DITTO FROM TARGET REQUEST
	TDZ B,[PRMERR,,DATMSK] 	;clear date field & error flag, keep tape/dump nbr
;	CAIE A,(B)		;SAME?
	CAME A,B		;SAME?
	MOVNI C,1		;NOPE
	MOVE B,RSTEXT		;GET DEST EXT AND FLAGS
	MOVE A,RSTNAM		;DEST NAME
	TRNE B,ALLFIL		;WILD?
	MOVE A,FSNAM(S)		;YES, USE SOURCE NAME
	CAME A,FSPNAM(S)	; AS DEST NAME
	MOVNI C,1
	TRNE B,ALLEXT		;WILD EXT?
	HLL B,FSEXT(S)		;YES, USE SOURCE
	HLLZ A,B		;GET EXT W/O FLAGS
	CAME A,FSPEXT(S)
	MOVNI C,1		;NOT THE SAME
	MOVE A,RSTPPN
	TRNE B,ALLPRJ
	HLL A,FSPPN(S)
	TRNE B,ALLPRG
	HRR A,FSPPN(S)
	CAME A,FSPPPN(S)
	MOVNI C,1
	HRRZ A,RSTDEV		;REQUESTOR'S PPN
	HRRZ B,FSPREQ(S)	;DITTO FROM TARGET
	CAIE A,(B)
	MOVNI C,1
	JUMPE C,UNPHIT		;GOTCHA! IF NO MISSES
	SOJG Z,UNPBLK		;FINISH THIS REQUEST
	JRST UNPQLP		;OR GET NEXT REQUEST

UNPHIT:	MOVEI A,-PSIZE+FSNAM(Y)	;ADDRESS OF WORD TO CLOBBER TO ZERO
	CAIL A,UNPBUF		;IS IT IN PREVIOUS RECORD?
	JRST UNPHI1		;NO, EASIER
IFN STANSW,<
	MOVEI B,0		;MAKE SURE NO -1 OR GODMOD
	MTAPE UFD,B		;GET USET POINTER
>;IFN STANSW
IFE STANSW,<
	PRINTX FIGURE OUT HOW TO GET USET POINTER
>;IFE STANSW
	USETI UFD,-2(B)		;WANT RECORD BEFORE THE ONE WE LAST READ
	PUSHJ P,UNPUIN		;READ IT
	 JRST UNUEOF		;OOPS
	ADDI A,200		;MAKE WORD POINTER POINT INTO THE BUFFER
UNPHI1:	SETZM (A)		;FLAG THIS REQUEST DELETED
IFN STANSW,<
	MOVEI B,0		;MAKE SURE NO -1 OR GODMOD
	MTAPE UFD,B		;GET USET POINTER
>;IFN STANSW
IFE STANSW,<
	PRINTX FIGURE OUT HOW TO GET USET POINTER
>;IFE STANSW
	USETO UFD,-1(B)		;WANT THE LAST RECORD WE READ
	OUTPUT UFD,[IOWD 200,UNPBUF
		    0]
	RELEAS UFD,		;WE'VE DONE IT!
	OUTSTR [ASCIZ /OK./]
	JRST UNPUM7		;SEE IF S/HE WANTS ANOTHER ONE

UNPURD:	JUMPL Y,UNPUR1		;JUMP IF BUFFER NOT EMPTY
	PUSHJ P,UNPUIN		;EMPTY, GET ANOTHER
	 POPJ P,		;EOF
UNPUR1:	MOVE A,(Y)		;GET A WORD
	AOBJN Y,CPOPJ1
	JRST CPOPJ1		;SUCCESS RETURN

UNPUIN:	SETZM UNPBUF+1		;DEAL WITH POSSIBLE PARTIAL RECORD, SIGH
	MOVE Y,[UNPBUF+1,,UNPBUF+2]
	BLT Y,UNPBUF+177
	MOVE Y,[525252525252]	;UNLIKELY PATTERN
	MOVEM Y,UNPBUF
	IN UFD,[IOWD 200,UNPBUF
		0]
	 JRST UNPUI1		;SUCCESS
	MOVE Y,UNPBUF		;EOF, WAS THERE ANY DATA AT ALL?
	CAMN Y,[525252525252]	;SKIP IF YES
	POPJ P,			;ERROR OR EOF RETURN
UNPUI1:	MOVE Y,[-200,,UNPBUF]	;SET UP AOBJN FOR UNPURD
	JRST CPOPJ1		;OK RETURN

UNPEOF:				;REALLY ANY NON-HIT IS UNEXPECTED
UNUEOF:	RELEAS UFD,
	OUTSTR [ASCIZ /?? Gee, I can't find the request to delete it!
/]
	POPJ P,

UNPLUZ:	RELEAS UFD,
	OUTSTR [ASCIZ /Sorry, I can't access PUMPKI.QUE; probably busy.
Try again shortly.
/]
	POPJ P,

PGETNO:	MOVEI B,0
PGETN1:	INCHWL A
	CAIN A,15
	JRST PGETN1
	CAIL A,"0"
	CAILE A,"9"
	JRST PGETN2
	IMULI B,12
	ADDI B,-"0"(A)
	JRST PGETN1

PGETN2:	CAIN A,12
	JRST CPOPJ1
PGETN3:	CAIE A,12
	CAIN A,175
	POPJ P,
	INCHWL A
	JRST PGETN3

DDTKLU:	MOVEI A,DDTENT
	SKIPE B,.JBDDT
	SETDDT A,		;MRC SEZ: WHAT? YOU'VE NEVER USED SETDDT?
	MOVEI B,(B)		;I DON'T KNOW OR CARE WHAT'S IN THE LH
	CAIE B,DDTENT		;DON'T CLOBBER DDTADR TWICE
	HRRZM B,DDTADR
	OUTSTR [ASCIZ /Okay./]
	EXIT

DDTENT:	MOVEM A,DDTSVA
	MOVEM B,DDTSVB
IFN STANSW,<			;I DON'T KNOW HOW TO DEAL WITH THIS ELSEWHERE
	MOVSI A,0		;ACTIVE
	GETPRV A,
	IOR A,[LUPPRV!LIVPRV]	;LUP AND LIV FREE IF IN PASSIVE
	MOVSI B,1		;PASSIVE
	GETPRV B,
	AND A,B			;KEEP ONLY PASSIVE-ENABLED ONES
	SETPRV A,
>;IFN STANSW
	MOVE A,DDTSVA
	MOVE B,DDTSVB
	JRST @DDTADR
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                subttl	locate and pumpkin	; PUMPKI PUMPKI PUMP0X PUMP00 DLOCAT PUMP01 PUMP0 PUMP11 PUMP21 PUMP1 PUMP2 DLOC1 DLOC11 LOC1A PLOC1A DLOC20 DLOC2 DLOC22 DLOC2 LPPADV LOCPPS LOCPP1 LOCPP2 LOCPP3 LCPP3A LCPP3B LOCPP4 LCPP4A LCPP4B LOCPP5 LOCPP6 LOCPP7 LOCPP8 LOCPP9 LCPP10 LCPP11 LCPP12 LOCFPD LOCFPA STWILD

NOSAIL,<
PUMPKI:	OUTSTR [ASCIZ/ Forget about getting PUMPKIN to work outside of WAITS.
/]
	EXIT
>;NOSAIL


SAIL,<
PUMPKI:
;	SETZM SWITCH		;No tape or date switches seen yet
	SETOM PUMPCM		;Flag we're doing a PUMPKIN command
	MOVEI A,0
	GETPRV A,		;ACTIVE PRIVS
	TDNE A,[REAPRV!WRTPRV]
	JRST PUMP00		;PRIVS OK
	MOVSI A,1		;must not be monitor command, check SYS group
	GETPRV A,		;get passive privs
	TDNE A,[SYSPRV]		;assume SYS priv user has access to dumper files
	JRST PUMP00		;OK, has SYS priv
	OUTSTR [ASCIZ /The PUMPKIN command can be given only at monitor level,
not after a * prompt from DART.
/]
PUMP0X:	INCHSL A		;ANY CHARS WAITING TO BE READ?
	 EXIT			;NO
	ANDI A,177
	CAIE A,12
	CAIN A,ALTMOD
	EXIT			;CONTROL-CR, CR WILL WORK MAYBE
	JRST PUMP0X		;READ TO END OF LINE
>;SAIL

PUMP00:	TLOA FL,L.PUMP		;THE GREAT PUMPKIN COMES BY NIGHT
DLOCAT:	TLZ FL,L.PUMP		;NOT PUMPKIN
	TLZ FL,L.BOTH
	HRRZM P,SWITOK		;switches OK, except rel dump number switch
	PUSHJ P,SCAN		;SCAN THE COMMAND LINE.
	MOVE R,TBASE		;GET THE BASE OF THE WORLD
	CAML R,FSPTR		;ARE THERE ANY TERMS?
	PUSHJ P,GETBLK		;NO. MAKE ONE.
	MOVE A,USRPPN		;GET USER PPN.
	MOVEM A,STKPPN		;SAVE AS STICKY PPN
	SETZM PRMOK		;ask user about any pumpkin'ing w/prev-media errors
	SETZM STKBIT		;ZERO STICKY BITS
	MOVSI A,'DSK'
	MOVEM A,STKDEV
	MOVE A,FSPTR		;AVOID CLOBBERING DATA
	TLNN FL,L.PUMP		;PUMPKIN COMMAND?
	JRST PUMP1		;NO
;PUMPKIN COMMAND
	MOVEM A,PBASE		;PUMPKIN DATA BASE
	MOVEI X,PFSLEN+1(A)	;SAVE IN AN AC TOO
	HRLI X,-<PFILES*PSIZE>	;MAKE AOBJN FORMAT
	ADDI A,PFILES*PSIZE+PFSLEN+1 ;LEAVE ROOM FOR SOME FILES
	SKIPN Z,DEST		;IS THERE AN EXPLICIT DEST?
	JRST PUMP0		;NO, SKIP THIS CHECK
	MOVS B,FSDEV(Z)		;YES, CHECK THE EXPLICIT DEVICE
	MOVE C,FSPPN(Z)
	CAIN B,'SYS'		;THIS IS THE FILE DISK TOO
	SKIPA C,['  1  3']
	CAIN B,'DSK'		;OUTPUT MUST BE TO THE FILE DISK
	JRST PUMP01
	JUMPE B,PUMP0		;SO IS NO DEVICE AT ALL
	OUTSTR [ASCIZ /Output device must be DSK./]
	JRST RESTAR		;ABANDON COMMAND

PUMP01:	MOVEM C,FSPPN(Z)
PUMP0:	PUSH P,DEST		;SAVE PUMPKIN DESTINATION TERM
	SETZM DEST		;USE THE TTY
	MOVEM A,.JBFF		;WITH BUFFERS
	CAMG A,.JBREL
	JRST PUMP11
	CORE A,
	 JRST NOCORE		;can't get core
PUMP11:	PUSHJ P,LSTINI
	POP P,DEST		;SORRY ABOUT THAT KLUDGE
	MOVEI A,17
	MOVSI B,'DSK'
	SETZ C,
	OPEN DSKMSC,A
	 PUSHJ P,NODEV
	JUMPN Z,.+2		;JUMP IF WE HAVE EXPLICIT DEST
	MOVEI Z,[	'DSK   ' ;ELSE GET DSK:*.*
			0
			ALLFIL!ALLEXT
			0	]
repeat 0,<
	MOVE A,FSEXT(Z)		;SET WILDCARD FLAGS AS NEEDED
	SKIPN B,FSNAM(Z)	;IF NO EXPLICIT FILENAME
	TROE A,ALLFIL		; AND NO EXPLICIT * EITHER,
	JRST PUMP21		;  (NO IMPLICIT .* IF ANY FILENAME)
	TLNN A,-1		; THEN SET .* IF NO EXPLICIT EXT
	TRO A,ALLEXT
PUMP21:	MOVEM A,FSEXT(Z)	;DON'T WORRY, IT WON'T CHANGE THE LITERAL
>;repeat 0
	MOVEI A,FSNAM(Z)	;ptr to filename and ext/wild bits
	PUSHJ P,STWILD		;make omitted filename wild, and maybe ext too
	GETPPN A,		;NOW SET UP VARIOUS DATA FOR ACCESS CHECKING
	MOVEM A,UPPN
	HRRZM A,UPRG

SAIL,<
	MOVSI A,1		;MY JOB'S PASSIVE PRIVS
	GETPRV A,
	MOVEM A,PRIVS
	MOVEI A,0
	DSKPPN A,
	MOVEM A,ALIAS
>;SAIL
	JRST PUMP2


;LOCATE COMMAND
PUMP1:	MOVEM A,.JBFF		;WITH BUFFERS
	CAMLE A,.JBREL
	CORE A,
	 JFCL			;CATCH IT LATER

DRAT,<
	MOVE A,['LOCATE']
	MOVSI B,'BIN'
	MOVEM A,LSTNAM
	MOVEM B,LSTEXT
	SETZM LSTPPN
	PUSHJ P,LSTBIN		;Make binary, not text listings
>;DRAT

NODRAT,<
	PUSHJ P,LSTINI		;DO LISTING TERM.
>;NODRAT

;Both LOCATE and PUMPKIN
PUMP2:
NOSAIL,<
	TLZ FL,L.WLDS		;No WILD Structure:  A wild structure
>;NOSAIL				;is DSK: as opposed to DSKB:
;INITIAL PROCESSING OF SOURCE TERMS
	MOVE R,TBASE
DLOC1:	CAML R,FSPTR		;Skip if in range
SAIL,< 	JRST DLOC2		;DONE.
>;SAIL

NOSAIL,<JRST DLOC20
	SETZM ERSPPN
>;NOSAIL

	SKIPN A,FSDEV(R)	;IS THERE AN EXPLICIT DEVICE?
	MOVE A,STKDEV
	MOVEM A,STKDEV
	MOVEM A,FSDEV(R)	;MAKE IT EXPLICIT

NOSAIL,<
;; LET ME TAKE THIS OPPORTUNITY TO MENTION THAT, ONCE AGAIN, A DEVICE
;; NAME OF THREE OR FEWER CHARACTERS IS TAKEN TO MEAN MORE THAN ONE
;; STRUCTURE, WHILE FOUR OR MORE CHARS IS A SINGLE STRUCTURE!
	TRNN A,-1
	TLO FL,L.WLDS		;FLAG TO SCAN ALL STRUCTURES
	DEVCHR A,
	TLNN A,DEVDSK
	JRST NOTDSK
	MOVE A,FSDEV(R)		;GET THE NAME AGAIN
	MOVE B,A
	DEVPPN B,		;KLUDGE FOR ERSATZ DEVICES
	 JRST DLOC11		;NO SUCH THING
	CAMN B,USRPPN		;IF I'D WRITTEN THE UUO,
	JRST DLOC11		; IT'D RETURN 0 NOT USRPPN
	MOVEM B,ERSPPN		;SAVE ERSATZ PPN
	HRLI A,'DSK'		;TURN SYSB: INTO DSKB: ETC.
	MOVEM A,FSDEV(R)	;BUT NOT IN STKDEV
DLOC11:
>;NOSAIL

	MOVEI B,ALLPRJ!ALLPRG
	AND B,FSEXT(R)
	SKIPN A,FSPPN(R)

SAIL,<	JUMPE B,[MOVE A,STKPPN
		MOVE B,STKBIT	;GET STICKY BITS
		JRST LOC1A]
>;SAIL

NOSAIL,<JUMPE B,[SKIPN A,ERSPPN	;NOTE THAT EXPLICIT PPN
		 SKIPA A,STKPPN	;OVERRIDES ERSATZ DEVICE
		 JRST LOC1A
		 MOVE B,STKBIT
		 JRST LOC1A]
>;NOSAIL

	MOVEM A,STKPPN
	MOVEM B,STKBIT
LOC1A:	MOVEM A,FSPPN(R)
	IORM B,FSEXT(R)		;SAVE BITS
repeat 0,<
	MOVE C,FSEXT(R)
	MOVEI B,ALLFIL!ALLEXT	;any wild name?
	TRNE C,GOTEXT		;skip unless really have extension (saw a dot)
	MOVEI B,ALLFIL		;don't make extension wild, just maybe file name
	TRNN C,ALLFIL		; and no wild file name
	SKIPE FSNAM(R)		;if no file name,
	CAIA
	IORM B,FSEXT(R)		;then make omitted filename (and maybe ext) wild
>;repeat 0
	MOVEI A,FSNAM(R)	;ptr to filename and ext/wild bits
	PUSHJ P,STWILD		;make omitted filename wild, and maybe ext too
	TLNN FL,L.PUMP
	JRST PLOC1A
;PUMPKIN Command
	MOVE C,FSEXT(R)		;CHECK FOR PUMPKIN *.*
	TRC C,ALLFIL!ALLEXT
	TRNE C,ALLFIL!ALLEXT
	JRST PLOC1A		;NO, OK
	OUTSTR [ASCIZ /PUMPKIN *.* is illegal./]
	JRST RESTAR		;ABANDON COMMAND

;everyone
PLOC1A:	ADDI R,FSLEN
	JRST DLOC1

NOSAIL,<
DLOC20:	SETZM RSTDEV		;INITIAL ARG FOR SYSSTR
DLOC2:	TLNN FL,L.WLDS		;HERE FOR NEXT STRUCTURE
	JRST DLOC22		;REG'S CODE WORKS IF NO WILD
	MOVE A,RSTDEV		;ELSE WE LOOP THROUGH ALL STRS
	SYSSTR A,
	 TLZA FL,L.WLDS		;ABORT TO REG MODE
	MOVEM A,RSTDEV
	TLNE FL,L.WLDS		;TEST AGAIN IN CASE SYSSTR FAILED
	JUMPE A,LOCFIN		;THIS IS OUR END TEST
DLOC22:
>;NOSAIL

SAIL,<
DLOC2:
>;SAIL
;HERE TO PROCESS ALL TERMS FOR ONE SOURCE DEVICE
	MOVE R,TBASE		;GET THE FIRST FREE ONE.
	CAML R,FSPTR		;IN RANGE?
	JRST LOCFIN		;DONE. FINISH LISTING FILE
	MOVE A,FSDEV(R)
NOSAIL,<TLNN FL,L.WLDS		;HANDS OFF MY STR LIST!
>;NOSAIL
	MOVEM A,RSTDEV		;PARAMETER FOR LOCRD1
	PUSH P,.JBFF		;REMEMBER .JBFF
	PUSHJ P,LOCRD1		;INITIALIZE LOCATE READER--READ INDEX FILES
	JRST LOCPPS		;GO SELECT A PPN

;IN THE CODE THAT FOLLOWS, ANEED ON MEANS WE HAVE TO READ ARC, 
;			   DNEED ON MEANS WE HAVE TO READ DAT.
;NOTE THIS DIFFERENT FROM THEIR MEANINGS IN MERGE/ARCHIVE

LPPADV:	MOVE A,[2,,2]		;INCREMENT TO AN AOBJN POINTER
	TLNE FL,DNEED		;HERE TO ADVANCE OVER A PPN.
	ADDM A,DATIDX		;ADVANCE IN DAT FILE
	TLNE FL,ANEED
	ADDM A,ARCIDX		;ADVANCE IN ARC FILE
LOCPPS:	TLO FL,ANEED!DNEED	;HERE TO SELECT NEXT PPN. FLAG ASSUME BOTH
	SKIPL Q,ARCIDX		;SKIP IF THERE ARE ARC PPNS LEFT
	JRST LOCPP1		;NONE.  SELECT NEXT DAT PPN, IF ANY
	SKIPL S,DATIDX		;SKIP IF THERE ARE DAT PPNS LEFT
	JRST LOCPP2		;NONE. USE THE NEXT ARC PPN.
	MOVE A,(Q)
	CAMN A,(S)
	JRST LOCPP3		;GO SELECT BOTH! (ARC AND DAT PPNS THE SAME)
	PUSHJ P,UFDCNV		;swap PPN halves and left justify each
	MOVEM A,DNX		;store ARC PPN
	MOVE A,(S)
	PUSHJ P,UFDCNV		;swap PPN halves and left justify each
	MOVEM A,TNX		;store DAT PPN
	PUSHJ P,PPNCMP		;compare DNX,TNX (2,3,SYS are special)
	 JRST LOCPP2		;DNX<TNX (ARC<DAT).  SELECT ARC NEXT. (>>matching)
LOCPP1:	SKIPL DATIDX
	JRST LOC9		;END OF ALL TERMS ON BOTH FILES
	TLZA FL,ANEED		;FLAG DAT NEXT (NOT ARC)
LOCPP2:	TLZA FL,DNEED		;FLAG ARC NEXT (NOT DAT)
LOCPP3:	SKIPA A,DATIDX		;1 = DAT, 2 = ARC, 3 = BOTH
	MOVE A,ARCIDX
	MOVE A,(A)		;GET NEXT PPN.
	MOVEM A,RSTPPN		;SAVE THE PPN NAME HERE FOR A WHILE.
	PUSHJ P,LCPPCK		;CHECK IF WE'RE INTERESTED IN THIS PPN.
	 JRST LPPADV		;NO.  ADVANCE TO NEXT PPN.
				;NOW POSITION THE INPUT FILE(S)
	TLNN FL,DNEED		;NEED DAT?
	JRST LOCPP4		;NO
	MOVE A,DATIDX		;ARGUMENT TO PPNPOS
	PUSHJ P,PPNPOS		;POSITION AT PPN
	 USETI UFD,1(A)		;ARGUMENT TO PPNPOS
	 PUSHJ P,UFDRD		;ARGUMENT TO PPNPOS
	CAME A,RSTPPN		;REDUNDANCY CHECK!
	HALT .
	TLNE FL,ANEED		;NEED BOTH DAT AND ARC?
	JRST LOCPP4		;YES.
LCPP3A:	PUSHJ P,LOCFPR		;READ EVERYTHING AND TYPE RELEVANT STUFF
	 PUSHJ P,UFDRD		;ARGUMENT
LCPP3B:	SKIPE RSTNAM		;END OF PPN YET?
	JRST LCPP3A		;no
	JRST LOCPP5		;ADVANCE TO NEXT PPN

LOCPP4:	MOVE A,ARCIDX		;ARGUMENT TO PPNPOS
	PUSHJ P,PPNPOS		;POSITION AT PPN
	 USETI FILE,1(A)	;ARGUMENT TO PPNPOS
	 PUSHJ P,DFREAD		;ARGUMENT TO PPNPOS
	CAME A,RSTPPN		;REDUNDANCY CHECK!
	HALT .
	TLNE FL,DNEED		;NEED BOTH DAT AND ARC?
	JRST LOCPP6		;YES.  THIS IS HARDER
LCPP4A:	PUSHJ P,LOCFPR		;READ EVERYTHING AND TYPE RELEVANT STUFF
	 PUSHJ P,DFREAD		;ARGUMENT
LCPP4B:	SKIPE RSTNAM		;end of PPN?
	JRST LCPP4A		;no
LOCPP5:	MOVE Q,TBASE		;CHECK FOR NO MORE TERMS..
	CAMGE Q,FSPTR
	JRST LPPADV		;MORE WORK LEFT. ADVANCE TO NEXT PPN.
	POP P,.JBFF
	CLOSE UFD,
	CLOSE FILE,
	JRST LOCFIN		;RELEASE LISTING DEVICE.

;HERE WE HAVE TO READ BOTH FILES
LOCPP6:	SETZM ANAME
	SETZM DNAME
LOCPP7:	SKIPE ANAME
	JRST LOCPP8		;WE HAVE ANAME ALREADY
	PUSHJ P,DFREAD
	MOVEM A,ANAME		;STORE ANAME
	JUMPE A,LOCPP8		;LAST ONE DONE
	PUSHJ P,DFREAD
	MOVEM A,AEXT		;STORE EXTENSION
LOCPP8:	SKIPE DNAME
	JRST LOCPP9		;WE HAVE DNAME ALREADY
	PUSHJ P,UFDRD		;READ NEXT FILE NAME
	JFCL
	MOVEM A,DNAME
	JUMPE A,LOCPP9		;JUMP IF LAST NAME READ
	PUSHJ P,UFDRD		;READ EXT
	JFCL
	MOVEM A,DEXT
LOCPP9:	SKIPN ANAME		;ANY ARC DATA LEFT?
	JRST LOCFPD		;NO. LET'S GO FLUSH DAT DATA
	SKIPN A,DNAME		;ANY ARC DATA LEFT
	JRST LOCFPA		;NONE LEFT
	CAMLE A,ANAME		;
	JRST LCPP11		;A<D - FLUSH A FIRST.
	CAME A,ANAME		;A=D?
	JRST LCPP10		;A>D - FLUSH D FIRST
	HLLZ A,DEXT
	HLLZ B,AEXT
	CAMLE A,B
	JRST LCPP11		;A<D
	CAMN A,B
	JRST LCPP12		;EQUAL.  THIS IS TOUGH.
LCPP10:	MOVE A,DNAME		;A>D  FLUSHING DAT
	MOVEM A,RSTNAM
	MOVE A,DEXT
	PUSHJ P,LOCFP0		;DO FILE.
	 PUSHJ P,UFDRD		;ARGUMENT
	SETZM DNAME
	JRST LOCPP8

LCPP11:	MOVE A,ANAME		;A<D  FLUSHING ARC (>matching)
	MOVEM A,RSTNAM
	MOVE A,AEXT
	PUSHJ P,LOCFP0		;DO FILE.
	 PUSHJ P,DFREAD		;ARGUMENT
	SETZM ANAME
	JRST LOCPP7

LCPP12:	MOVE A,DNAME
	MOVEM A,RSTNAM
	MOVE A,DEXT
	TLO FL,L.BOTH		;IF PUMPKIN COMMAND, WE NEED TO KNOW THIS
	PUSHJ P,LOCFP0
	 PUSHJ P,UFDRD
	MOVE A,AEXT
	HRRZM A,IWC
	PUSHJ P,LOCFPX		;ENTER AND DECIDE WHETHER TO PRINT OR NOT
	 PUSHJ P,DFREAD
	SETZM ANAME
	SETZM DNAME
	JRST LOCPP7


LOCFPD:	SKIPN A,DNAME		;HERE TO FLUSH REST OF DAT IN MERGE
	JRST LOCPP5		;NO DAT DATA LEFT.
	MOVEM A,RSTNAM
	MOVE A,DEXT
	PUSHJ P,LOCFP0		;READ FILE DATA. TYPE IF RELEVANT
	 PUSHJ P,UFDRD		;ARGUMENT
	JRST LCPP3B		;ADVANCE TO NEXT FILE

LOCFPA:	MOVE A,ANAME		;HERE TO FLUSH REST OF ARC IN MERGE
	MOVEM A,RSTNAM
	MOVE A,AEXT
	PUSHJ P,LOCFP0		;READ EVERYTHING AND TYPE RELEVANT STUFF
	 PUSHJ P,DFREAD		;ARGUMENT
	JRST LCPP4B		;ADVANCE TO NEXT FILE

;Set wild bits for omitted filename and maybe extension.
;Call with (A) pointing to filename, 1(A) pointing to wild bits in RH.
;Clobbers LH of A.
STWILD:	HRL A,1(A)		;get wild bits
	SKIPN (A)		;do nothing if explicit file name
	TLOE A,ALLFIL		;make file name wild, unless already wild
	POPJ P,			;file name already specified, no implicit wildness
	TLNN A,GOTEXT		;skip if saw dot -- explicit extension
	TLO A,ALLEXT		;make extension wild too
	HLRM A,1(A)		;save additional wild bits
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             subttl locate/pumpkin printer	; LOCFPR LOCFP0 LOCFP1 LOCFP2 LOCFP3 LOCFP4 LOCFP5 LOCFP6 DRATL1 LOCFP7 LOCF7X LOCFP8 LOCF9U LOCF9T LOCF9Y LOCF9W LOCF9V RELOOK ACCOK LOCLKF PBUSY PNOACC PNOAC1 PNOAC2 LOCF9X LOCF9D LOCPRO LOCTRM LOCF9Z LOCF9E LOCPRE LOCHL2 LOCGO LOCUSE LOCOK LOCIGN LOCHLP LOCF8Z LOCF8Y LOCFPX LOCFXX LOCFPZ LOC9 LOC9A LOC9B PFIFP7 LOC9Z PPNPOS PPNPS1 LCPPCK LCPPC1 LCPPC2 IDXPCK IDXPC1 LOCRD1 NEWARC LCR0.0 LCR0.1 LCR0.2 LCR0.3 LCR0.4 INDGET INDGT0 INDGT1 INDGT3 INDGTX CREARC LOCFIN LOCFRT PUMXIT PMPLUZ NULPUM ACCCHK OWNACC GRPCHK GRPWIN SCDIDX FDATIM

;When we find a term matching some dumped file, we set ALLFLG in that term
;to indicate that the term has been dumped.  When we type out actual location
;information (tape and date), we set ABFILE in that term.  When we're done
;with the entire database, for all files without ALLFLG, we say "never dumped";
;for all files with ALLFLG but not ABFILE, we say "not found with requested
;tape/dump or date".  (ALLFLG and ABFILE are arbitrarily chosen flag bits.)


;HERE'S THE ROUTINE THAT PRINTS THINGS.  CALL IT WITH RSTNAM AND RSTEXT SET UP
;Prints matches for one file in one PPN.
;Returns with RSTNAM zero if hits end of PPN.
LOCFPR:	XCT @(P)		;read a word -- file name
	 JFCL			;ignore possible skip
	MOVEM A,RSTNAM
	JUMPE A,CPOPJ1		;END OF PPN DATA
	XCT @(P)		;read a word -- extension word
	 JFCL			;ignore possible skip
;Enter here if filename and ext already read.  Filename stored in RSTNAM, ext in A.
LOCFP0:	HLLZM A,RSTEXT
	HRRZM A,IWC		;SET UP NAME, EXT, AND COUNT of tape,,date words
;Check all file terms against this filename.
	MOVE Q,TBASE		;GET THE BASE OF ALL TERMS
;Check next term.
LOCFP1:	CAML Q,FSPTR		;ARE WE IN RANGE?
	JRST LOCFPZ		;NO.  SKIP THIS FILE.
	ADDI Q,FSLEN
	MOVE A,FSDEV-FSLEN(Q)
	CAME A,RSTDEV		;SAME DEVICE?
IFE STANSW,<
	TRNN A,-1		;OK ALSO IF WILD STR
	JRST .+2		;IE DSK: OR ALL:
>;IFE STANSW
	JRST LOCFP1		;NO.
	HRRZ B,FSEXT-FSLEN(Q)	;GET FLAGS
	TRNE B,ALLPRG
	JRST LOCFP2		;ACCEPT PROGRAMMER NAME
	HRRZ A,FSPPN-FSLEN(Q)	;GET THE PROGRAMMER
	HRRZ C,RSTPPN
	CAME A,C		;MATCH?
	JRST LOCFP1		;NO. REJECT THIS TERM
LOCFP2:	TRNE B,ALLPRJ
	JRST LOCFP3		;ACCEPT PROJECT
	HLLZ A,FSPPN-FSLEN(Q)
	HLLZ C,RSTPPN
	CAME A,C
	JRST LOCFP1		;REJECT THIS TERM
LOCFP3:	TRNE B,ALLFIL		;HERE PPN MATCHES.  FILE NAME OK?
	JRST LOCFP4		;ANY FILE NAME IS OK
	MOVE A,FSNAM-FSLEN(Q)
	CAME A,RSTNAM
	JRST LOCFP1		;FAILS TO MATCH THIS TERM
LOCFP4:	TRNE B,ALLEXT		;EXTENSION OK?
	JRST LOCFP5		;YES. ANY EXT WILL DO
	HLLZ A,FSEXT-FSLEN(Q)
	CAME A,RSTEXT
	JRST LOCFP1		;EXT FAILS
LOCFP5:	MOVEI A,ALLFLG		;RANDOM FLAG BIT, indicates match found for term
	IORM A,FSEXT-FSLEN(Q)	;FLAG THIS ONE FOUND (not necessarily typed out)
	MOVE A,FSTAP-FSLEN(Q)	;get the tape request word
	MOVEM A,GLOTAP		;save it temporarily, past freeing of term
repeat 0,<
	TRNE B,ALLMSK		;WAS THERE ANYTHING WILD?
	JRST LOCFP6		;YES. KEEP THIS SOURCE TERM FOR LATER
	SUBI Q,FSLEN		;DECREMENT Q - FLUSH THIS SOURCE TERM 
	HRLZ A,TBASE		;SOURCE - MOVE BOTTOM TERM UP ONTO THIS TERM
	HRRI A,(Q)		;DESTINATION
	BLT A,FSLEN-1(Q)	;COPY BOTTOM TERM TO THIS TERM
	MOVEI A,FSLEN
	ADDM A,TBASE		;PUSH TBASE UP PAST OLD COPY.
LOCFP6:
>;repeat 0

DRAT,<				;Here's the DRAT LOCATE command Kludge
	MOVE A,RSTPPN		;send four words:
	PUSHJ P,LSTOUT		;ppn
	MOVE A,RSTNAM		;name
	PUSHJ P,LSTOUT
	XCT @(P)		;get the tape # and date word
	JFCL
	HLLZ B,RSTEXT
	HLR B,A			;EXT,,TAPE (+400000 if T)
	MOVE A,B
	PUSHJ P,LSTOUT
	MOVEI A,0
	PUSHJ P,LSTOUT
DRATL1:	SOSG IWC
	JRST CPOPJ1		;exit.
	XCT @(P)		;flush data
	JFCL
	JRST DRATL1
>;DRAT

	MOVE A,RSTDEV		;PRINT DATA.  GET THE DEVICE NAME
	TLNE FL,L.PUMP
	MOVEM A,PDEV(X)		;SAVE IN PUMPKIN DATA BASE
repeat 0,<
	CAMN A,['DSK   ']	;IS THE DEFAULT NAME?
	JRST LOCFP7		;YES. DONT PRINT
	PUSHJ P,SIXOUT		;TYPE SIXBIT DEVICE NAME
	MOVEI A,":"
	PUSHJ P,OUT.CH
	MOVEI A,11
	PUSHJ P,OUT.CH
LOCFP7:
>;repeat 0
	MOVE A,RSTNAM
	HLLZ B,RSTEXT
	MOVE D,RSTPPN
	TLNN FL,L.PUMP
	JRST LOCF7X		;JUMP IF NOT PUMPKIN CMD
	MOVEM A,PNAME(X)	;PUMPKIN, SAVE THE POOP
	MOVEM B,PEXT(X)
	MOVEM D,PPPN(X)
LOCF7X:
repeat 0,<
	PUSHJ P,TYFIL		;type filename on initially finding it in database
	MOVEI A,11
	PUSHJ P,OUT.CH
>;repeat 0
	TRZ FL,ALLFLG		;nothing reported yet for this file
LOCFP8:	XCT @(P)		;READ MORE -- tape,,date etc.
	 JFCL
	MOVE B,GLOTAP		;want specific tape?
	TLNN B,TAPMSK		;any tape number?
	JRST LOCF9Y		;NO, maybe SPECIFIC DATE
	MOVE C,A		;copy dump info
	AND C,[RDHMSK!TAPMSK,,RDLMSK] ;just tape and dump numbers
	TDNN B,[RDHMSK,,RDLMSK]	;any dump number?
	TDZ C,[RDHMSK,,RDLMSK]	;no, clear dump number from dump info
	CAME B,C
	JRST LOCF9Z		;NO
	JRST LOCF9W		;YES

;Here when want to type first line of dump info for a given file.
;Type out the filename.
LOCF9U:	MOVE A,RSTDEV		;PRINT DATA.  GET THE DEVICE NAME
	CAMN A,['DSK   ']	;IS THE DEFAULT NAME?
	JRST LOCF9T		;YES. DONT PRINT
	PUSHJ P,SIXOUT		;TYPE SIXBIT DEVICE NAME
	MOVEI A,":"
	PUSHJ P,OUT.CH
	MOVEI A,11
	PUSHJ P,OUT.CH
LOCF9T:	MOVE A,RSTNAM
	HLLZ B,RSTEXT
	MOVE D,RSTPPN
	PUSHJ P,TYFIL		;type filename on first line of dump info
	MOVEI A,11
	PUSHJ P,OUT.CH
	JRST LOCF9V		;now type out dump info

LOCF9Y:	TRNN B,DATMSK		;no target tape, try target date
	JRST LOCF9W		;NO TARGET date either, WE'LL TAKE IT
	HRRZ C,A		;GET DATE
	ANDI C,DATMSK		;just the date bits (ignore extra bits)
	CAILE C,(B)		;OK IF CANDIDATE  TARGET
	JRST LOCF9Z		;NOPE
LOCF9W:	PUSH P,A		;save tape,,date etc.
	TRON FL,ALLFLG		;skip if this is second or later line for file
	JRST LOCF9U		;first hit, type filename
	MOVEI A,11		;HERE FOR SECOND & SUBSEQUENT LINES
	PUSHJ P,OUT.CH		;type tabs instead of filename
	PUSHJ P,OUT.CH
	MOVE B,RSTDEV
	CAME B,['DSK   ']
	PUSHJ P,OUT.CH
	PUSHJ P,OUT.CH
LOCF9V:	TLNN FL,L.PUMP		;PUMPKIN COMMAND?
	JRST LOCF9X		;no, no protection check
;Now we will check the protection of the indicated output file and directory,
;to make sure the PUMPKIN requestor is allowed to write such a file.
	MOVE A,(P)		;get back tape,,date
	MOVEM A,PTPDT(X)	;MATCH, SAVE THE POOP
	MOVE A,FSNAM(Z)		;SET UP ACS WITH DEST FILENAME FOR LOOKUP
	MOVE B,FSEXT(Z)
	SKIPN D,FSPPN(Z)
	MOVE D,ALIAS		;ALIAS IS DEFAULT PPN
	TRNE B,ALLFIL		;COPY SOURCE TOKENS AS PER * FLAGS
	MOVE A,PNAME(X)
	TRNE B,ALLEXT
	HLL B,PEXT(X)
	TRNE B,ALLPRJ
	HLL D,PPPN(X)
	TRNE B,ALLPRG
	HRR D,PPPN(X)		;(NOTE ALLPRJ AND ALLPRG DEFAULT OFF)
	HLLZS B			;FLUSH FLAGS FROM EXT WORD
	CAMN D,['  1  1']
	JRST PNOACC		;DON'T EVEN BOTHER TRYING THIS
	MOVEM D,LOCLUK		;PPN IS FILENAME FOR UFD
	HRLZI K,'UFD'
	MOVEM K,LOCLUK+1
	SETZM LOCLUK+2
	MOVE K,['  1  1']
	MOVEM K,LOCLUK+3
	LOOKUP DSKMSC,LOCLUK
	 JRST PNOACC		;NO ACCESS IF CAN'T LOOK UP UFD
	PUSHJ P,GRPCHK		;CHECK GROUP ACCESS BITS
	PUSHJ P,ACCCHK		;CHECK ACCESS
	 JRST PNOACC
	MOVEI K,20		;FILE BUSY RETRY COUNT
RELOOK:	MOVEM D,LOCLUK+3	;store PPN of PUMPKIN output file to be checked
	MOVEM A,LOCLUK		;and name
	HLLZM B,LOCLUK+1	;and extension
	SETZM LOCLUK+2
	LOOKUP DSKMSC,LOCLUK	;NOW WE CHECK THE ACTUAL FILE
	 JRST LOCLKF		;LOOKUP FAILED, COMPLICATED
	PUSHJ P,ACCCHK		;CHECK FILE ACCESS
	 JRST PNOACC
ACCOK:	CLOSE DSKMSC,		;DONE READING FILE FOR ACCESS CHECK
	JRST LOCF9X		;ACCESS ALLOWED

LOCLKF:	HRRZ C,LOCLUK+1		;GET LOOKUP ERROR CODE
	JUMPE C,ACCOK		;NOT FOUND, ACCESS OK
	CAIE C,3		;FILE BUSY?
	JRST PNOACC		;NO, LOSE
	SOJLE K,PBUSY		;CAN'T WAIT FOREVER
	MOVEI C,1
	SLEEP C,
	JRST RELOOK

PBUSY:	PUSH P,D
	PUSH P,B
	PUSH P,A
	MOVEI B,[ASCIZ /file busy, can't check access to DSK:/]
	JRST PNOAC1

PNOACC:	PUSH P,D
	PUSH P,B
	PUSH P,A
	MOVEI B,[ASCIZ /no write access allowed to DSK:/]
PNOAC1:	PUSHJ P,STROUT
	POP P,A
	PUSHJ P,SIXOUT
	POP P,B
	JUMPE B,PNOAC2
	MOVEI A,"."
	PUSHJ P,OUT.CH
	MOVE A,B
	PUSHJ P,SIXOUT
PNOAC2:	POP P,A
	PUSHJ P,PPNOUT
	MOVEI B,CRLF
	PUSHJ P,STROUT
	CLOSE DSKMSC,
	SUB X,[PSIZE,,PSIZE]	;NOT OK, CORRECT FOR LATER ADD
	POP P,A
	JRST LOCF8Y		;PRETEND WE WON

LOCF9X:	MOVE A,(P)		;get back tape,,date
	ANDI A,DATMSK		;just the date bits
	PUSHJ P,TYDATE		;TYPE FILE DATE
	MOVEI A,11
	PUSHJ P,OUT.CH
	MOVEI A,"P"		;ASSUME P CLASS TAPE
	SKIPGE (P)
	MOVEI A,"T"		;WRONG.  WAS T CLASS
	PUSHJ P,OUT.CH
	HLRZ A,(P)		;get tape number
	ANDI A,TAPMSK		;clear extra bits leaving only tape number
	PUSHJ P,DECOUT		;TAPE NUMBER
	LDB A,[POINT RDLBTS,(P),RDLPOS] ;get low bits of relative dump nbr
	LDB B,[POINT RDHBTS,(P),RDHPOS] ;get high bits of relative dump nbr
	DPB B,[POINT RDHBTS,A,35-RDLBTS] ;combine high and low bits
	JUMPE A,LOCF9D		;jump if no relative dump bits
	PUSH P,A		;save rel dump number
	MOVEI A,"/"
	PUSHJ P,OUT.CH
	POP P,A			;rel dump nbr
	PUSHJ P,DECOUT		;output relative dump number
LOCF9D:	POP P,A			;tape,,date etc.
	TLNE A,PRMERR		;skip unless errors occurred during tape copy
	PUSHJ P,LOCPRE		;report error -- if pumpkin, maybe ignore version
	 JRST LOCPRO		;use this file version
	MOVEI B,[ASCIZ/  Ignoring above file version, looking for another version.
/]
	PUSHJ P,STROUT
repeat 0,<
	MOVE A,RSTNAM
	HLLZ B,RSTEXT
	MOVE D,RSTPPN
	PUSHJ P,TYFIL		;type out file name again
	MOVEI A,11
	PUSHJ P,OUT.CH		;and a tab
>;repeat 0
	TRZ FL,ALLFLG		;need to say something for this file still
	JRST LOCF9Z		;ignore file with prev-media errors, keep looking

LOCPRO:	MOVEI B,CRLF
	PUSHJ P,STROUT
	JUMPE Q,LOCTRM		;jump if already flushed this term
	MOVEI A,ABFILE		;RANDOM FLAG BIT, indicates term typed out
	IORB A,FSEXT-FSLEN(Q)	;term typed out (accepted if pump w/prv med err)
	TRNE A,ALLMSK		;WAS THERE ANYTHING WILD?
	JRST LOCTRM		;YES. KEEP THIS SOURCE TERM FOR LATER
;	SUBI Q,FSLEN		;DECREMENT Q - FLUSH THIS SOURCE TERM 
	HRLZ A,TBASE		;SOURCE - MOVE BOTTOM TERM UP ONTO THIS TERM
	HRRI A,-FSLEN(Q)	;DESTINATION
	BLT A,-1(Q)		;COPY BOTTOM TERM TO THIS TERM
	MOVEI A,FSLEN
	ADDM A,TBASE		;PUSH TBASE UP PAST OLD COPY.
	MOVEI Q,0		;indicate that we've flushed the term now
LOCTRM:
;in case you want blessed silence (one line per file) from locate,
;Starting at TLNE change it to:
;	XCT @(P)
;	 JFCL
;LOCF9Z:SOSLE IWC
;	JRST .-3
;
	TLNE FL,L.PUMP
	JRST LOCF8Y		;WINNER, THAT'S ALL IF PUMPKIN
LOCF9Z:	SOSLE IWC
	JRST LOCFP8
repeat 0,<
;	TLNE FL,L.PUMP
	TLNE FL,L.BOTH		;MESSAGE PREMATURE IF STILL HAVE ARC TO READ
	JRST LOCF9E
	MOVEI B,[ASCIZ /not available with specified tape or date.
/]
	TRNN FL,ALLFLG		;skip if we said something already
	PUSHJ P,STROUT
>;repeat 0
LOCF9E:	TRNE FL,LSTTTY
	CLOSE LST,		;IF LISTING ON TTY, FORCE IT NOW.
	SETZM LQUIET
	JRST CPOPJ1		;RETURN TO PROCESS NEXT FILE

;Here if file version has previous media errors.
;Take direct return if should use it (or if not pumpkin cmd).
;Take skip return if should ignore it.
LOCPRE:	MOVEI B,[ASCIZ/ (errors from prev. media)/]
	PUSHJ P,STROUT		;warn about previous media errors
	TLNE FL,L.PUMP		;skip unless pumpkin
	SKIPLE C,PRMOK		;skip unless previous media errors OK
	POPJ P,			;OK to use files with prev-media errors
	JUMPL C,LOCIGN		;jump to ignore this file automatically
	TRNE FL,LSTTTY
	CLOSE LST,		;if listing on tty, force it now.
LOCHL2:	CLRBFI
	OUTSTR [ASCIZ/
Ignore version with previous-media errors?  (Type ? for help.) /]
	PUSH P,A		;save tape/date word
	PUSHJ P,GETWRD		;get terminal response
	POP P,B
	EXCH A,B		;put tape/date word back into A
	CAME B,['G     ']
	CAMN B,['GO    ']
	JRST LOCGO		;ignore all such file versions
	CAMN B,['U     ']
	JRST LOCUSE		;use all such file versions
	CAME B,['US    ']
	CAMN B,['USE   ']
	JRST LOCUSE		;use all such file versions
	CAMN B,['Y     ']
	JRST CPOPJ1		;ignore this file version
	CAME B,['YE    ']
	CAMN B,['YES   ']
	JRST CPOPJ1		;ignore this file version
	CAME B,['N     ']
	CAMN B,['NO    ']
	JRST LOCOK		;use this file version
	JRST LOCHLP		;invalid response, report the options

;Said GO, to ignore versions with errors.
LOCGO:	SETOM PRMOK		;negative to ignore all prev-media error versions
	JRST CPOPJ1		;ignore this version

;Said USE versions with errors.
LOCUSE:	HRRZM P,PRMOK		;positive to use all prev-media error versions
;Said NO, don't ignore -- OK to use this version.
LOCOK:	OUTSTR [ASCIZ/  OK, will restore above version./]
	POPJ P,			;use this version

;Here if automatically ignoring version with prev. media errors.
LOCIGN:	MOVEI B,CRLF
	PUSHJ P,STROUT
	JRST CPOPJ1

;Unrecognized response, list the choices.
LOCHLP:	OUTSTR [ASCIZ/This file version had tape errors when it was copied from 800 bpi to 6250 bpi.
Your options are:
  YES	ignore this file version (look for another version)
  NO	use this file version (don't ignore it)
  GO	ignore all file versions with previous media errors (won't ask again)
  USE	use any file versions despite previous media errors (won't ask again)
  HELP	type these choices./]
	JRST LOCHL2

;Here for Pumpkin to skip past tape,,date words after selected one (or no access).
LOCF8Z:	XCT @(P)		;READ MORE -- tape,,date etc.
	 JFCL			; SKIPPING OVER UNNECESSARY TAPES
LOCF8Y:	SOSLE IWC
	JRST LOCF8Z
	TLZ FL,L.BOTH		;IF WINNING IN DAT, DON'T NEED ARC
	ADD X,[PSIZE,,PSIZE]	;SKIP OVER WINNING ENTRY
	JUMPL X,LOCF9E
	CLOSE LST,
	OUTSTR [ASCIZ /Sorry, too many files requested.  Will only recover these.
/]
	JRST LOCFIN

LOCFPX:	TLNN FL,L.PUMP		;HERE TO READ ARC AFTER DAT, SAME NAME
	JRST LOCFXX		;RELATIVELY SIMPLE IF NOT PUMPKIN
	SKIPN LQUIET
	TLZN FL,L.BOTH		;DID WE GET A WINNER IN DAT?
	JRST LOCFPZ		;YES, MAKE IT QUIET
	JRST LOCFP8		;NO, KEEP TRYING OUT LOUD

LOCFXX:	SKIPN LQUIET
	JRST LOCFP8		;MAKE NOISE
LOCFPZ:	XCT @(P)		;read word -- tape,,date (etc.)
	 JFCL
	SOSLE IWC		;skip if no more tape,,date words
	JRST LOCFPZ		;ignore more tape,,date words
	SETOM LQUIET
	JRST CPOPJ1		;RETURN TO PROCESS NEXT FILE.

;HERE AT EOF ON DATA FILE FOR SOME SOURCE DEVICE.  FLUSH ALL TERMS FROM THAT DEVICE
LOC9:	POP P,.JBFF
	CLOSE UFD,
	CLOSE FILE,
	SKIPA R,TBASE		;BASE
LOC9A:	ADDI R,FSLEN
LOC9B:	CAML R,FSPTR		;TO THE END?
	JRST DLOC2		;YES.  DO NEXT SOURCE DEVICE
	MOVE A,FSDEV(R)		;GET DEVICE
	CAME A,RSTDEV		;SAME AS THIS?
	JRST LOC9A		;NO.  LEAVE THIS TERM FOR NEXT TIME
	MOVE Y,FSEXT(R)		;GET FLAG WORD
	TRNE Y,ABFILE		;WAS THIS ONE FOUND and typed out?
	JRST LOC9Z		;YES
	SKIPE A,FSDEV(R)	;PRINT DATA.  GET THE DEVICE NAME
	CAMN A,['DSK   ']	;IS THE DEFAULT NAME?
	JRST PFIFP7		;YES. DONT PRINT
	PUSHJ P,SIXOUT		;TYPE SIXBIT DEVICE NAME
	MOVEI A,":"
	PUSHJ P,OUT.CH
	MOVEI A,11
	PUSHJ P,OUT.CH
PFIFP7:	MOVE A,FSNAM(R)
	TRNE Y,ALLFIL
	MOVSI A,'*  '
	HLLZ B,FSEXT(R)
	TRNE Y,ALLEXT
	MOVSI B,'*  '
	MOVE D,FSPPN(R)
	TRNE Y,ALLPRJ
	HRLI D,'  *'
	TRNE Y,ALLPRG
	HRRI D,'  *'
	PUSHJ P,TYFIL
	MOVEI B,[ASCIZ /	not available without previous-media errors.
/]
	SKIPE A,FSTAP(R)	;skip if no date/tape specified
	MOVEI B,[ASCIZ /	not available with specified tape or date.
/]
	TRNN Y,ALLFLG		;skip if this term matched something in database
	MOVEI B,[ASCIZ /	never dumped.
/]
	PUSHJ P,STROUT
	TRNE FL,LSTTTY
	CLOSE LST,		;IF LISTING ON TTY, FORCE IT NOW.
LOC9Z:	MOVSI A,FSLEN(R)	;SOURCE OF BLT
	HRRI A,(R)		;DESTINATION
	MOVNI B,FSLEN		;CALC ENDING ADDRESS
	ADDB B,FSPTR		;BY MOVING TOP OF TERMS DOWN
	BLT A,-1(B)		;MOVE ALL SOURCE TERMS
	JRST LOC9B		;LOOP BACK.  DON'T INCREMENT R.


PPNPOS:	MOVE A,1(A)		;GET THE PPN LOCATION FROM INDEX
	IDIVI A,200		;RECORD NUMBER IN A, WORDCOUNT IN B
	XCT @(P)		;EXECUTE APPROPRIATE USETI
	AOS (P)			;POINT TO NEXT ARGUMENT
IFE STANSW,<			;MAKE US DO AN INPUT NOW!
	MOVE K,@(P)		;K/ PUSHJ P,READROUTINE
	MOVE K,(K)		;K/ SOSG BUFFERCOUNT
	SETZM (K)		;USE UP THIS BUFFERLOAD
>;IFE STANSW
PPNPS1:	XCT @(P)		;EXECUTE READ TO SKIP INTO RECORD
	 JFCL			;(MAY SKIP)
	SOJGE B,PPNPS1		;LOOP. SKIP THE PPN WORD ITSELF!
	JRST CPOPJ1		;SKIP RETURN (PAST BOTH ARGS)

;Routine to skip if PPN in A matches any PPN in the term list, either
;exactly or with wildcards.  Device has to match too.
LCPPCK:
IFN STANSW,<
	MOVE K,RSTDEV		;GET DEVICE NAME
>;IFN STANSW
	SKIPA Q,TBASE		;TERM BASE
LCPPC1:	ADDI Q,FSLEN		;FOR ALL TERMS, CHECK IF ANY MATCH THIS PPN
	CAML Q,FSPTR
	POPJ P,			;LOSE - GO REJECT PPN
IFN STANSW,<
	CAME K,FSDEV(Q)
>;IFN STANSW
IFE STANSW,<
	MOVE K,FSDEV(Q)
	CAME K,RSTDEV
	TRNN K,-1
	JRST .+2
>;IFE STANSW
	JRST LCPPC1		;THIS TERM DOESN'T MATCH
	CAMN A,FSPPN(Q)
	JRST CPOPJ1		;OUTRIGHT MATCH.
	MOVE B,FSEXT(Q)
	TRNN B,ALLPRG!ALLPRJ
	JRST LCPPC1		;THIS TERM LOSES
	TRNE B,ALLPRG
	JRST LCPPC2		;* FOR PROGRAMMER
	HRRZ C,FSPPN(Q)
	CAIE C,(A)
	JRST LCPPC1		;LOSER.
LCPPC2:	TRNE B,ALLPRJ
	JRST CPOPJ1		;PPN MATCHES
	HLLZ C,FSPPN(Q)
	HLLZ D,A
	CAME C,D
	JRST LCPPC1		;LOSER
	JRST CPOPJ1

;Routine to skip if any PPN in the term list (including wildcards)
;might go between PPNs in X (inclusive) and Y (exclusive).
;Device has to match too.
IFN STANSW,<
IDXPCK:	MOVE K,RSTDEV		;GET DEVICE NAME
	MOVE A,Y		;starting PPN
	PUSHJ P,UFDCNV		;swap PPN halves and left justify each
	MOVEM A,IDXBEG		;store first PPN
	MOVE A,Z		;ending PPN
	PUSHJ P,UFDCNV		;swap PPN halves and left justify each
	MOVEM A,IDXEND		;store last PPN
	SKIPA Q,TBASE		;TERM BASE
IDXPC1:	ADDI Q,FSLEN		;FOR ALL TERMS, CHECK IF ANY MATCH THIS PPN
	CAML Q,FSPTR
	POPJ P,			;LOSE - GO REJECT index block
	CAME K,FSDEV(Q)
	JRST IDXPC1		;THIS TERM DOESN'T MATCH
	MOVE B,FSEXT(Q)		;get wildcard bits for PPN
	TRNE B,ALLPRG		;any programmer?
	JRST CPOPJ1		;yes, need all index blocks
	MOVE A,FSPPN(Q)		;get PPN for term
	PUSHJ P,UFDCNV		;swap PPN halves and left justify each
	TRNE B,ALLPRJ		;any project?
	HRR A,IDXBEG		;yes, use project of starting PPN (help match)
	MOVEM A,DNX		;store term PPN for comparison
	MOVE A,IDXBEG
	MOVEM A,TNX		;compare against starting PPN
	PUSHJ P,PPNCMP		;compare DNX,TNX (2,3,SYS are special)
	 JRST IDXPC1		;DNX<TNX, so term may need block (>matching)
	TRNE B,ALLPRJ		;any project?
	HLLZS DNX		;yes, use zero project for term, help match
	MOVE A,IDXEND
	MOVEM A,TNX		;compare against ending PPN
	PUSHJ P,PPNCMP		;compare DNX,TNX (2,3,SYS are special)
	 JRST CPOPJ1		;PPN may appear in index block, must read it
	JRST IDXPC1		;DNXTNX, so term doesn't need block (>matching)
>;IFN STANSW

;LOCATE READER "MERGES" DART.DAT AND DART.ARC. 

;CHANNEL FILE		MODE	BUFFER	GET(PUT) ROUTINE

;UFD		DART.DAT 	BUFFRD UFDBUF	UFDRD (SKIPS UNLESS EOF)
;FILE		DART.ARC BUFFRD	FIBUF	DFREAD

;Read all index blocks for DART.DAT and DART.ARC into core, setting up AOBJN
;pointers to the incore versions in DATIDX and ARCIDX.
LOCRD1:				;OPEN 2 DISK CHANNELS
IFN STANSW,<
	PUSH P,X		;Pumpkin seems to want these preserved
	PUSH P,Z
	MOVEI A,17		;read INDEX.DAT and INDEX.ARC first
	MOVE B,RSTDEV
	MOVEI C,0
	OPEN UFD,A		;device for INDEX.DAT and INDEX.ARC
	 PUSHJ P,NODEV
	MOVSI B,'DAT'		;file extension
	PUSHJ P,SCDIDX		;read second level index file
	 IDDAOB,,IDDDAT		;args: places to store aobjn ptr and date word
	MOVSI B,'ARC'		;file extension
	PUSHJ P,SCDIDX		;read second level index file
	 IDAAOB,,IDADAT		;args: places to store aobjn ptr and date word
	RELEAS UFD,		;for completeness
>;IFN STANSW
	MOVEI A,10
	MOVE B,RSTDEV
	MOVEI C,UFDBUF
	OPEN UFD,A		;DART.DAT INPUT
	 PUSHJ P,NODEV
IFN STANSW,<
	INBUF UFD,NBUFS		;SOME BUFFERS
>;IFN STANSW
IFE STANSW,<
	INBUF UFD,1
;; SUPER WINNING DEC SYSTEM DOESN'T FLUSH OUT THE BUFFERS WHEN YOU
;; USETI, SO WITH LOTS OF BUFFERS WE GET CONFUSED WHERE WE'RE UP TO.
;; I COULD HAVE WRITTEN A PIECE OF CODE USING INPUT UUOS WITH NONZERO
;; EFFECTIVE ADDRESSES AND GROVELING AROUND WITH USE BITS AND SO ON
;; BUT I'M A LAZY BUM AND THIS MAKES IT WORK.
>;IFE STANSW

	MOVEI C,FIBUF
	OPEN FILE,A		;DART.ARC INPUT
	PUSHJ P,NODEV
IFN STANSW,<
	INBUF FILE,NBUFS	;SOME BUFFERS
>;IFN STANSW
IFE STANSW,<
	INBUF FILE,1
>;IFE STANSW

	MOVE A,['DART  ']
	MOVSI B,'DAT'
	MOVEI C,0
	MOVE D,DUMPER
	LOOKUP UFD,A		;SEEK DART.DAT FILE
	 JRST ARCB0	
IFN STANSW,<
	PUSHJ P,FDATIM		;combine date and time into AC B
	CAMLE B,IDDDAT		;is DART.DAT newer than second level index?
	SETZM IDDAOB		;yes, clear pointer to second level index data
>;IFN STANSW
NEWARC:	MOVSI B,'ARC'
	MOVEI C,0
	MOVE D,DUMPER
	LOOKUP FILE,A		;SEEK DART.ARC
IFE STANSW,<
	 JRST CREARC		;WE LOSE SOMEHOW.
>;IFE STANSW
IFN STANSW,<
	 JRST ARCB1		;Too risky to just create empty DART.ARC - EJG
	PUSHJ P,FDATIM		;combine date and time into AC B
	CAMLE B,IDADAT		;is DART.ARC newer than second level index?
	SETZM IDAAOB		;yes, clear pointer to second level index data
>;IFN STANSW
LCR0.0:	MOVE W,.JBFF		;INITIAL POINTER FOR STORING INDEX
IFN STANSW,<
	MOVE X,IDDAOB		;get ptr to second level index
>;IFN STANSW
LCR0.1:	PUSHJ P,INDGET		;GET INDEX block from DAT FILE
	 PUSHJ P,UFDRD		;PARAMETER TO INDGET
	 JRST LCR0.2		;ALL DONE.
	USETI UFD,1(A)		;OTHERWISE NEED TO READ MORE
IFE STANSW,<
	SETZM UFDBUF+2		;FORCE AN INPUT UUO
>;IFE STANSW
	JRST LCR0.1		;

LCR0.2:	MOVEM W,DATIDX		;SAVE INDEX TO DAT FILE.
	MOVE W,.JBFF
IFN STANSW,<
	MOVE X,IDAAOB		;get ptr to second level index
>;IFN STANSW
LCR0.3:	PUSHJ P,INDGET		;GET INDEX block FROM ARC FILE
	 PUSHJ P,DFREAD		;PARAMETER TO INDGET
	 JRST LCR0.4		;ALL DONE.
	USETI FILE,1(A)		;OTHERWISE NEED TO READ MORE
IFE STANSW,<
	SETZM FIBUF+2
>;IFE STANSW
	JRST LCR0.3

LCR0.4:	MOVEM W,ARCIDX		;INDEX POINTER TO ARC FILE.
IFN STANSW,<
	POP P,Z
	POP P,X
>;IFN STANSW
	POPJ P,			;DONE WITH FIRST PART

INDGET:	HLRE C,W		;-WC (SO FAR) INTO C
	MOVN C,C
	ADDI C,(W)		;CALC NEXT ADDRESS TO STORE
IFN STANSW,<
;See if we need this index block.  Ptr to it's second level entry is in X.
	JUMPGE X,INDGT0		;jump if no second level data
	MOVE Y,(X)		;get first PPN in index block
	MOVE Z,2(X)		;get first PPN in next index block (or zero)
	ADD X,[2,,2]		;advance to next index block ptr
	PUSHJ P,IDXPCK		;skip if some term needs this index block
	 JRST [	MOVE A,1(X)	;get ptr to next index block
		JRST INDGT3]	;don't need this index block, ready for next
INDGT0:
>;IFN STANSW
	MOVEI B,176(C)		;CALC MAX ADDRESS FOR THIS CALL
	CAMGE B,.JBREL		;SKIP IF THERE'S NO ROOM
	JRST .+3
	CORE B,			;MAKE ROOM
	 JRST NOCORE
	MOVEI B,77		;COUNT OF PAIRS TO READ
INDGT1:	XCT @(P)		;READ A WORD
	 JFCL			;maybe EOF (depends on routine)
	JUMPE A,INDGTX		;END OF ALL INDEX DATA
	MOVEM A,(C)		;STORE PPN
	XCT @(P)
	 JFCL			;maybe EOF (depends on routine)
	MOVEM A,1(C)		;store PPN's pointer
	ADDI C,2
	ADD W,[-2,,0]		;COUNT IN AOBJN POINTER TO INDEX DATA
	SOJG B,INDGT1		;LOOP THRU INDEX WORDS
	XCT @(P)		;read word, which is pointer to next index block
	 JFCL
INDGT3:	JUMPE A,INDGTX		;LAST INDEX BLOCK WAS FULL, BUT NO NEXT BLOCK
	LSH A,-7		;CONVERT TO BLOCK NUMBER
	JRST CPOPJ2

INDGTX:	MOVEM C,.JBFF
	JRST CPOPJ1		;RETURN. W HAS AOBJN PNTR.

IFE STANSW,<
CREARC:	TRNE B,-1		;NO DART.ARC:
	JRST ARCB1		;JUMP IF NOT FNF ERROR
	MOVE D,DUMPER		;DRD
	ENTER FILE,A		;MAKE AN EMPTY DART.ARC
	 JRST ARCB1		;OOPS
	CLOSE FILE,
	JRST NEWARC		;NOW LOOK IT UP
>;IFE STANSW

;Locate and Pumpkin come here to finish output.
LOCFIN:	TLZN FL,L.PUMP		;PUMPKIN COMMAND?
	JRST LSTFIN		;NO
	MOVE A,PBASE		;YES, FINISH UP OUR BLOCK
	HRRZM A,PIOWD
	SOS PIOWD		;IOWD IS ADDR-1
	MOVEI X,(X)		;FLUSH LH COUNT
	SUBI X,(A)		;THIS IS THE NUMBER OF WORDS IN USE
	CAIG X,PFSLEN+1		;WERE ANY FILES FOUND?
	JRST NULPUM		;NO, NOTHING TO DO
	MOVEM X,(A)		;SAVE AS FIRST WORD TO OUTPUT
	MOVNS X			;NEGATIVE WC
	HRLM X,PIOWD		;SAVE FOR OUTPUT COMMAND
	MOVEI X,1(A)		;NOW COPY THE DEST STUFF
	HRLI X,(Z)		;BLT POINTER
	BLT X,PFSLEN(A)		;DO IT
	SKIPN X,FSPPN+1(A)	;TELL THE PUMPKIN OUR ALIAS
	MOVE X,ALIAS		; IF NO EXPLICIT DEST PPN
	MOVEM X,FSPPN+1(A)
	DATE X,			;GET DATE OF REQUEST
	MOVSI X,(X)		; IN LH
	HRR X,UPPN		;SINCE THE DEST DEVICE MUST BE DISK,
	MOVEM X,FSDEV+1(A)	; LET'S USE THAT WORD FOR THE REQUESTOR AND DATE
	MOVEI X,30		;RETRY COUNT FOR FILE BUSY
LOCFRT:	MOVE A,['PUMPKI']
	MOVSI B,'QUE'
	MOVEI C,0
	MOVE D,DUMPER
	LOOKUP DSKMSC,A
	 TRNN B,-1		;LOOKUP FAILED.  WHY?
	SKIPA D,DUMPER
	 JRST PMPLUZ		;LOOKUP FAILURE OTHER THAN FILE NOT FOUND
	ENTER DSKMSC,A
	 JRST PMPLUZ
	UGETF DSKMSC,A		;MOVE TO EOF
	OUTPUT DSKMSC,PIOWD	;DO OUR BOOGIE
REPEAT 0,<
	OUTSTR [ASCIZ/
I hope you're not in a hurry.  The Great Pumpkin doesn't visit the
patch very often these days, but have faith, the G.P. will show eventually.
/]
>;REPEAT 0
PUMXIT:	RELEAS DSKMSC,		;THAT WAS EASY
	JRST LSTFIN

PMPLUZ:	MOVEI B,(B)		;GET ERROR CODE ALONE
	CAIN B,3		;FILE BUSY?
	SOJG X,[ MOVEI A,1
		 SLEEP A,
		 JRST LOCFRT ]
	OUTSTR [ASCIZ /? Can't access PUMPKI.QUE, please report via GRIPE.
/]
	JRST RESTAR

NULPUM:	OUTSTR [ASCIZ /No files in request.
/]
	JRST PUMXIT

ACCCHK:	MOVE K,LOCLUK+2		;GET PROTECTION
	SKIPN OWNER		;IF USER HAS GROUP ACCESS PRIVS TO THIS UFD,
	CAMN D,UPPN		; OR IF FILE PPN IS USER'S PPN,
	JRST OWNACC		; USE OWNER ACCESS
	LSH K,3			;ELSE USE LOCAL ACCESS (*** SHOULD CHECK LUP? ***)
OWNACC:	TLNN K,100000		;THE WRITE BIT SHOULD ALWAYS BE HERE NOW
	AOS (P)			;ACCESS OK
	POPJ P,

GRPCHK:	SETZM OWNER		;THIS WILL FLAG OWNER ACCESS
IFN STANSW,<
	MOVE K,PRIVS		;GET PASSIVE PRIVILEGES
	TDNE K,[AAOPRV]		;DO WE HAVE ACCESS-ALIAS-AS-OWNER?
	CAME D,ALIAS		;AND IS THIS OUR ALIAS?
	 JRST .+2		;NO AAO OR WRONG PPN
	JRST GRPWIN		;WIN, SET OWNER ACCESS
	MTAPE DSKMSC,PRVMTA	;READ RETRIEVAL
	 POPJ P,		;CAN'T, NO GROUP ACCESS
	SETZM PASWD		;JUST IN CASE WE HAVE INF
	MOVE K,GRPWD		;GET FILE ACCESS GROUPS FOR THIS UFD
	AND K,[GROUPS]		;JUST THE RIGHT BITS PLEASE
	MOVEI C,(D)		;PRG OF TARGET UFD
	CAME C,UPRG		;PRG OF OUR USER
	TDZ K,[MASPRV]		;NOT THE SAME, NO MAS ACCESS
	TDNE K,PRIVS		;DOES USER HAVE ANY CORRESPONDING PRIVS?
GRPWIN:	SETOM OWNER		;YES! ALLOW OWNER ACCESS
>;IFN STANSW
	POPJ P,

IFN STANSW,<
;Read second level index file.  B has extension in LH.
SCDIDX:	MOVE A,['INDEX ']
	MOVEI C,0
	MOVE D,DUMPER
	MOVE X,@(P)		;get args
	SETZM (X)		;assume no file, clear date word
	LOOKUP UFD,A		;SEEK INDEX.DAT FILE
	 JRST CPOPJ1		;forget it
	PUSHJ P,FDATIM		;combine date and time into AC B
	MOVEM B,(X)		;save date & time written for file
	MOVS A,D		;negative file size
	MOVE Y,.JBFF		;INITIAL POINTER FOR STORING second level INDEX
	SUBM Y,A		;ending address
	MOVEM A,.JBFF		;update free pointer
	CAMGE A,.JBREL		;SKIP IF THERE'S NO ROOM
	JRST .+3
	CORE A,			;MAKE ROOM
	 JRST NOCORE
	HLL Y,D			;negative file size in LH
	MOVS X,X
	MOVEM Y,(X)		;store aobjn ptr to second level index
	SUBI Y,1		;make IOWD
	MOVEI Z,0		;end of cmd list
	IN UFD,Y		;read entire second level index file
	 JRST CPOPJ1		;OK
	JRST DSKRER		;disk read error

;Enter here after a LOOKUP in ACs A,B,C,D.  Combine date and time written
;from ACs B and C into one word value in B, with date in higher part.
FDATIM:	DPB C,[POINT 12,B,32]	;store low date bits next to high date bits
	ANDI B,777770		;clear extra bits, leaving only date
	LSH B,17		;shift date into LH
	LSH C,-14		;shift time bits to low part of AC
	DPB C,[POINT 11,B,35]	;store time in RH
	POPJ P,
>;IFN STANSW
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           subttl	tape-to-tape copy	; WCWD DVWD CKWD UCOPY MCOPY MCOP00 MCOP01 PTLUP MCOP02 UCOP0 MCOP0 MCOP0C MCOP0D

;Here to copy all or part of a Dart tape to another tape, possibly
;changing density or drive type.
;UCOPY MTU1:_MTU0:*.*[*,*] is the default if no arg to TCOPY cmd.
;MCOPY MTU1:_MTU0:*.*[*,*] is the default if no arg to MCOPY cmd.

WCWD__1		;space allowance for word-count word on tape
DVWD__1		;space allowance for device name word on tape
CKWD__1		;space allowance for checksum word on tape

;DENSITY dddd  is the command to set the output density (in DEVMOD).
;IDENSITY dddd is the command to set the input density (in INPMOD).

;RSTDEV holds the output device, MTDEV the input device.

UCOPY:	TDZA A,A		;zero to indicate user-class copy
MCOPY:	MOVNI A,1		;nonzero to indicate master tape copy
	MOVEM A,MASCOP		;set copy class
	MOVEM A,TELEOF		;report EOFs iff master tape copy
	MOVEM A,LRETRY		;limit read retries iff master tape copy
	DATE A,			;get today's date
	MOVEM A,TODAYD		;remember for date written check in TCOPDT
	SETZM PRDATE		;no validated date yet (master tape copy)
	SETZM SPPN		;no saved PPN yet (for master tape copy)
	SETZM TABORT		;no tape abort requested yet
	SETZM TSKIP		;no tape skip fwd requested yet
	SETZM TSKIPN		;reset tape skip fwd count
	SETOM SLILVL		;set desired initial slice level (1) (see MCIMNT)
	SETZM PICKON		;assume not doing a pickup
	SETOM PCPFIL		;initialize pointer into buffer of recent filenames
	SETZM MASDAF		;not reading date yet
	SETZM MEMSAV+TBRAND	;no brand text info for input tape yet
	TRO FL,PCLASS		;if this is system class, we're handling P tapes
	SKIPN MASCOP		;master copy?
	TDZA A,A		;no, class 0 is user class
	MOVEI A,2		;class 2 is permanent system class
	MOVEM A,CLASS		;set up dump class
	SKIPN MASCOP		;skip if master tape copy
	JRST UCOP0
	PUSHJ P,MCLINI		;initialize log file output
MCOP00:	OUTSTR [ASCIZ/Please type your name or initials: /]
	PUSHJ P,GETGO		;get the response
	 JRST MCOP01		;unknown response, assume name or initials
	 JRST MCOP00		;said GO, which isn't what we wanted
	JRST MCOP00		;null response, ask again

MCOP01:	PTYGET A		;get a pty for MTAFIX command
	 JRST UCOP0		;hmm, failed to get PTY, for some reason, oh well.
	MOVE B,[POINT 7,[ASCIZ/MTAFIX
/]]
	PTWRS7 A		;write the command (with CR and LF, maybe 2 cmds)
	MOVEI B,1
	SLEEP B,		;give it a chance to finish
PTLUP:	PTRD1S A		;read a char from pty into B
	 JRST MCOP02		;none, all done
	JRST PTLUP		;look for more

MCOP02:	PTYREL A		;release the pty
UCOP0:	SETOM MBUFLG		;make MTINIR/W use two sets of buffers optimally
	MOVEI A,10
	MOVSI B,'DSK'
	MOVEI C,UFDBUF
	OPEN UFD,A		;DART.DAT input for merge phase
	 PUSHJ P,NODEV
	INBUF UFD,NBUFS		;SOME BUFFERS
	MOVSI C,FOBUF
	OPEN FILE,A		;DART.DAT output
	 PUSHJ P,NODEV
;;	OUTBUF FILE,NBUFS	;SOME BUFFERS (;;set up within MERGE)
	MOVEI A,17
	MOVEI C,0
	OPEN MEM,A		;DTAPES.DAT input, dump mode, for merge and DTSORT
	 PUSHJ P,NODEV
	OPEN DSKMEM,A		;DART.MEM memory file
	 PUSHJ P,NODEV
	OPEN DSKMSC,A		;DTAPES.DAT output, RA mode
	 PUSHJ P,NODEV
	SKIPN MASCOP		;skip if master copy
	JRST MCOP0		;user copy, can't be locked out, no memory file
	PUSHJ P,CHKLOK		;check for lockout file
	 JRST MCLOUT		;LOCKOUT FILE EXISTS, LOSE
	PUSHJ P,PTCNTR		;read PTCNT.DAT, counts of files on each P tape
	PUSHJ P,RDMEM		;read DART.MEM memory file
	 JRST NOMCOP		;no such file!  maybe we're just starting
	 POPJ P,		;disk input error
;Come here if BEGINNING MCOPY (NOMCOP) or if doing user copy.
MCOP0:	MOVSI A,'DSK'		;set up some reasonable structure device
	MOVEM A,STRNAM
	SKIPE MASCOP		;switches not permitted with user copy
	HRRZM P,SWITOK		;switches OK, except rel dump number switch
	PUSHJ P,SCAN		;scan the command line
	MOVEI K,REGRST		;regular restore data area
	PUSHJ P,RSTDFT		;setup default dests
	PUSHJ P,TCOPTM		;process all terms given
	SKIPE MASCOP		;no status with user copy
	PUSHJ P,TELMCP		;report MCOPY status
	SKIPE GLOTAP		;skip unless tape number given (to back up copy)
	JRST MCOBAK		;backing up the tape copy -- check it out, confirm

	SKIPE A,RSTDEV		;get the output device name
	JRST MCOP0C
;	SKIPE MASCOP
;	SKIPA A,['MTU1  ']	;default OUTPUT for master copy is drive D
;	SKIPA A,['MTU1  ']	;temp default OUTPUT for master copy
	MOVE A,['MTU1  ']	;default output device for user copy
MCOP0C:	MOVEM A,RSTDEV		;save as restore device. (output)
	PNAME A,		;see which physical device being used for output
	 JRST NOMTA

	SKIPE B,MTDEV		;get input device
	JRST MCOP0D
;	SKIPE MASCOP
;	SKIPA B,['MTA1  ']	;default INPUT for master copy is drive B
;	MOVE B,['MTA0  ']	;default input device for user copy
	MOVE B,['MTU0  ']	;default input device for (master) copy
MCOP0D:	MOVEM B,MTDEV		;save nonzero logical name
	PNAME B,		;get physical name of input device
	 JRST NOMTA
	CAMN A,B		;make sure input and output devices are different
	JRST MTSAME		;error -- input and output mag drives are same

	SKIPE MASCOP		;master copy?
	JRST MCOPGO		;yes, skip user mode options below
;User mode tape copy
;Open output tape on MTA2
	PUSH P,MTDEV		;save input magtape device
	MOVE A,RSTDEV		;get output magtape device
	MOVEM A,MTDEV		;set to use it
	PUSHJ P,MTINIW		;open output tape on MTA2
	POP P,MTDEV		;restore input device
;Open input tape on MTA (done second so footage display will be for input tape).
	PUSH P,DENMOD		;save output density
	SKIPE A,INPMOD		;get requested input density, skip if none
	MOVEM A,DENMOD		;set it for INIT
	PUSHJ P,MTINIR		;init the magtape device, just reading
	POP P,DENMOD		;restore output density
	OUTSTR [ASCIZ/Want OUTPUT tape rewound before starting? /]
	PUSHJ P,YORN
	 CAIA			;no
	PUSHJ P,MT2REW		;Yes, rewind output tape
	STATZ MTA2,IOBOT	;don't write tape header unless output tape at BOT
	 PUSHJ P,TAPHED		;write a tape header (ends with MT2CLZ)
	TLO FL,MCLOSE		;no magtape file open
	OUTSTR [ASCIZ/Want INPUT tape rewound before starting? /]
	PUSHJ P,YORN
	 CAIA			;no
	PUSHJ P,MTAREW		;Yes, rewind input tape
	PUSHJ P,MTANOP		;do a no-op to detect front of input tape
	JRST TCPIK0		;go begin the copy

                                                                                                                                                                                                      ;tape copy -- report MCOPY status ; TELMCP TELMCA TELMCB BADPIK MCOBAK MCONFW

;Report MCOPY status.
TELMCP:	MOVE A,MEMSAV+CHKNUM	;range check the pickup code
	CAIL A,MCPIKS		;better be less than this
	JRST BADPIK		;pickup code out of range!
	OUTSTR [ASCIZ/MCOPY checkpoint: /]
	PUSHJ P,TYPOCT		;type octal pickup code
	MOVE A,MEMSAV+CHKNUM	;the pickup code
	MOVE X,MCPIK(A)		;get pickup flags
	OUTSTR [ASCIZ/
	/]
	OUTSTR @MCPIKT(A)	;report type of pickup we're doing
	OUTSTR [ASCIZ/
  Input tape: P/]
	MOVE A,MEMSAV+MCITAP	;input tape number
	PUSHJ P,DECOUT
	OUTSTR [ASCIZ/, /]
	MOVE A,MEMSAV+MTAFI2	;number of MT files before input reposition point
	PUSHJ P,DECOUT
	OUTCHR ["/"]
	MOVE A,MEMSAV+MTAFIL	;number of MT files before current tape position
	PUSHJ P,DECOUT
	OUTSTR [ASCIZ/ MT files, /]
	MOVE A,MEMSAV+MTOPOS	;input tape footage at that point
	PUSHJ P,TYFOOT		;type footage from internal units
	TLNE X,NOITAP		;skip unless no input tape filename to bother with
	JRST TELMCA		;no input filename
	OUTSTR [ASCIZ/ -- /]
	MOVE A,MEMSAV+CFILE	;input file name
	MOVE B,MEMSAV+CEXT	;input filename extension
	MOVE D,MEMSAV+CUSER	;input filename PPN
	PUSHJ P,TYFIL
TELMCA:	OUTSTR [ASCIZ/
  Output tape: P/]
	MOVE A,MEMSAV+MCOTAP	;output tape number
	PUSHJ P,DECOUT
	OUTSTR [ASCIZ/, /]
	MOVE A,MEMSAV+MT2FIL	;number of MT files finished on output tape
	PUSHJ P,DECOUT
	OUTSTR [ASCIZ/ MT files, /]
	MOVE A,MEMSAV+MTFPOS	;output tape footage at that point
	PUSHJ P,TYFOOT		;type footage from internal units
	TLNE X,NOOTAP		;skip unless no output tape filename to bother with
	JRST TELMCB		;no output filename
	OUTSTR [ASCIZ/ -- /]
	MOVE A,MEMSAV+FFILE	;output file name
	MOVE B,MEMSAV+FFEXT	;output filename extension
	MOVE D,MEMSAV+FUSER	;output filename PPN
	PUSHJ P,TYFIL
TELMCB:	OUTSTR [ASCIZ/
/]
	SETOM PICKON		;we're doing a pickup
	POPJ P,

BADPIK:	OUTSTR [ASCIZ/Checkpoint number (pickup code) out of range for Master Copy!
Can't continue -- find a wizard./]
	EXIT 1,
	JRST BADPIK

;Here if user specified a particular input tape, e.g, MCOPY/P1234<return>.
;Wants to backup the tape copy to re-read the given tape.
MCOBAK:	MOVE A,MEMSAV+MCITAP	;expected input tape number
	HLRZ B,GLOTAP		;requested input tape
	CAMGE A,B		;better not be saying go forward
	JRST MCONFW		;can't jump forward beyond expected tape
;	CAIE A,1(B)		;backing up by one tape?
;	JRST MCOBA2		;no, find a wizard, refuse to do this automatically
	OUTSTR [ASCIZ/
Back up of MCOPY requested, but not implemented in DART.
Use following technique.

***  To backup and re-read, say, P100 (sic):

Observe the latest output tape MT file count, as shown above.  Remember it.

Now use either:
   DO(previousInputTape) to backup to a tape whose data has already been merged,
or
   DO(restartInputTape) to backup to the beginning of the current tape (not yet merged).

In either case, next do an MCOPY command and observe the backed-up output tape
MT file count.  Subtract that count from the remembered one from above.  If
the difference <n> is more than 1, call out of MCOPY and say "BACK MTU0: <n>".
If the output tape number has changed between the two .MEM files, you'll have
to remount the prior output tape -- just let it sit rewound at this point.

Now, MCOPY should immediately ask you for a new input tape.
If it doesn't, find a wizard.

/]
	HALT .

MCONFW:	OUTSTR [ASCIZ/Skipping forward to given tape is not allowed.
Tapes must be done in sequence.
/]
	JRST RESTAR

comment 

DO(previousTape) does this:

   RENAME P00100.MSV_DART.MEM	;save latest memory file, just in case
   RENAME P00100.DS1_DART.DAT	;save latest locate info, just in case
   COPY DART.MEM_P00099.MEM	;restore memory file to state after P99 finished
   COPY DART.DAT_P00099.DAT	;restore locate file to information through P99
   RENAME P00099.DS2_P00099.DAT	;move old locate file, so MCOPY's later rename works
   RENAME P00099.TSV_P00099.DTP	;move old DTAPES file, so MCOPY's later rename works

DO(restartTape) does this:

   RENAME P00100.MSV_DART.MEM	;save latest memory file, just in case
   COPY DART.MEM_P00099.MEM	;restore memory file to state after P99 finished
   DIRECTORY P00099.DAT		;should NOT exist -- DART.DAT goes through P99

end of comment 
                                                                                                                                                        ;tape copy -- just starting MCOPY ; NOMCOP TCPIKS MCONLY

;Here if no memory file for MCOPY.
NOMCOP:	TRNE B,-1		;check error code from lookup
	JRST NOLOOK		;tell what happened
	OUTSTR [ASCIZ/No memory file exists -- initializing MCOPY.
/]
	MOVEI A,1		;first input tape
	MOVEM A,MEMSAV+MCITAP	;initialize input tape number
	MOVEI A,=3000		;first output tape
	MOVEM A,MEMSAV+MCOTAP	;initialize output tape number
	MOVE A,[1,,1]		;init relative and absolute dump numbers
	MOVEM A,MEMSAV+RELABS	;init dump numbers at beginning of master copy
	MOVEI A,MCPIKS
	MOVEM A,MEMSAV+CHKNUM	;this pickup code means starting master copy
	HRRZ A,CLASS		;class will be system permanent
	HRL A,FL		;get the flags
	MOVEM A,MEMSAV+DCLASS	;save flags and class
	OUTSTR [ASCIZ/%%% ARE YOU SURE you're just beginning the Master Tape Copy? /]
	HALT .			;it will only be begun once -- make it hard
	JRST MCOP0

;Dispatch to here when starting entire master tape copy.
TCPIKS:	MOVEI A,'2  '		;most "negative" unswapped PPN, for PPNCMP to skip with
	MOVEM A,MEMSAV+ITEPPN	;prevent incrementing RELABS for first input tape
	PUSHJ P,MCNEWI		;request and set up new input tape
	SETZM MEMSAV+MCODFI	;no disk files copied yet
	SETZM MEMSAV+MCODFE	;no disk files copied with errors yet
	JRST TCFSTO		;go mount first output tape

;Here if user gave a PICKUP, TDUMP, PDUMP, FDUMP or PURGE command
;to the MCOPY.DMP core image, which is only for MCOPY.
MCONLY:	OUTSTR [ASCIZ/This program version of Dart shouldn't be used for that command.
This version is restricted to MCOPY use.
/]
	RESET
	EXIT
                                                                                                                                                                                                                                                                                                                                ;tape copy -- sort DTAPES.DAT by PPN ; DTSOR0 DTSORT DTNXT DTPPN DTPTR DTLEN DTSPPN DTSPP2 DTSCMP DTSINS DTSINL DDREAD DTSEO2

DRAT,<
;Here we make sure we have the channels open for DTSORT below.
DTSOR0:	MOVEI A,17
	MOVSI B,'DSK'
	MOVEI C,0
	OPEN MEM,A		;DTAPES.DAT input, dump mode, for merge and DTSORT
	 PUSHJ P,NODEV
	OPEN DSKMSC,A		;DTAPES.DAT output, RA mode
	 PUSHJ P,NODEV
	;fall into DTSORT
>;DRAT
;Here if DTAPES.DAT was generated with some PPNs out of order (probably because
;of tape errors clobbering some PPNs).  Have to sort PPNs in DTAPES so that
;the merge will merge it correctly with DART.DAT, maintaining order there.
;We read in and store all the PPNs (only), saving ptrs to their spots in the file,
;sort the PPNs, then write the new file by reading in each PPN's data separately.
;We'll use channel MEM to read DTAPES.DAT and channel DSKMSC to write a sorted
;DTAPES.DAT.
;;printx The insertion sort at DTSORT should be a reverse insertion, to be fastest.
DTSORT:	OUTSTR [ASCIZ/
PPNs out of order in DTAPES.DAT -- sorting...
/]
	MOVE A,['DTAPES']
	MOVSI B,'DAT'
	MOVE D,DUMPER
	LOOKUP MEM,A
	 JRST NOLOOK		;oops, can't read file to sort it!
	MOVSM D,MEMWC		;SAVE -WC OF DTAPES.DAT FILE
	SETZM MEMWC2		;FORCE INPUT TO HAPPEN -- uses MEMBLK
	SETOM ARCWC		;first word read from file will be word zero
;We use some free core to store all the PPNs in a sorted list.
;Blocks look like this:
DTNXT__0	;0/next block
DTPPN__1	;1/PPN -- with halves swapped and left justified (for PPNCMP)
DTPTR__2	;2/word within file where PPN's data starts (loc of PPN itself)
DTLEN__3	;number of words in block
;X contains ptr to next free block of core.
;Y contains ptr to first block in list.
	MOVE X,.JBFF		;get ptr to some free core
	MOVEI Y,0		;initial header ptr is null
DTSPPN:	PUSHJ P,DDREAD		;read a PPN from file
	 JRST DTSEOF		;EOF
	JUMPE A,DTSEO2		;zero means end-of-file, actually
	MOVEI D,DTLEN(X)	;make sure we have enough core for a new block
	CAMG D,.JBREL
	JRST DTSPP2		;got enough core
	CORE D,			;get more core
	 JRST NOCORE
DTSPP2:	PUSHJ P,LJUSTH		;left justify each half of PPN
	MOVSM A,DNX		;save PPN that we're about to insert
	MOVSM A,DTPPN(X)	;save in new block
	MOVE A,ARCWC		;get word address in file of PPN's location
	MOVEM A,DTPTR(X)	;save file addr in PPN's block
;Now we do an insertion sort of new PPN in the list.  Hdr in Y, end is null ptr.
;B points to current element, D to previous.  C is temporary for LJUSTH.
;A is also temporary.
	MOVEI D,0		;no previous element
	SKIPN B,Y		;start with header
	JRST DTSINS		;null list, insert at end
DTSCMP:	MOVE A,DTPPN(B)		;get PPN
	MOVEM A,TNX		;store for comparison
	PUSHJ P,PPNCMP		;Skip if DNX is greater than or equal to TNX.
	 JRST DTSINS		;this is the place to insert the new PPN
	MOVE D,B		;remember current element as previous
	SKIPE B,DTNXT(B)	;get next element
	JRST DTSCMP		;go on down the list
;Here to insert element X in list between D (prev) and B (current).
DTSINS:	SKIPN D			;skip unless no previous element
	SKIPA Y,X		;this element is new first element
	MOVEM X,DTNXT(D)	;make D point to X
	MOVEM B,DTNXT(X)	;make X point to B
	ADDI X,DTLEN		;advance free core ptr past this new block
;Now we skip over this PPN's file data from DTAPES.DAT
DTSINL:	PUSHJ P,DDREAD		;get a filename
	 JSP B,DTUEOF		;unexpected EOF!
	JUMPE A,DTSPPN		;zero means new PPN is coming
	PUSHJ P,DDREAD		;read extension word
	 JSP B,DTUEOF		;unexpected EOF
	PUSHJ P,DDREAD		;read data word
	 JSP B,DTUEOF		;unexpected EOF
	JRST DTSINL		;loop reading filenames till see a zero

;Read a word from the file and count it.  Used by DTSORT.
DDREAD:	PUSHJ P,TNREAD		;read a word, skip unless EOF
	 POPJ P,		;pass EOF return up
	AOS ARCWC		;count words in DTAPES.DAT
	JRST CPOPJ1		;skip with word read

;Here when have seen a zero PPN, which should be marking the end of the file.
;Just to be safe, we'll read until real EOF to make sure it's all zero.
DTSEO2:	PUSHJ P,DDREAD		;read a word from file
	 JRST DTSEOF		;EOF
	JUMPE A,DTSEO2		;zero words are expected here
	OUTSTR [ASCIZ/
%%% Non-zero word found after last PPN data in DTAPES.DAT being sorted.
%%% Find a wizard.
/]
	HALT .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ;tape copy -- DTAPES.DAT sorted, now write it out ; DTSEOF DTWPPN DTWROK DTWLOO DTUEOF DTWERR DTPDU0 DTPDUN DTPDU2

;Here when have read in and sorted all PPNs from DTAPES.DAT.
;Now we write out a new version of DTAPES.DAT with the PPNs sorted.
;We go through the sorted list, and for each PPN, we read its data from
;the old file using random access to that PPN's portion of the file.
;ARCWC will continue to hold the number of the last word read from
;the old file, and therefore it will indicate which record of that
;file is in core (since most of the file is probably sorted, we won't
;have to do too many random disk reads).
;Y will be the pointer to the block of the current PPN.
DTSEOF:	CLOSE DSKMSC,		;make sure nothing open here
	MOVE A,['DTAPES']	;now we'll write out a new sorted version of this
	MOVSI B,'DAT'
	MOVEI C,0
	MOVE D,DUMPER
	ENTER DSKMSC,A		;create new version of file
	 JRST NOENT		;lost!
	SETOM DSKMM3		;set binary mode
	PUSHJ P,DMINIC		;clear buffer
	PUSHJ P,DMINIP		;init buffer pointer and count, uses REELBF
	MOVSI A,400000		;most negative number
	MOVEM A,MEMWC		;inhibit EOF detector at TNREAD
	JUMPE Y,DTPDU0		;jump if no PPNs at all!
;Here to write out data for a PPN
DTWPPN:	MOVE A,DTPTR(Y)		;word address of PPN in the file
	XOR A,ARCWC		;compare with current disk record in core
	TDNN A,[-1,,777600]	;same record number?
	JRST DTWROK		;yes
	MOVE A,DTPTR(Y)		;no, get desired word loc again
	LSH A,-7		;make it record location (zero based)
	USETI MEM,1(A)		;select right record to read
	LSH A,7			;make word address of first word of rec
	MOVEM A,ARCWC		;save address of word about to be read
	PUSHJ P,TNRDR1		;read a record from the disk, and a word from rec
	 HALT .			;always skips
DTWROK:	MOVE A,DTPTR(Y)		;desired word
	SUB A,ARCWC		;distance from current word
	SUBI A,1		;backup one so we can adjust and then do ILDB
	ADDM A,ARCWC		;advance/backup to word loc before desired
	ADDM A,MEMWC1		;adjust byte ptr too
	ADDM A,MEMWC2		;adjust byte count
	PUSHJ P,DDREAD		;go read a word from old DTAPES.DAT -- PPN
	 JSP B,DTUEOF		;unexpected EOF
	JUMPE A,DTWERR		;PPN shouldn't be zero!
	PUSHJ P,DMPUT		;output to new DTAPES.DAT
DTWLOO:	PUSHJ P,DDREAD		;go read a word from old DTAPES.DAT -- filename
	 JSP B,DTUEOF		;unexpected EOF
	PUSHJ P,DMPUT		;output to new DTAPES.DAT
	JUMPE A,DTPDUN		;zero means no more files for this PPN
	PUSHJ P,DDREAD		;go read a word from old DTAPES.DAT -- ext
	 JSP B,DTUEOF		;unexpected EOF
	PUSHJ P,DMPUT		;output to new DTAPES.DAT
	PUSHJ P,DDREAD		;go read a word from old DTAPES.DAT -- data
	 JSP B,DTUEOF		;unexpected EOF
	PUSHJ P,DMPUT		;output to new DTAPES.DAT
	JRST DTWLOO		;loop for next file

DTUEOF:	OUTSTR [ASCIZ/
%%% Unexpected end-of-file while reading DTAPES.DAT to sort it.  Find a wizard.
/]
	HALT .

DTWERR:	OUTSTR [ASCIZ/
%%% PPN word read from DTAPES.DAT during sorting is zero!  Find a wizard.
/]
	HALT .

DTPDU0:	OUTSTR [ASCIZ/
%% No PPNs in DTAPES.DAT being sorted.
/]
	PUSHJ P,WIZGO		;ask for wizard, but accept GO
	JRST DTPDU2

;Here when all of a PPN's data has been copied to new file.
DTPDUN:	MOVE Y,DTNXT(Y)		;get ptr to next PPN block
	JUMPN Y,DTWPPN		;jump unless end of PPN list
DTPDU2:	PUSHJ P,DMFINI		;write out last buffer, if necessary
	CLOSE DSKMSC,		;all done, new sorted DTAPES.DAT exists
	CLOSE MEM,		;let go of old unsorted file
	OUTSTR [ASCIZ/DTAPES.DAT sorting finished.
/]
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ;tape copy -- request input or output tape mounting ; MCOMNT MCIMNT TPHNAM MCREIN

;Request output tape mounted for master tape copy, init tape
MCOMNT:	OUTSTR [ASCIZ/On OUTPUT tape drive /]
	MOVE A,MEMSAV+MCOTAP	;get output tape number
	MOVEM A,TAPNO		;indicate tape to be mounted
	SETZM PRVPPN		;no output MT file open
	MOVE A,RSTDEV		;output device
	PUSHJ P,TPHNAM		;type physical device name and CRLF
	OUTSTR [ASCIZ/With a WRITE RING, /]
	PUSH P,MTDEV		;save input magtape device
	MOVE A,RSTDEV		;get output magtape device
	MOVEM A,MTDEV		;set to use it
	PUSH P,TAPNAM		;save input tape name
	PUSHJ P,DOMOUNT		;mount output tape (INIT). if not PICKON: then rewind and write header
	PUSHJ P,TYWHEN		;type date and time
	PUSHJ P,DUPINI		;clear list of recently seen tapes, new tape here
	MOVE A,TAPNAM		;save output tape name
	MOVEM A,OTPNAM
	POP P,TAPNAM		;restore input tape name
	POP P,MTDEV		;restore input device
	POPJ P,

;Request input tape mounted for master tape copy, init tape
MCIMNT:	PUSHJ P,TYWHEN		;type date and time
	PUSH P,TAPNO		;save output tape number
	OUTSTR [ASCIZ/On INPUT tape drive /]
	MOVE A,MEMSAV+MCITAP	;get input tape number
	MOVEM A,TAPNO		;indicate tape to be mounted
	MOVEM A,PREQTP		;ensure we get the right tape
	MOVE A,MTDEV		;input device
	PUSHJ P,TPHNAM		;type physical device name and CRLF
	PUSH P,DENMOD		;save output density
	SKIPE A,INPMOD		;get requested input density, skip if none
	MOVEM A,DENMOD		;set it for INIT
	SETCMM SLILVL		;pretend slice level was toggled
	SETOM TSLICE		;but request slice level to be toggled "back"
	PUSHJ P,DOMINP		;tell operator to mount input tape -- init device
	PUSHJ P,SLIINI		;initialize slice-toggle checking
	PUSHJ P,TYWHEN		;type date and time
	PUSHJ P,DUPINI		;clear list of recently seen tapes, new tape here
	POP P,DENMOD		;restore output density
	POP P,TAPNO		;restore output tape number
	POPJ P,

;Type physical name of device in A, then CRLF.
TPHNAM:	PNAME A,		;get physical name
	 JFCL			;none!?
	PUSHJ P,SIXOUT		;type device
	OUTSTR [ASCIZ/:
  /]
	POPJ P,

;Re-open input tape device.
MCREIN:	PUSH P,DENMOD		;save output density
	SKIPE A,INPMOD		;get requested input density, skip if none
	MOVEM A,DENMOD		;set it for INIT
	PUSHJ P,MTINIR		;re-open input tape
	POP P,DENMOD		;restore output density
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ;tape copy -- resume MCOPY, restore all positions ; MCOPGO MCOPG2 MCOPG3 MCOPG4

;Here when starting or resuming master copy.
;Maybe need input and output tapes mounted.
MCOPGO:	SKIPL A,MEMSAV+CHKNUM	;get pickup code (-1 if just starting copy)
	CAILE A,MCPIKS		;in range?
	JRST BADPIK		;pickup code out of range
	MOVE A,MCPIK(A)		;get dispatch word for this type of pickup
	PUSH P,A		;save dispatch for POPJ
	;Must fix output tape position first, since FIXPOS uses input channel.
	;However, we can ask for mounting of input tape first, so we do.
	TLNE A,NOITAP		;suppressing mounting input tape now?
	JRST MCOPG2		;yup, we'll mount it later
	PUSHJ P,MCIMNT		;mount input tape for master copy
	PUSHJ P,MTAREL		;release input tape for MFIXI/FIXP00 to re-init
	MOVE A,(P)		;get dispatch word again
MCOPG2:	TLNE A,NOOTAP		;suppress mounting output tape now?
	JRST MCOPG3		;yup, we'll mount it later
	PUSH P,MEMSAV+MT2FIL	;this might get zeroed by DOMOUNT/MT2NOP/MT2RE2
	PUSHJ P,MCOMNT		;mount output tape for master copy
	POP P,MEMSAV+MT2FIL	;restore number of files on output tape
	MOVE A,(P)		;get dispatch word again
	TLNN A,NOOFIX		;skip if suppressing repositioning of output tape
	PUSHJ P,MFIXO		;fix position of output tape (before input tape!)
	MOVE A,(P)		;get dispatch word again
MCOPG3:	TLNN A,NOIFIX!NOITAP	;skip if suppressing repositioning of input tape
	PUSHJ P,MFIXIB		;fix position of input tape
	MOVE A,MEMSAV+MCITAP	;get input tape number
	SKIPN THSTAP		;make sure this is nonzero, to avoid safety check
	MOVEM A,THSTAP		;  at MASPIK (will fix input tape or mount new one)
	MOVE A,(P)
	TLNE A,NODTAP		;suppressing positioning within DTAPES.DAT?
	JRST MCOPG4		;yup
	PUSHJ P,DTDRAM		;get DTAPES.DAT open in RA mode
	PUSHJ P,MFIXD		;reposition us within DTAPES.DAT
MCOPG4:	SETZM PICKON		;no longer doing pickup stuff (see DOMOUNT)
	POPJ P,			;dispatch to saved address
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ;tape copy -- new output tape and main file loop ; TCNXTO TCFSTO TCPIK0 TCOPFI TCOPF0 TCOPF2 MINREC TCOPF3 TCOPF4 TCOPF5 TCOPDP

;Here when need a new output tape for master copy.
TCNXTO:	AOS MEMSAV+MCOTAP	;advance to next output tape
	MOVSI A,1
	HLLM A,MEMSAV+RELABS	;init relative dump number for new output tape
	PUSHJ P,TYWHEN		;type date and time
TCFSTO:	PUSHJ P,MCOMNT		;mount output tape for master copy, rewind, write hdr
TCPIK0:	TLZ FL,UDPGO		;assume not udp
	SETZM PRVPPN		;no output MT file open
;Here we read next file from input tape.
TCOPFI:	PUSHJ P,SLICHK		;maybe toggle the slice level, if that might help
	PUSHJ P,RDFIL		;read retrieval from mtape
	 JRST TCPHTR		;header/trailer: copy and keep going
	AOS MTFBEG		;we've seen another file after input tape EOF
	TRNE FL,MTAEOT		;skip unless logical end of tape
	JRST TCLEOT		;need new input tape, I guess
	SKIPG A,MEMSAV+MTIDAT	;do we know valid date written of input tape?
	PUSHJ P,VALDAT		;no, validate date or get one from operator
	PUSHJ P,ADJDAT		;zero the file's date written if it's unreasonable
	MOVE A,INVERS		;get positive tape format number
	CAIL A,IOVER2		;does this format have disk offset in retrieval?
	JRST TCOPF0		;yes
	MOVEI A,1		;no, this is an early format, fix offset word
	EXCH A,FILINF+DDOFFS	;normalize the disk offset word to 1 (no offset)
	MOVEM A,FILINF+DDWPPN	;move writer's PPN to it's normal retr word
TCOPF0:	PUSHJ P,DPYSER		;display input file name plus output tape position
	 FILINF+DDNAM,,DPYFIL
	SKIPE MASCOP
	 JRST TCOPF2		;master copy: copy all files
	PUSHJ P,TCOPMT		;See if this file matches a term (double skips)
	 JRST TCOPFI		;no match, read next file
	 JRST TCLEOT		;no match and logical EOT, need new tape, I guess
;See if we need an EOF here.
TCOPF2:	MOVE A,MTFBEG		;see if input file at front of a magtape file
	MOVE C,MTFILN		;number of records in current output magtape file
  MINREC__32      ;minimum number of records before we close an MT file.
	CAIL C,MINREC		;write EOF if have written this many records
	CAIE A,1		;1 means first thing in MT file (AOS'd at MTAINP & TCOPFI)
	JRST TCOPF3		;not enough recs or not at beg of input MT file
	PUSHJ P,NEWMTF		;write EOF periodically, to make pickup possible
	 JRST TCPEOT		;physical EOT on output, need new output tape
TCOPF3:	MOVE A,FILINF+DDNAM	;set up the default filename
	MOVE B,FILINF+DDEXT
	MOVE D,FILINF+DDPPN
	SKIPN MASCOP		;if master copy, everything is wild
	PUSHJ P,TCOPUF		;set up output filename, using bits in X
	CAMN A,FAKEFI		;look like fake filename?
	PUSHJ P,NEWERR		;yes, turn *ERROR.NEW into *ERROR.ERR
	CAMN D,SPPN		;same ppn as last one?
	TDZA D,D		;yes, don't type PPN
	OUTSTR CRLF		;no, type CRLF for new PPN
	PUSHJ P,TYFIL		;type a file name
	PUSHJ P,TCOPND		;check for having encountered a new dump
	 JRST TCPEOT		;real or fake physical EOT, finish output tape
	PUSHJ P,TEMDMP		;report rel dump nbr from MEMSAV+RELABS
	PUSHJ P,DUPCHK		;check for duplicated filename (prob. from tape err)
	 JRST TCOPDP		;found duplicate name, you'll have to do a PICKUP
	SKIPN PRVPPN		;if this will be first file in output magtape file,
	PUSHJ P,STOIFN		; then store current input filename for pickup
	MOVE A,MEMSAV+MTAFIL	;have we seen more input files?
	CAMN A,MTAFMM		;skip if so -- need to write out MEM file
	JRST TCOPF4		;no, MEM file is up to date (save disk ops)
	MOVEI A,MCPIK0		;pickup type 0
	PUSHJ P,MASPIK		;write DART.MEM to remember state for pickup
TCOPF4:	SETOM PRVPPN		;indicate some output in MT file
	PUSHJ P,TCDUMP		;read the file and re-dump it as we go
	 JRST TCPEOT		;physical end of tape
	SKIPE MASCOP		;skip unless master tape copy
	JRST TCOPF5
	PUSHJ P,NEWMTF		;close and write an EOF for user copy
	 JRST TCPEOT		;EOT on output, need new output tape
TCOPF5:	PUSHJ P,TCOPDT		;update DTAPES.DAT for file just copied
;;	OUTSTR CRLF	;limit lines of output, to speed it up
	OUTSTR [ASCIZ /  /]
	MOVE W,TBASE		;get beginning of term list
	SKIPN MASCOP		;skip if master copy
	XCT R.EMPT(K)		;skip if no terms left in list
	 JRST TCOPFI		;go read another file
	JRST TCOPUE		;there are no more terms

TCOPDP:	OUTSTR [ASCIZ/
  The filename above was about to be listed in DTAPES.DAT for the second time,
  corrupting the database.  This is probably the result of tape re-reads.
  We'll omit this additional copy of the file from the database.
/]
;;;	HALT .+1		;don't forget that this is trapped by uuo simulator
	JRST TCOPFI
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ;tape copy -- misc. subroutines ; NEWERR CHKFAK VALDAT VALDA2 VALDA3 VALDA4 VALDA5

;Turn *ERROR.NEW from new read error into *ERROR.ERR on output tape of tape copy.
;Then when we read back the output tape, the tape won't appear to have read errors.
NEWERR:	CAMN B,FAKEFI+1		;fake (.NEW) extension?
	CAME D,FAKEFI+3		;fake file's PPN?
	POPJ P,			;no, leave filename alone
	MOVE C,SRCDEV		;get fake device
	CAME C,FAKEDV		;right fake?
	POPJ P,			;no!  I bet we never get here.
	MOVE B,ERREXT		;turn .NEW into .ERR
	MOVEM B,FILINF+DDEXT	;store as file to write
	POPJ P,

;Skip IF filename is fake file generated during tape copy.
CHKFAK:	MOVE D,FILINF+DDPPN	;get PPN
	MOVE A,FILINF+DDNAM	;get filename
	CAMN D,FAKEFI+3
	CAME A,FAKEFI
	POPJ P,			;direct return since not fake file
	MOVE D,SRCDEV		;device
	HLLZ A,FILINF+DDEXT
	CAMN D,FAKEDV		;fake device?
	CAME A,ERREXT		;skip if old error
	POPJ P,			;direct return since not fake file
	JRST CPOPJ1		;skip for fake filename

;Here when see first file on tape that has no valid date written in tape header.
;LH of A is negative if potential date (from tape hdr) is in RH A.  Else A is zero.
;Clobbers A,B,C.
VALDAT:	SKIPN MASCOP		;nothing to do if user tape copy
	POPJ P,
	JUMPL A,VALDA4		;jump if we have a potential date from tape
	OUTSTR [ASCIZ/
Input tape doesn't have valid date in tape header.
/]
VALDA2:	PUSHJ P,MASDAT		;read date from operator (check vs. today & prev)
VALDA3:	MOVEM B,PRDATE		;save validated date
	ADDI B,=31		;allow file date to be one month after tape date
	CAMLE B,TODAYD		;but not in actual future
	MOVE B,TODAYD		;use today as limit
	MOVEM B,MEMSAV+MTIDAT	;remember valid date limit for file written dates
	POPJ P,

;Here after reading tape header, with apparently valid tape-written date in A
;Ask operator to validate the date.
;But if date is within 15 days of previously validated date, just accept it.
VALDA4:	SKIPN B,PRDATE		;any previous date?
	JRST VALDA5		;no, must validate new one
	CAIG B,(A)		;date shouldn't go backwards
	CAIGE B,-=15(A)		;nor should it go forwards too much at a time
	JRST VALDA5		;unlikely date, ask operator
	MOVEI B,(A)		;looks ok, use date
	JRST VALDA3

VALDA5:	OUTSTR [ASCIZ/
If date on input tape's label is within 2 days of /]
	MOVEI A,(A)		;clear flag in LH
	PUSH P,A		;save date
	PUSHJ P,TYDATE		;type out date
	POP P,B			;potential date, in case verified by operator
	OUTSTR [ASCIZ/
then type GO<return>; otherwise type <return>: /]
	PUSHJ P,GETGO		;get response
	 JRST VALDA2		;random response (X<return>), read date from user
	 JRST VALDA3		;typed GO, store date from B
	JRST VALDA2		;just <return> typed, ask for date
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ;tape copy -- check for new input dump ; TCOPND NEWIDE TCOPN1 TCOPA0 TCOPAD

;Check for having encountered a new dump, i.e., PPN out of order on new tape.
;Skips unless want to simulate physical EOT or hit real physical EOT.
TCOPND:	MOVE D,FILINF+DDPPN	;get PPN
	CAME D,FAKEFI+3		;don't log file if fake PPN
	SKIPN MASCOP		;skip if master copy
	JRST CPOPJ1		;no binary file being written for user copy
	CAMN D,SPPN		;same PPN as before?
	JRST CPOPJ1		;yes, can't be out of order
	PUSHJ P,TCOPAD		;skip unless file is ALLDIR.DAT[DMP,SYS]
	 JRST CPOPJ1		;omitting file from DTAPES, ignore PPN out of order
	MOVEM D,DNX		;remember new PPN for order check
	SKIPE D,SPPN		;check old PPN
	JRST CPOPJ1		;not first file on input tape, not new dump
	MOVE A,MEMSAV+ITEPPN	;get back final PPN from previous tape
	MOVEM A,TNX		;set up for comparison with new PPN
	PUSHJ P,SWPJST		;swap LH and RH of DNX and TNX, left justifying each half
	PUSHJ P,PPNCMP		;Skip if DNX is greater than or equal to TNX.
	 PUSHJ P,INCDMP		;Looks like new dump, increment RELABS, skip if too big
	  JRST CPOPJ1		;In right order, or RELABS incremented OK
	MOVE A,MTFBEG		;make sure we're looking at a new MT file
	CAIE A,1		;1 means input file is first thing in MT file
	JRST TCOPN1		;OOPS!  new tape, new PPN, but middle of MT file??
	PUSHJ P,NEWMTF		;write EOF, before finishing off the output tape
	 POPJ P,		;physical EOT on output, need new output tape anyway
	OUTSTR NEWIDE		;tell what happened
	OUTSTR [ASCIZ/So we'll start a new output tape, despite not having reached physical EOT.
/]
	PUSHJ P,STOIFN		;store current input filename for pickup
	POPJ P,			;simulate physical EOT to force new output tape

NEWIDE: ASCIZ/
New input dump exceeds output tape max number of dumps.
/

TCOPN1:	OUTSTR NEWIDE		;tell what started this
	OUTSTR [ASCIZ/%%% BUT current input file seems not to be at beginning of a magtape file.
%%% Find a wizard -- do not try to go on.
/]
	HALT .	;we could probably proceed by not calling STOIFN and hoping we
		;don't have to do a pickup around here.
		;But we do have to start a new output tape.

;Skip unless file is ALLDIR.DAT[DMP,SYS].  PPN already in D for TCOPAD.
TCOPA0:	MOVE D,FILINF+DDPPN	;get PPN
TCOPAD:	MOVE A,FILINF+DDNAM	;get filename
	CAMN D,['DMPSYS']
	CAME A,['ALLDIR']
	JRST CPOPJ1
	HLRZ A,FILINF+DDEXT
	CAIE A,'DAT'
	AOS (P)			;some other file, skip return
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ;tape copy -- add file data to DTAPES.DAT ; TCOPDT TCOPD2 TCOPD3 TCOPD4 ADJDAT CKDATE POPABJ DMPPN0 DMFIL0

;Update DTAPES.DAT for file just copied.
TCOPDT:	MOVE D,FILINF+DDPPN	;get PPN
	CAME D,FAKEFI+3		;don't log file if fake PPN
	SKIPN MASCOP		;skip if master copy
	POPJ P,			;no binary file being written for user copy
	AOS MEMSAV+MTADFI	;count a disk file copied
	SKIPE TAPERR		;skip unless we saw input tape media errors
	AOS MEMSAV+MTADFE	;count a disk file copied with errors
	CAMN D,SPPN		;same PPN as before?
	JRST TCOPD3		;yes
	PUSHJ P,TCOPAD		;skip unless file is ALLDIR.DAT[DMP,SYS]
	 POPJ P,		;omit file from DTAPES, PPN probably out of order
	MOVEM D,DNX		;remember new PPN for order check
	EXCH D,SPPN		;remember new PPN, check old
	JUMPE D,TCOPD2		;jump if this is first file on input tape
	MOVEM D,TNX		;store old PPN for comparison
	PUSHJ P,SWPJST		;swap LH and RH of DNX and TNX, left justifying each half
	PUSHJ P,PPNCMP		;Skip if DNX is greater than or equal to TNX.
	 SETOM MEMSAV+DTAOOO	;set flag indicating PPNs in DTAPES now out of order
	MOVEI A,0		;end old PPN with a zero
	PUSHJ P,DMPUTX		;output zero
TCOPD2:	SKIPN A,SPPN		;file PPN
	 PUSHJ P,DMPPN0		;PPN better not be zero -- would screw up format
	PUSHJ P,DMPUTX		;output new PPN
TCOPD3:	SKIPN A,FILINF+DDNAM	;get filename
	 PUSHJ P,DMFIL0		;file name can't be zero -- would screw up format
	PUSHJ P,DMPUTX		;output filename
	MOVE A,FILINF+DDEXT	;get extension
	HRR A,MEMSAV+MCOTAP	;get output tape number
	HLRZ B,MEMSAV+RELABS	;get relative dump number
	LSH B,-RDLBTS		;shift low bits off low end
	DPB B,[POINT RDHBTS,A,RDHPOS+=18] ;insert high bits of relative dump nbr
	SKIPE TAPERR		;skip unless we saw input tape media errors
	TRO A,PRMERR		;indicate previous media error in data base
	PUSHJ P,DMPUTX		;output extension and tape number/bits
	MOVE A,FILINF+DDPRO	;get date word
	ANDI A,7777		;just low-order date bits
	LDB B,[POINT 3,FILINF+DDEXT,20] ;get high-order date bits
	DPB B,[POINT 3,A,23]	;combine high and low date
	PUSHJ P,CKDATE		;make sure date is within range, maybe fix it
TCOPD4:	HLRZ B,MEMSAV+RELABS	;get rel dump nbr
	DPB B,[POINT RDLBTS,A,RDLPOS] ;insert low bits of relative dump nbr
	PUSHJ P,DMPUTX		;output date written and low bits of rel dmp nbr
	POPJ P,

;Check date written in retrieval and zero it if it is out of reasonable range.
;Here from TCOPFI.  Clobbers A and B.
ADJDAT:	MOVE A,FILINF+DDPRO	;get date word
	ANDI A,7777		;just low-order date bits
	LDB B,[POINT 3,FILINF+DDEXT,20] ;get high-order date bits
	DPB B,[POINT 3,A,23]	;combine high and low date
	PUSHJ P,CKDATE		;make sure date is within range, maybe fix it
	JUMPN A,CPOPJ		;return unless date was bad
	DPB A,[POINT 12,FILINF+DDPRO,35] ;store zero in low-order date bits
	DPB A,[POINT 3,FILINF+DDEXT,20] ;store zero in high-order date bits
	AOS BADDAT		;count an error of this type
	AOS TAPERR		;count an error of any type
	POPJ P,

;Check the date in low bits of A, making sure it is reasonable.  If not, zero it.
CKDATE:	PUSH P,B		;save this in case from MERGE
	PUSH P,A		;save non-date bits (MERGE)
	ANDI A,DATMSK		;just the date bits
	SKIPE MASCOP		;only check for master tape copy
	CAMG A,MEMSAV+MTIDAT	;make sure date written is in range
	JRST POPABJ		;OK
;	OUTSTR [ASCIZ/  Fixing bad file date in database: /]
	OUTSTR [ASCIZ/  Zeroing bad file date: /]
	PUSHJ P,TYDATE		;report date that's bad
	OUTSTR [ASCIZ/  (/]
	MOVE A,(P)		;get date again
	ANDI A,DATMSK		;just date bits
	PUSHJ P,TYPOCT		;type octal date value
	OUTCHR [")"]
	OUTSTR CRLF
;	MOVE A,MEMSAV+MTIDAT	;date out of range, use forward limit for date
	POP P,A			;original date word
	TRZA A,DATMSK		;date out of range, use zero for date written
POPABJ:	POP P,A
	POP P,B
	POPJ P,

;Bugtrap: Here if we were just about to write a zero PPN into DTAPES.DAT.
DMPPN0:	OUTSTR [ASCIZ /
%%% PPN being written into DTAPES.DAT is zero!  Can't continue.  Find a wizard.
/]
	HALT .	;How should we recover?  Must detect zero earlier.
		;We could set DTAOOO and invent a funny nonzero PPN (both halves)

;Bugtrap: Here if we were just about to write a zero file name into DTAPES.DAT.
DMFIL0:	OUTSTR [ASCIZ /
%%% File name going into DTAPES.DAT is zero!  Can't continue.  Find a wizard.
/]
	HALT .	;How should we recover?  Could just make funny nonzero file name.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ;tape copy -- hit logical end of input tape ; TCLEOT TCOPUE

;Here if hit logical end of tape on input tape.
TCLEOT:	TRZ FL,MTAEOT
	PUSHJ P,NEWMTF		;close output tape if necessary
	 JRST TCPEOT		;EOT on output, need new output tape
	SKIPE MASCOP		;skip unless master copy
	JRST MCLEOT		;figure out next input tape for master copy
	OUTSTR [ASCIZ/Any more input tapes? /]
	PUSHJ P,YORN		;yes or no
	 JRST TCOPUE		;no more, all done
	PUSHJ P,MTAREW		;rewind input tape
	OUTSTR [ASCIZ/Mount the next input tape and type RETURN to proceed. /]
	INCHWL A
	PUSHJ P,FLUSH1		;flush to end of line
	PUSHJ P,MTACLZ		;close input
	OUTSTR [ASCIZ/Want me to rewind new input tape? /]
	PUSHJ P,YORN
	 CAIA			;no
	PUSHJ P,MTAREW		;Yes, rewind input tape
	PUSHJ P,MTANOP		;do a mta no-op to detect front of TAPE
	JRST TCOPFI		;go read another file

;Here if user said there are no more input tapes or if all input terms
;have been satisfied (files copied).
TCOPUE:	OUTSTR [ASCIZ/Want final INPUT tape rewound? /]
	PUSHJ P,YORN
	 CAIA			;no
	PUSHJ P,MTAREW		;Yes, rewind input tape
	OUTSTR [ASCIZ/Want final OUTPUT tape rewound? /]
	PUSHJ P,YORN
	 CAIA			;no
	PUSHJ P,MT2REW		;Yes, rewind output tape
	PUSHJ P,MT2REL		;release output tape
	PUSHJ P,MTAREL		;release input tape
	OUTSTR [ASCIZ/Tape copy finished.
/]
	TRZ FL,SAFETY
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ;tape copy -- logical end of input tape in MCOPY ; FS3600 MCLEOT MCLECL MCLEFL Counts TELWIN

FS3600__=2457	;P tape number of first 3600-foot tape (assumes rest are 3600').

;Here when have hit logical end of input tape in master tape copy.
;First, report some data on tape just finished, then verify that that
;was a reasonable spot for logical end of tape.
;Figure out what input tape we want next, request it,
;rewind it, set PREQTP, and return to the copying loop.
MCLEOT:	MOVE A,[MEMSAV+MTCLPE,,TCIEC2] ;save the old counts (from BOT, we hope)
	BLT A,TCIEC2+NSYSCT-1	;we'll subtract old from new shortly
	PUSHJ P,GETECT		;get system's tape counts into MEMSAV+MTCLPE, etc.
	;now we subtract old from new counts and publish the results
	SETOM STATLG		;tell UUOTRP to save text of stats for us
	MOVEI A,STATLN		;number of free bytes in buffer
	MOVEM A,STATFR		;all free so far
	MOVE A,[POINT 7,STATBF]
	MOVEM A,STATBP		;init byte ptr into buffer
	OUTSTR [ASCIZ/
System counts for input tape P/]
	MOVE A,MEMSAV+MCITAP	;get input tape number
	PUSHJ P,DECOUT		;print tape nbr
	OUTSTR [ASCIZ/ on /]
	MOVE A,MTDEV		;get input device
	PNAME A,		;get physical device name
	 JFCL			;can't fail
	PUSHJ P,SIXOUT		;type sixbit device name
	OUTSTR [ASCIZ/:	Records read OK:
/]
	MOVSI C,-NMECNT		;aobjn ptr to the error counts
MCLECL:	OUTSTR [ASCIZ/    /]	;indent error count text
	OUTSTR @TXTECT(C)	;type error count's description
	MOVE A,MEMSAV+MTCLPE(C)	;get new system error count
	CAML A,TCIEC2(C)	;if count went backwards, report new system total
	SUB A,TCIEC2(C)		;subtract value at beginning of input tape
	PUSHJ P,DECOUT		;report the count
	PUSHJ P,TELWIN		;report win count for given try
	OUTSTR CRLF
	AOBJN C,MCLECL		;loop through table of error counts
	OUTSTR [ASCIZ/MT read errors . . . . . . . . . /]
	MOVE A,MEMSAV+MTLOSE	;get new system losing record count
	CAML A,TCIEC2+MTLOSE-MTCLPE ;if count went backwards, report new sys cnt
	SUB A,TCIEC2+MTLOSE-MTCLPE ;subtract old system count
	PUSHJ P,DECOUT		;report the count
	HRLI C,NMECNT-MTREDO	;-number of tries left to document winning cnts for
	PUSHJ P,TELWIN		;report win number
	AOBJN C,.+1		;one more try done
	OUTSTR [ASCIZ/
Checksum errors, no read error . /]
	MOVE A,MEMSAV+CHKSUE	;get checksum error count
	PUSHJ P,DECOUT		;print it
	PUSHJ P,TELWIN		;report win count for given try
	AOBJN C,.+1		;one more try done
	OUTSTR [ASCIZ/
Records read from input tape . . /]
	MOVE A,MEMSAV+MTAIRG	;number of records read since last rewind
	PUSHJ P,DECOUT		;report the count
	PUSHJ P,TELWIN		;report win count for given try
	AOBJN C,.+1		;one more try done
	OUTSTR CRLF
	SKIPL A,PTCNTP		;get ptr to table of expected files/tape
	JRST NOPTC		;huh, no ptr?
	ADD A,MEMSAV+MCITAP	;add in offset, which is tape number
	PUSH P,(A)		;save expected number of files
	MOVN A,MEMSAV+MCITAP	;make aobjn count from tape number
	MOVSI A,(A)		;negative cnt in LH, we'll add one less than this
	HRR A,PTCNTP		;ptr to incore table of expected files per tape
	TDZA B,B		;count expected file total here
MCLEFL:	ADD B,(A)		;add in expected file count for one tape
	AOBJN A,MCLEFL		;count all tapes through previous one
	PUSH P,(A)		;save expected count for current tape for checking
	PUSH P,B		;save total expected from all previous tapes
	PUSHJ P,TCOPAD		;skip unless latest file was ALLDIR.DAT[DMP,SYS]
	 AOS -1(P)		;count another expected file for current tape
	HRRZ A,MEMSAV+RELABS	;get dump set number
	SUBI A,1		;make nbr of previous dumps that we've finished
	ADDM A,(P)		;increase previous tapes total for all ALLDIR.DATs
	OUTSTR [ASCIZ/ Disk File	/]
	MOVE A,MTDEV		;get input device
	PNAME A,		;get physical device name
	 JFCL			;can't fail
	PUSHJ P,SIXOUT		;type sixbit device name
	OUTSTR [ASCIZ/:	Previous		In progress:
  Counts:	/]
	MOVE A,MEMSAV+MCITAP	;current input tape number
	CAIGE A,=100
	OUTCHR [" "]		;indent a little for 1:99
	OUTCHR ["P"]
	PUSHJ P,DECOUT		;type input tape number
	OUTSTR [ASCIZ/	  Tapes		    Dump set /]
	HRRZ A,MEMSAV+RELABS	;get dump set number
	PUSHJ P,DECOUT		;type it
	OUTSTR [ASCIZ/, P/]
	MOVE A,MEMSAV+MCOTAP	;current output tape number
	PUSHJ P,DECOUT		;type it
	OUTCHR ["/"]		;indicate rel dmp nbr
	HLRZ A,MEMSAV+RELABS	;get rel dmp number
	PUSHJ P,DECOUT		;type it
	OUTSTR [ASCIZ/
						   /]
	MOVE A,MEMSAV+MT2POS	;output tape position
	PUSHJ P,TYFOOT		;type output position in feet
	OUTSTR [ASCIZ/
    Expected  .	/]
	MOVE A,-1(P)		;expected disk file count, current tape
	MOVE B,(P)		;expected disk files, previous tapes
	PUSHJ P,DECAB		;report two numbers in A and B in aligned cols
	OUTSTR [ASCIZ/
    Missing . . /]
	MOVE A,-1(P)		;expected count, current tape
	SUB A,MEMSAV+MTADFI	;minus count of files seen on tape is nbr missing
	MOVE B,(P)		;expected count, previous tapes
	SUB B,MEMSAV+MCODFI	;minus files seen on previous tapes is nbr missing
	PUSHJ P,DECAB		;report two numbers in A and B in aligned cols
	OUTSTR [ASCIZ/
    Read  . . . /]
	MOVE A,MEMSAV+MTADFI	;count of files seen on tape
	MOVE B,MEMSAV+MCODFI	;files seen on previous tapes
	PUSHJ P,DECAB		;report two numbers in A and B in aligned cols
	OUTSTR [ASCIZ/
    Imperfect . /]
	MOVE A,MEMSAV+MTADFE	;error count for files seen on tape
	MOVE B,MEMSAV+MCODFE	;error count for files seen on previous tapes
	PUSHJ P,DECAB		;report two numbers in A and B in aligned cols
	OUTSTR [ASCIZ/
    Perfect . . /]
	MOVE A,MEMSAV+MTADFI	;count for files seen on tape
	SUB A,MEMSAV+MTADFE	;minus error count for tape is perfect file count
	MOVE B,MEMSAV+MCODFI	;count for files seen on previous tapes
	SUB B,MEMSAV+MCODFE	;minus error count for previous tapes is perf cnt
	PUSHJ P,DECAB		;report two numbers in A and B in aligned cols
repeat 0,<
	OUTSTR [ASCIZ/
    Perfect % ./]
>;repeat 0
	OUTSTR CRLF
	PUSHJ P,PDSTAT		;pad stats buffer with nulls to end of word
	MOVEM A,STATSU		;save byte ptr to start of summary stats
	MOVE A,MEMSAV+MCITAP	;get number of input tape
	PUSHJ P,REEL00		;convert to P00001 sixbit form in D
	MOVE A,D
	PUSHJ P,SIXOUT		;type P00001 form of tape number
	OUTSTR [ASCIZ/ on /]
	MOVE A,MTDEV		;get input device
	PNAME A,		;get physical device name
	 JFCL			;can't fail
	PUSHJ P,SIXOUT		;type sixbit device name
	OUTCHR [":"]
	MOVE A,MEMSAV+MTADFI	;count for files seen on tape
	SUB A,MEMSAV+MTADFE	;minus error count for tape is perfect file count
	MOVE B,-1(P)		;expected count, current tape
	PUSHJ P,TYPPER		;print A/B as a percentage
	OUTSTR [ASCIZ/	  /]	;skip to second col
	MOVE A,MEMSAV+MCODFI	;count for files seen on previous tapes
	SUB A,MEMSAV+MCODFE	;minus error count for previous tapes is perf cnt
	POP P,B			;expected count, previous tapes
	PUSHJ P,TYPPER		;print A/B as a percentage
	OUTSTR [ASCIZ/  /]	;two spaces
	OUTSTR MEMSAV+TBRAND	;tape brand and model text (from operator earlier)
	OUTCHR [11]		;output at least one tab
	MOVE A,MEMSAV+NBRAND	;length of brand
	CAIGE A,6		;skip unless really short brand name
	OUTCHR [11]		;really short name, add another tab
	CAIGE A,=14		;skip unless short brand name
	OUTCHR [11]		;short name, add another tab
	MOVEI A,1000
	ADDM A,MCLCOL		;prevent insertion of CRLF by MCLCH2
	PUSHJ P,TYWHE0		;type time and date and CRLF
	SETZM STATLG		;disable collecting of stats text by UUOTRP
	OUTSTR CRLF		;blank line to delimit stats line (for copy w/E)
	POP P,A			;expected number of files for latest tape
	MOVE B,MEMSAV+MTADFI	;get number of files we saw on tape
	CAIG A,20(B)		;did we find most of the files?
	JRST MCLEO2		;yes
	;;; not as many files were seen as expected.
	;;; check to see if last file was ALLDIR.DAT or a tape trailer.
	MOVE A,MEMSAV+FFILE	;maybe last file was tape trailer
	CAME A,['*TAIL*']	;skip if tape trailer just seen
	PUSHJ P,TCOPA0		;skip unless last file was ALLDIR.DAT[DMP,SYS]
	 JRST MCLEO2		;OK, seem to have seen last expected file on tape
	MOVE A,MEMSAV+MTAPOS	;get input tape position
	IDIV A,MTFOOT		;get feet in A
	MOVE B,MEMSAV+MCITAP	;get tape number
	CAIGE B,FS3600		;before first 3600 foot tape?
	CAIGE A,=2200		;yes, assume 2400 foot tape -- close to end?
	CAIL A,=3400		;are we close to end of tape?
	JRST MCLEO2		;yup, go right ahead, I guess
	OUTSTR [ASCIZ/
%%% This may be a phony logical end-of-tape.  There were supposed to be
%%% more files on this tape.  If you're sure this is really the end of the
%%% tape (e.g., tape near end of reel), then type CONTINUE (to the monitor).
%%% Otherwise, type MCOPY to back up and retry this part of the copy.
/]
	HALT MCLEO2

TELWIN:	JUMPGE C,CPOPJ		;return quickly if no more try counts
	OUTSTR [ASCIZ/		  On try /] ;about to print successes on given try
	MOVEI A,1(C)		;number of try
	PUSHJ P,DECOUT		;print try number
	OUTSTR [ASCIZ/:  /]
	MOVE A,MEMSAV+MTWIN(C)	;get new system winning count for this try
	CAML A,TCIEC2+MTWIN-MTCLPE(C) ;if count went backwards, report new sys cnt
	SUB A,TCIEC2+MTWIN-MTCLPE(C) ;subtract saved winning count
	JRST DECOUT		;report the count and return
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ;tape copy -- finish handling end of input tape ; FTLIFT MCLEO2 TCPIKA MCLEO3 TCPIKA TCPIKB TCPIB2 TCPIKC TCPIKD

FTLIFT__0	;nonzero if require operator to insert tape lifter before rewind
MCLEO2:	MOVE A,SPPN
	MOVEM A,MEMSAV+ITEPPN	;remember last PPN on input tape, for dump-end test
IFE FTLIFT,<	;version without teflon spacer, start rewind immediately
	PUSHJ P,MTAUNL		;rewind and unload the old input tape
	PUSHJ P,MTAREL		;release input tape
TCPIKA:
>;IFE FTLIFT
	PUSHJ P,PDSTAT		;pad stats buffer with nulls to end of word
	PUSHJ P,UPSTAT		;output the stats to special files
	MOVEI A,MCPIKA		;pickup code
	PUSHJ P,MASPIK		;record pickup point and state info
IFN FTLIFT,< ;don't rewind until operator has teflon spacer in place
	PUSHJ P,TYWHEN		;type date and time
MCLEO3:	OUTSTR [ASCIZ/  Need to rewind INPUT tape.  Insert tape lifter, then type GO<return>: /]
	MOVNI A,1
	BEEP A,			;get operator's attention
	PUSHJ P,GETGO		;look for GO response
	 JRST MCLEO3		;garbage answer
	 CAIA			;said GO
	JRST MCLEO3		;said <return>
	PUSHJ P,TYWHEN		;type date and time
	PUSHJ P,MTAUNL		;rewind and unload (if possible) the old input tape
	PUSHJ P,MTAREL		;release input tape
	SKIPG ARCWC		;better be something on output tape!
	JRST TCPIRE		;nope, maybe detected logical EOT really early?
TCPIKA:		;if come here for pickup, simply won't re-store same pickup code
>;IFN FTLIFT
	PUSHJ P,MFIXD		;fix position of output to DTAPES.DAT
	SKIPG ARCWC		;better be something on output tape!
	JRST TCPIRE		;nope, maybe detected logical EOT really early?
	MOVEI A,0
	SKIPE SPPN		;did we start a PPN record?
	PUSHJ P,DMPUTX		;yes, end it with a zero word
	MOVE B,MEMSAV+DTAMAX	;maximum length DTAPES.DAT has been backed up from
	SUB B,ARCWC		;minus number of words we've output is zeroes needed
	PUSHJ P,DMPUTX		;mark end of file with zeroes (in case backed up!)
	SOJG B,.-1		;overwrite data we backed up over with zeroes
	SETZM SPPN		;no saved PPN yet (for next tape)
	PUSHJ P,DMFINI		;write out last buffer, if necessary
	CLOSE DSKMSC,		;close the file
TCPIKB:	SKIPN MEMSAV+DTAOOO	;did any PPNs occur out of order in DTAPES.DAT?
	JRST TCPIB2		;no
	MOVEI A,MCPIKB		;pickup code
	PUSHJ P,MASPIK		;record pickup point and state info
	PUSHJ P,DTSORT		;must sort DTAPES to make merge work
	SETZM MEMSAV+DTAOOO	;no longer any out of order PPNs
TCPIB2:	MOVEI A,MCPIKB		;pickup code
	PUSHJ P,MASPIK		;record pickup point and state info
	SKIPE MEMSAV+MERGFL	;skip unless already done merge
	JRST TCPIKC		;don't do merge again
	SKIPG A,MEMSAV+MTIDAT	;do we know valid date written of input tape?
	PUSHJ P,VALDAT		;no, validate date or get one from operator
	PUSHJ P,MERGE0		;merge DTAPES.DAT with DART.DAT for one input tape
TCPIKC:	MOVEI A,MCPIKC		;pickup code
	PUSHJ P,MASPIK		;record pickup point and state info
	PUSHJ P,SAVINP		;save emergency copy of DART.MEM as P00001.MEM
	PUSHJ P,MCPVER		;verify the format of DART.DAT we just wrote
TCPIKD:	MOVEI A,MCPIKD		;pickup code
	PUSHJ P,MASPIK		;record pickup point and state info
	AOS A,MEMSAV+MCITAP	;get next input tape number
	;if we've reached the first 6250-bpi input tape yet, change input devices
	CAIN A,FS6250		;is this the first 6250 tape?
	PUSHJ P,US6250		;yes, we probably need to change input device
	PUSHJ P,MCNEWI		;request and set up new input tape
	JRST TCPIK0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ; Counts NOPTC MCNEWI BRANEW BRANDL GBRAND GBRAN2 GETBRN GETBOO GETBCR GETBXT

comment  Example stats at end of input tape:

System counts for input tape P62 on MTA1:	Records read OK:
    Longitudinal parity errors . 242		  On try 1:  10041
    Lateral parity errors  . . . 1214		  On try 2:  210
    Illegal drive operations . . 0		  On try 3:  22
    Tape drive data missed . . . 531		  On try 4:  2
    DC 136 data missed . . . . . 10		  On try 5:  1
MT read errors . . . . . . . . . 143		  On try 6:  2
Checksum errors, no read error . 10		  On try 7:  2
Records read from input tape . . 10234
 Disk File	MTA1:	Previous		In progress:
  Counts:	 P62	  Tapes		    Dump set 14, P3002/2
						   1234 ft
    Expected  .	 784      49316
    Missing . .    0       5096
    Read  . . .  784      44220
    Imperfect .   45       2894
    Perfect . .  739      41326
P00062 on MTA1: 94.3%	   83.8%  Scotch 777   	11:34   6-Jul-87   (13 mins)

end of comment 

NOPTC:	OUTSTR [ASCIZ/
%%% Unexpected error: No PTCNT pointer found -- find a wizard.
/]
	HALT .

;initialize for new input tape
MCNEWI:	SETZB A,B		;zero two counts
	EXCH A,MEMSAV+MTADFI	;no disk files copied from this input tape yet
	ADDM A,MEMSAV+MCODFI	;count disk files copied from all input tapes
	SETZM MEMSAV+MTEDFI	;clear saved disk file count for tape
	EXCH B,MEMSAV+MTADFE	;no disk files copied with errors from this tape
	ADDM B,MEMSAV+MCODFE	;count disk files copied w/errors from all tapes
	SETZM MEMSAV+MTEDFE	;clear saved disk file error count for tape
	SETZM MEMSAV+MTIDAT	;no date from tape header yet
	SETZM MEMSAV+CHKSUE	;no checksum errors from this tape yet
	PUSHJ P,BRANEW		;get brand of new tape
	PUSHJ P,MCIMNT		;mount input tape for master copy
	PUSHJ P,MTAREW		;rewind new input tape
	PUSHJ P,GETECT		;get system's tape error counts into MEMSAV+MTCLPE
	PUSHJ P,DTDINI		;open DTAPES.DAT for binary data of copy
	POPJ P,

BRANEW:	PUSHJ P,BRANDL		;load previous tape brand into line editor
	SETZM MEMSAV+TBRAND	;no brand name for this tape yet
	SETZM THSTAP		;no tape header read yet
	PUSHJ P,TYWHEN		;type date and time
	PUSHJ P,GBRAND		;get brand and type of input tape, for stats
	POPJ P,

;Load previous tape brand, if any, into line editor.
BRANDL:	SKIPE MEMSAV+TBRAND	;if any previous brand, load line editor with it
	SKIPN BRENDP		;make sure we have a byte ptr
	POPJ P,
	MOVEI A,15		;a CR to end previous brand line
	DPB A,BRENDP		;make CR on new line actually send a CR
	PTLOAD [0MEMSAV+TBRAND] ;load line editor
	POPJ P,

;get brand of next tape from operator
GBRAND:	SKIPE MEMSAV+TBRAND	;skip if no brand name string stored
	POPJ P,
GBRAN2:	OUTSTR [ASCIZ/Please enter Brand and Model of INPUT tape P/]
	MOVE A,MEMSAV+MCITAP	;get input tape number
	PUSHJ P,DECOUT		;type it
	OUTSTR [ASCIZ/:  /]
	PUSHJ P,GETBRN		;get line of input
	MOVE A,MEMSAV+TBRAND
	TDZ A,[BYTE (7)40,40,40,40,40] ;convert first chars to upper case
	CAME A,[ASCIZ/GO/]	;avoid common mistaken response
	JUMPN A,CPOPJ		;return if nonempty response
	JRST GBRAN2		;try again

;Get line of text from user and store at MEMSAV+TBRAND.
GETBRN:	MOVEI B,MEMSAV+TBRAND	;place to collect brand text
	HRLI B,440700		;make byte ptr
	MOVEI C,<LBRAND*5>-1	;max length in chars
	INCHWL A		;get first char
	CAIE A,11		;ignore leading tabs
	CAIN A," "		;ignore leading spaces
	JRST GETBRN
GETBOO:	CAIN A,15		;ignore CR
	JRST GETBCR
	CAIE A,175
	CAIN A,12
	JRST GETBXT		;end of line
	SOSL C			;skip if ran out of room in buffer
	IDPB A,B
GETBCR:	INCHWL A		;get next char
	JRST GETBOO		;loop till end of line

GETBXT:	MOVEI A,0		;end text string with a null
	IDPB A,B
	MOVEM B,BRENDP		;save byte ptr to end of brand for inserting CR
	SUBI C,<LBRAND*5>-1	;make negative of number of chars
	MOVNM C,MEMSAV+NBRAND	;save positive length for formatting at MCLEOT
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ;tape copy -- printing subroutines ; DECAB COL10 COL9 COL4 COL3 TYPPER TYP100

;Print counts from A and B in two columns, each right aligned.
DECAB:	PUSH P,B		;save second nbr
	PUSHJ P,COL4		;print number in at least this many cols
	OUTCHR [" "]		;space to second col
	POP P,A			;second number
	PUSHJ P,COL10		;print number in at least this many cols
	POPJ P,

;Right align the number in A.  Slow but simple.
COL10:	CAMGE A,[=1000000000]
	OUTCHR [" "]
	CAMGE A,[=100000000]
	OUTCHR [" "]
	CAMGE A,[=10000000]
	OUTCHR [" "]
	CAMGE A,[=1000000]
	OUTCHR [" "]
	CAIGE A,=100000
	OUTCHR [" "]
	CAIGE A,=10000
	OUTCHR [" "]
COL4:	CAIGE A,=1000
	OUTCHR [" "]
COL3:	CAIGE A,=100
	OUTCHR [" "]
	CAIGE A,=10
	OUTCHR [" "]
	JUMPGE A,DECOUT		;now print the number
	MOVEI A,0		;but make sure it isn't negative
	JRST DECOUT		;print zero for negative numbers

;Print A/B as a percentage, with one digit after decimal point.
TYPPER:	CAML A,B		;limit to 100%
	JRST TYP100		;limited
	IMULI A,=1000		;scale to units of .1%
	MOVE C,B		;make copy of divisor
	LSH C,-1		;divide by two
	ADD A,C			;force rounding up for .05% or more
	IDIV A,B		;get units of .1% in A
	IDIVI A,=10		;units of 1% in A, of .1% in B
	PUSH P,B		;save fraction
	PUSHJ P,COL3		;print integer part in 3 cols, right aligned
	OUTCHR ["."]		;decimal pt
	POP P,A			;fraction
	PUSHJ P,DECOUT		;print single digit fraction
	OUTCHR ["%"]
	POPJ P,

TYP100:	OUTSTR [ASCIZ/100.0%/]
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ;tape copy -- copy Dart header or trailer ; TCPHTR TCPHT2

;Copy Dart header or trailer block that we saw onto the output tape.
repeat 0,<
;Note that we don't save a "filename" in MEMSAV for this hdr/trlr, so we
;won't use this position to pickup at on the tape (FIXPOS doesn't know how
;to verify a position in a previous media hdr/trlr).
>;repeat 0
;If the header or trailer we're copying wasn't previously copied, then we
;mark it as a copied header/trailer with the PRVMTM bit and we set CUPRVH so
;that pickup will understand that the output tape has this extra bit in RHDATE.
;We also extend and/or update the header to contain current dump numbers,
;tape position, test words, and checksum.
TCPHTR:	AOS MTFBEG		;we've seen another file (hdr/trlr) after tape EOF
	PUSHJ P,NEWMTF		;force out prev data, write an EOF, if necessary
	 JRST TCPEOT		;EOT on output, need new output tape
	PUSHJ P,STOIFN		;store current input filename (hdr/trlr) for pickup
	SKIPE TELEOF		;skip unless debugging, reporting EOFs
	OUTSTR [ASCIZ/--Copying header or trailer block--/]
	;We update the header to current format.
	HRLZ A,.JBVER		;GET THE VERSION NUMBER
	HRRI A,HEDLEN		;WORD COUNT FOR current format HEADER
	MOVEM A,RHDLEN		;overwrite old word count word
	MOVSI A,PRVMTM		;get bit indicating previous media date/time
	TDNN A,RHDATE		;skip if header already marked as prev media hdr
	SETOM MEMSAV+CUPRVH	;tell pickup that we changed a bit in copied hdr
	IORM A,RHDATE		;insert bit in new header being written out
	MOVE A,MEMSAV+RELABS	;get dump numbers
	MOVEM A,RHDNBR		;put current dump numbers into copied hdr
	MOVE A,MEMSAV+MT2POS	;PICK UP output MTA POSITION
	ADD A,[6*MXINCH]	;ADD 6 INCHES FOR ROUNDING
	IDIV A,MTFOOT		;GET FEET (REMAINDER IN B)
	MOVEM A,RHDPOS		;put current footage into copied hdr
	SETZM RHDRES		;clear reserved word
	SETOM RHDONE		;set all bit in word of ones
	SETZM RHDZER		;clear word of zeroes
	;Compute rotated checksum of header or trailer.
	MOVEI B,RHDCOP		;ptr to data to checksum
	PUSHJ P,ROTCHK		;compute rotated checksum in A
	MOVEM A,RHDCHK		;store new checksum (we set PRVMTM bit above).
	MOVN B,RHDLEN		;use length of current format header
	MOVSI B,-1(B)		;include length word in aobjn's negative wd count
TCPHT2:	MOVE A,RHDCOP(B)	;get word from old header
	PUSHJ P,TWRITE		;write out a word
	 JRST TCPEOT		;physical end of tape (IOTEND has been cleared)
	AOBJN B,TCPHT2		;loop copying header/trailer block
	PUSHJ P,NEWMT0		;close output, to write an EOF here
	 JRST TCPEOT		;EOT on output
	JRST TCOPFI		;go read another file
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ;tape copy -- write EOF on output tape ; NEWMTF NEWMT0 POPAJ1 NEWMTT

;Write an EOF on output tape if have done any output.
;Takes skip return on success (or nothing to do).
;Takes direct return if hits physical EOT while trying to write EOF.
;Halts if any tape output error other than physical EOT.
NEWMTF:	SKIPN PRVPPN		;skip unless already closed
	JRST CPOPJ1		;nothing to do
NEWMT0:	PUSHJ P,MT2CLZ		;write an EOF
	PUSH P,A
	MOVE A,WRCSZ		;size of a buffer
	MOVEM A,WC		;SET UP WC for fresh buffer
	SETZM MTFILN		;start over counting records in magtape file
	PUSHJ P,MT2CTS		;skip if EOF written OK, remember where written
	 JRST NEWMTT		;phys end of tape
	SETZM PRVPPN		;no output in new MT file
	MOVE A,ARCWC		;get word count for DTAPES.DAT
	MOVEM A,MEMSAV+PTRSAV	;and remember for pickup
	MOVE A,SPPN		;get last PPN in DTAPES.DAT
	MOVEM A,MEMSAV+LUSER	;remember it
	MOVE A,MEMSAV+CUSER	;remember the file that starts MT output
	MOVEM A,MEMSAV+FUSER	;  file just closed
	MOVE A,MEMSAV+CFILE
	MOVEM A,MEMSAV+FFILE
	HLLZ A,MEMSAV+CEXT
	MOVEM A,MEMSAV+FFEXT
	MOVE A,MEMSAV+CUPRVH	;remember whether this is a copied/altered header
	MOVEM A,MEMSAV+FUPRVH
	MOVE A,MEMSAV+RELABS	;get rel and absolute dump numbers
	MOVEM A,MEMSAV+REEABE	;remember then in case of pickup
POPAJ1:	POP P,A
	JRST CPOPJ1		;skip return for success

;Here on physical end of tape from trying to write EOF.
;Takes direct return from NEWMTF.
NEWMTT:	POP P,A
	PUSHJ P,MT2CLZ		;clear error, write log EOT (is this necessary?)
	POPJ P,			;take direct return from NEWMTF
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ;tape copy -- hit physical end of output tape ; TCPEOT TCPIKX TCPIKY

;Here when hit physical EOT while copying.  Back up input tape to
;known place, then release input tape, back up output tape to same known
;spot and then finish off output tape, rewind it, and request a new one,
;and then loop back to place where we write a tape header.
TCPEOT:	OUTSTR [ASCIZ/ Not saved -- physical end of output tape: /]
	MOVE A,MEMSAV+MT2POS	;get output tape position
	PUSHJ P,TYFOOT		;type footage
	OUTSTR CRLF
	PUSHJ P,TYPFOO		;type test footage counts and CRLF
	PUSHJ P,MTAREL		;release input tape
	SETSTS MTA2,610		;clear error bits (supposedly already cleared)
TCPIKX:	MOVEI A,MCPIKX
	PUSHJ P,MASPIK		;record pickup point and state info
	;Must fix output tape position first, since FIXPOS uses input channel.
	PUSHJ P,MFIXO		;fix position of output tape
	TLO FL,IGNEOT		;ignore phys EOT for the moment
;	MOVE A,MEMSAV+MCOTAP	;get output tape number
;	MOVEM A,TAPNO		;indicate tape number in trailer
	PUSHJ P,TAPTAI		;write tape trailer
	TLZ FL,IGNEOT		;normal EOT treatment hereafter
IFN FTDBMC,<
printx For testing we don't unload completed output tape in TCOPY, just rewind it.
	PUSHJ P,MT2REW		;rewind output tape
>;IFN FTDBMC
IFE FTDBMC,<
	PUSHJ P,MT2UNL		;rewind and unload output tape
>;IFE FTDBMC
	PUSHJ P,MT2REL		;release output tape
TCPIKY:	MOVEI A,MCPIKY
	PUSHJ P,MASPIK		;record pickup point and state info
	PUSHJ P,SAVOUP		;save emergency copy of DART.MEM as OUTPUT.MEM
	SKIPE MASCOP		;skip unless master tape copy
	PUSHJ P,MFIXD		;fix position of output to DTAPES.DAT
	PUSHJ P,MFIXI		;fix position of input tape
	SKIPE MASCOP		;skip if not master copy
	JRST TCNXTO		;go request new output tape
;tell user to mount new output tape and type return, else type alt.
;	..
	OUTSTR [ASCIZ/%%% ..Unfinished tape copy code.. /]
	HALT .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ;tape copy -- error routines ; TCPARE TCPIEE TCPIRE TCPIRF

repeat 0,<
;Here if ARCWC is zero after backing it up after hitting physical end of tape.
TCPARE:	OUTSTR [ASCIZ/ Database pointer indicates that we just finished an
output tape with no data files on it!!  That can't be right.  Find a wizard.
/]
	HALT .
>;repeat 0

TCPIEE:	OUTSTR [ASCIZ/
%%% Supposedly no filenames recorded from this input tape (ARCWC is zero),
%%% but other data indicates some filenames were found.  Find a wizard!
/]
	HALT .			;should absolutely never happen

;Here if ARCWC is zero at logical end of tape.
;Make sure all the expected flags and counts are zero.
;Then ask operator if OK to go on.
;(If you continue from this, don't call MERGE0, because it doesn't seem to
;work with an empty DTAPES.DAT.  Nothing to merge anyway.)
TCPIRE:	SKIPN SPPN		;this better be zero, else we wrote a filename
	SKIPE MEMSAV+PTRSAV	;backup version of ARCWC should also be zero
	JRST TCPIEE		;oops, something is rotten
	SKIPN MEMSAV+MERGFL	;skip if already done merge!
	SKIPE MEMSAV+DTAOOO	;did any PPNs occur out of order in DTAPES.DAT?
	JRST TCPIEE		;yes, but we didn't write any!!
	CLOSE DSKMSC,		;close DTAPES.DAT
TCPIRF:	OUTSTR [ASCIZ/
%% Looks like we just finished an input tape with no disk files on it!!
%% Type GO<return> if you think that that's reasonable (also tell a wizard).
%% Otherwise you better find a wizard before continuing the copy. /]
	PUSHJ P,GETGO		;get response
	 JRST TCPIRF		;garbage typed
	 JRST TCPIKC		;GO typed, resume the copy, avoid merge
	JRST TCPIRF		;CR typed
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ;tape copy -- remember new pickup point ; STOIFN STOIF2 STOIER WIZGO

;Here when about to start writing data on a new output magtape file.
;Store input tape filename (or header/trailer info)
;since it will be the first file in an output magtape
;file and hence will be the file we want to back up input tape to for picking
;up the copy hereafter.  After this MT file is closed, this becomes the file
;to which the output tape will be backed up for pickups during the next MT file.
;The input tape file better also be the first file in an input magtape file.
STOIFN:	SKIPN MASCOP		;don't do this check unless master tape copy
	POPJ P,			;must be user copy
	MOVE A,MTFBEG		;this first file in input magtape file?
	CAIE A,1		;1 means first thing in MT file (AOS'd at MTAINP & TCOPFI)
	JRST STOIER		;no, something's wrong
	SKIPE A,MTFPPN		;remember the input tape filename
	JRST STOIF2
	MOVE A,MTFFIL		;bugtrap, avoid zero CUSER
	CAME A,['*HEAD*']	;unless we have a header or trailer
	CAMN A,['*TAIL*']
	TDZA A,A		;header or trailer is OK, restore zero
	JRST MASCU0		;bugtrap to catch zero CUSER early
STOIF2:	MOVEM A,MEMSAV+CUSER	;remember input filename for repositioning later
	MOVE A,MTFFIL
	MOVEM A,MEMSAV+CFILE
	MOVE A,MTFEXT
	MOVEM A,MEMSAV+CEXT
	PUSH P,B
	PUSH P,C
	PUSH P,D
	OUTSTR [ASCIZ/  Pickup filename: /]
	MOVE A,MEMSAV+CFILE
	MOVE B,MEMSAV+CEXT
	MOVE D,MEMSAV+CUSER
	PUSHJ P,OUTFIL		;print reasonable format filename
	OUTSTR [ASCIZ/  Dump set /]
	HRRZ A,MEMSAV+RELABS	;get dump set number
	PUSHJ P,DECOUT		;print it
	OUTSTR CRLF
	POP P,D
	POP P,C
	POP P,B
	MOVE A,MEMSAV+MTAFIL	;remember how many MT files come before this
	MOVEM A,MEMSAV+MTAFI2	;  input file, for repositioning input tape later
	SETZM MEMSAV+CUPRVH	;assume we're not changing a header/trailer
	SETZM MTFPPN		;enable above bugtrap in case don't read new
	SETZM MTFFIL		;  MT file before coming back here
	MOVE A,MEMSAV+MTEPOS	;get input tape position just after EOF
	MOVEM A,MEMSAV+MTOPOS	;save it in case we do a pickup from here
	MOVE A,MEMSAV+MTADFI	;get disk file count for input tape
	MOVEM A,MEMSAV+MTEDFI	;remember it in case of pickup
	MOVE A,MEMSAV+MTADFE	;get disk file error count for input tape
	MOVEM A,MEMSAV+MTEDFE	;remember it in case of pickup
	MOVEI A,MCPIK0		;pickup type 0
	JRST MASPIK		;write DART.MEM to remember state for pickup

;Pause to report an error.  Avoid trouble by not changing CUSER at this time.
;Don't pause -- this happens when beginning of input tape gets read errors.
;Has also been observed when changing output tapes in middle of input tape --
;perhaps because of read errors there too.
STOIER:	OUTSTR [ASCIZ/
%% First file going into output MT file is not first file in an input MT file.
/]
;;	PUSHJ P,WIZGO		;ask for wizard, but accept GO -- don't optimize
	POPJ P,

;Ask operator to find a wizard, or type GO.
;Messages printed before calling this should start with "%%" on each line.
;Clobbers only A.
WIZGO:	OUTSTR [ASCIZ/FIND A WIZARD--If you can't, report this error and then type GO<return>.  /]
	MOVNI A,1
	BEEP A,			;catch operator's attention
	PUSHJ P,GETGO
	 JRST WIZGO
	 POPJ P,		;said GO, according to directions
	JRST WIZGO
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ;tape copy -- store pickup code and write DART.MEM ; MASPIK MASPI0 MASPI1 MASPI2 MASPSE MASPIE MASCU0 CONFRM CONFR2

;Store pickup code in A and write DART.MEM (if master copy).
MASPIK:	MOVEM A,MEMSAV+CHKNUM	;remember pickup code
MASPI0:	MOVE A,ARCWC		;see if DTAPES.DAT is longer than before
	CAMLE A,MEMSAV+DTAMAX	;is this longest it's been?
	MOVEM A,MEMSAV+DTAMAX	;yes, remember, in case have to back up
	MOVE A,MEMSAV+CUSER	;bugtrap:
	CAME A,MEMSAV+FUSER	;  input and output pickup files shouldn't match
	JRST MASPI1		;OK, different files
	MOVE A,MEMSAV+CFILE
	CAME A,MEMSAV+FFILE
	JRST MASPI1		;OK
	HLLZ A,MEMSAV+CEXT
	XOR A,MEMSAV+FFEXT
	TLNE A,-1		;skip if extensions are same
	JRST MASPI1		;OK
	MOVE A,MEMSAV+CHKNUM	;filename are identical, better be new input tape
	CAIE A,MCPIKA		;skip if we're ready for new input tape
	CAIN A,MCPIKB		;skip unless we're ready for new input tape
	JRST MASPI1		;new input tape, OK for names to match
	CAIE A,MCPIKC		;skip unless we're ready for new input tape
	CAIN A,MCPIKD		;skip if we're ready for new input tape
	JRST MASPI1		;new input tape, OK for names to match
	JRST MASPSE		;bug!  same pickup filename for input & output

MASPI1:	SKIPE MEMSAV+CUSER	;bugtrap
	JRST MASPI2		;OK
	MOVE A,MEMSAV+CFILE	;avoid zero CUSER
	CAME A,['*HEAD*']	; unless this is header or trailer
	CAMN A,['*TAIL*']
	JRST MASPI2		;header or trailer is OK
	JRST MASPIE		;bug!  how can we reposition to a zero PPN?
MASPI2:	MOVE A,MEMSAV+MTAFIL	;remember how many input files seen when last saved
	MOVEM A,MTAFMM		;save count so can tell if need to write file again
	SKIPN MASCOP		;no state file unless master copy
	POPJ P,
	SKIPN THSTAP		;if we haven't seen a tape header,
	PUSHJ P,CONFRM		;  then ask operator to confirm the tape number
	PUSHJ P,SAVMEM		;write DART.MEM
	OUTSTR [ASCIZ/ | /]	;report that we wrote the MEM file out
	SETOM NOSAVM
	JRST MCLFRC		;force out log file buffer too

MASPSE:	AOSN NOSAVM		;suppress message till saved state once again
	SKIPN MASCOP		;no state file unless master copy
	POPJ P,
	OUTSTR [ASCIZ\
%% CUSER (etc.) = FUSER (etc.) at MASPIK; can't save state till this changes.
\]
;;	PUSHJ P,WIZGO		;ask for wizard, but accept GO -- don't optimize
	POPJ P,

MASPIE:	AOSN NOSAVM		;suppress message till saved state once again
	SKIPN MASCOP		;no state file unless master copy
	POPJ P,
	OUTSTR [ASCIZ/
%% CUSER is zero at MASPIK; can't save state till this changes.
/]
	PUSHJ P,WIZGO		;ask for wizard, but accept GO -- don't optimize
	POPJ P,

MASCU0:	SKIPN MASCOP		;no state file unless master copy
	POPJ P,
	OUTSTR [ASCIZ\
%% CUSER would have become zero at STOIFN (not header/trailer)--not changed.
\]
;;	PUSHJ P,WIZGO		;ask for wizard, but accept GO -- don't optimize
	POPJ P,

CONFRM:	OUTSTR [ASCIZ/
No Dart tape number found on INPUT tape, so please recheck INPUT tape number on
the tape's label and type it in (e.g., P1234 -- please be accurate!): /]
IFN STANSW!IRCPPN,<
	MOVNI A,1		;wake up operator
	BEEP A,
>;IFN STANSW!IRCPPN
IFE FTDBMC,< ;re-install this code before real tape copy
	CLRBFI			;clear typeahead
	PUSHJ P,GETANS		;get response
	 JRST CONFRM		;just CR typed, or something unexpected, like T nbr
	 CAIA
	JRST CONFRM		;typed GO, which we don't allow
	CAME B,PREQTP		;is this the right tape?
	JRST CONFR2
>;IFE FTDBMC
IFN FTDBMC,<
printx Confirmation is disabled during testing.
move b,preqtp  outstr crlf	;assume right tape, during testing
>;IFN FTDBMC
	MOVEM B,THSTAP		;don't need to confirm again, for this tape
	POPJ P,			;yes

CONFR2:	OUTSTR [ASCIZ/
!!! THAT'S THE WRONG TAPE !!!
Mount the right tape, start a new Dart and give the MCOPY command over again!/]
	EXIT 1,
	JRST CONFRM		;allow another chance to type right tape number
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ;tape copy -- process terms in command line ; TCOPTM TCOPT1 TCOPT0 TCOPT2 TCOP2A TCOPT3 TCOPT4 ILLMUL ILLMT2 ILLMTP

;Process source terms in command line for tape copy.
;Command line was already parsed into terms by SCAN.
TCOPTM:	HRRZ W,TBASE		;get the base of all terms
	CAME W,FSPTR		;are there any source terms at all?
	JRST TCOPT1		;yes.
	PUSHJ P,GETBLK		;get a term block
	MOVEI A,ALLFIL+ALLEXT+ALLPRG+ALLPRJ ;restore *.*[*,*]
	MOVEM A,FSEXT(R)	;store wild flags
TCOPT1:
	;Make omitted filename parts mean *.
	;Don't use DSK alias, since not using DSK.
	;First we do the output spec.
	MOVEI B,ALLPRG!ALLPRJ
	SKIPN RSTPPN		;skip if any output PPN given
	IORM B,RSTEXT		;use wild PPN
	MOVEI A,RSTNAM		;ptr to filename and ext/wild bits
	PUSHJ P,STWILD		;make omitted filename wild, and maybe ext too
	;Now make omitted parts of each term mean *.
	HRRZ W,TBASE		;get the base of all terms
TCOPT0:	MOVEI B,ALLPRG!ALLPRJ	;wild bits for project and programmer
	SKIPN FSPPN(W)		;skip if any output PPN given
	IORM B,FSEXT(W)		;use wild PPN
	MOVEI A,FSNAM(W)	;ptr to filename and ext/wild bits
	PUSHJ P,STWILD		;make omitted filename wild, and maybe ext too
	XCT R.NXT(K)		;point to next term
	XCT R.END(K)		;is this overrun yet?
	 JRST TCOPT0		;no. continue looking thru term blocks

	HRRZ W,TBASE		;get the base of all terms
	MOVE A,USRPPN		;initial sticky ppn
	MOVEM A,STKPPN		;save it
	SETZM STKBIT		;clear sticky bits for [*,*]
	MOVE A,FSDEV(W)		;look for a device
	MOVEM A,MTDEV		;dev name given in first term. save it.
	MOVE A,FSPTR
	MOVEM A,.JBFF		;make .jbff from free pointer.
TCOPT2:	SKIPN A,FSTAP(W)	;check for tape number
	JRST TCOP2A
	SKIPN GLOTAP		;got one, did we already have one?
	MOVEM A,GLOTAP		;store first tape number
	TDNE A,[TAPMSK,,-1]	;shouldn't be anything here but tape number
	JRST ILLSW2		;invalid number -- should never get here
	CAME A,GLOTAP		;make sure only tape number is used
	JRST ILLMTP		;multiple tape numbers, not all same
TCOP2A:	MOVEI A,FSNAM(W)	;ptr to filename and ext/wild bits
	PUSHJ P,STWILD		;make omitted filename wild, and maybe ext too
	MOVE B,FSEXT(W)		;get wild bits
	ANDI B,ALLPRJ+ALLPRG	;select only the ppn bits.
	SKIPN A,FSPPN(W)	;pickup any explicit ppn
	JUMPE B,TCOPT3		;jump if there is no explict bits
	MOVEM A,STKPPN		;save new sticky ppn
	MOVEM B,STKBIT		;save sticky bits
	JRST TCOPT4

TCOPT3:	MOVE A,STKPPN		;get sticky ppn
	MOVEM A,FSPPN(W)
	HRRZ B,STKBIT
	IORM B,FSEXT(W)		;save sticky bits here too

TCOPT4:	ADDI W,FSLEN		;increment w
	CAML W,FSPTR		;are we done?
	POPJ P,			;yes.
	SKIPE A,FSDEV(W)	;pickup device name
	CAMN A,MTDEV		;explicit device 
	JRST TCOPT2		;no device, or same device
ILLMUL:	OUTSTR [ASCIZ/Multiple source devices not permitted.
/]
	JRST RESTAR

ILLMT2:	CLRBFI
ILLMTP:	OUTSTR [ASCIZ/Multiple (input) tape numbers not permitted.
/]
	JRST RESTAR
                                                                                                                                                                                                                                                                                               ;tape copy -- misc. subroutine ; FS6250 US6250 INCDMP SWPJST LJUSTH LADJ PMTCLP GETECT GETEC0 GETEC2 GETEC3 GETEC4 GETTAB

;Here when about to read the first 6250-bpi P tape.
;Make sure the input tape device is a 6250 drive.
FS6250__=2747	;number of first P tape written at 6250 bpi
US6250:	OUTSTR [ASCIZ/
*** NEXT INPUT TAPE is the first P tape written at 6250 (on an MTUn drive). ***
/]
	MOVE A,MTDEV		;get input device name
	PNAME A,		;get physical name
	 MOVEI A,0		;huh? no such device!
	HLRZ A,A		;just left half, into right half for comparison
	CAIN A,'MTU'		;should be an MTU (6250-bpi) device
	POPJ P,			;OK, it is, so here we go
	OUTSTR [ASCIZ/
!!! But current input tape drive device cannot read 6250 tapes.

You should deassign (if necessary) the current input tape device and
assign the other MTUn tape drive as MTA1 for input of remaining tapes.
Then type CONTINUE (or restart the MCOPY)./]
	EXIT 1,
	JRST US6250		;see if operator followed instructions

;Increment relative and absolute dump nbrs.
;skip if it becomes too big for its field in DART.DAT.
INCDMP:	MOVE A,[1,,1]		;inc rel in LH and abs in RH
	ADDB A,MEMSAV+RELABS	;record a new relative dump number
	OUTSTR [ASCIZ/ (Encountered new dump set, #/]
	HRRZ A,A		;abs dump nbr
	PUSHJ P,DECOUT		;report abs dump number
	OUTSTR [ASCIZ/.) /]
	HLRZ A,MEMSAV+RELABS	;get new rel dump number
	CAILE A,RDMAX		;dump number within bounds?
	AOS (P)			;no -- simulate physical EOT to force new ouput tape
	POPJ P,

;swap LH and RH of DNX and TNX, left justifying each half, to make PPNCMP work.
SWPJST:	MOVS A,DNX		;swapping halves is easy
	PUSHJ P,LJUSTH		;left justify half words of A
	MOVEM A,DNX
	MOVS A,TNX		;swapping halves is easy
	PUSHJ P,LJUSTH		;left justify half words of A
	MOVEM A,TNX
	POPJ P,

;Left justify names in left and right halves of A.
LJUSTH:	HLLZ C,A		;get LH
	PUSHJ P,LADJ		;left justify LH
	HLL A,C			;save justified LH
	HRLZ C,A		;get RH
	PUSHJ P,LADJ		;left justify RH
	HLR A,C			;save justified RH
	POPJ P,

LADJ:	TLNE C,770000		;is it left adjusted yet?
	POPJ P,			;yes
	LSH C,6			;no. shove it some
	JUMPN C,LADJ		;loop.
	POPJ P,			;don't get stuck all day with zero

;Routine to get MTA error counts and record lossage/win counts
;from magtape DDB in system and store in MEMSAV block.
PMTCLP__360	;lowcore location of offset of error counts within MTA DDB
GETECT:	POPJ P,			;do nothing now tha 7-track tapes are finished!
	;Old code to grab counts for MTA DDB.
	MOVEI A,PMTCLP		;lowcore location
	PEEK A,			;get offset of error counts in MT DDB
	PUSH P,A		;save -MTREDO,,MTCLPE from lowcore
	ADD A,.JBJDA+MTA	;add in DDB address for input magtape
	HRLI A,-NMECNT		;number of error counts to pick up
	MOVEI C,MEMSAV+MTCLPE	;place to start storing error counts
	PUSHJ P,GETTAB		;copy table from system
	HRRZ A,.JBJDA+MTA	;get in DDB address for input magtape
	ADDI A,MTLOS2		;add offset from MTCLPE to MTLOSE
	ADDB A,(P)		;make ptr to MTLOSE word
	JUMPGE A,GETEC5		;jump if no win/lose counts in DDB
GETEC0:	PEEK A,			;get lossage count for this magtape drive
	MOVEM A,MEMSAV+MTLOSE	;save it
	AOS A,(P)		;make aobjn ptr to MTWIN, which follows MTLOSE
	CAMGE A,[-MTREDO,,0]	;make sure system's table no bigger than ours
	HRLI A,-MTREDO		;system's is bigger, limit to our size
	MOVEI C,MEMSAV+MTWIN	;place to start saving copy of win table
	PUSHJ P,GETTAB		;copy table from system
	POP P,B			;get back -size of system table in LH
	HLRE B,B		;make full word of -size
	ADDI B,MTREDO		;adjust by our size
	JUMPE B,CPOPJ		;jump if same size
	JUMPL B,GETEC3		;jump if system size if bigger (combine)
	;our table is bigger than system's by (B)
	MOVN B,B		;negative difference
	HRLI C,(B)		;make aobjn to remainder of our table
GETEC2:	SETZM (C)		;clear rest of our table
	AOBJN C,GETEC2
	POPJ P,

;System table is bigger than ours.
;Add rest of system table to our last entry.
GETEC3:	HRL A,B			;aobjn with number of extra system entries
GETEC4:	MOVEI B,(A)		;just 18-bit address
	PEEK B,			;get error count
	ADDM B,-1(C)		;add into our last table entry (C was inc'd at end)
	AOBJN A,GETEC4		;loop through rest of system table
	POPJ P,

;Here if system doesn't have MT win/lose counts in DDB.
GETEC5:	OUTSTR [ASCIZ\? No MT DDB win/lose counts pointed to by low core.
\]
	HALT .

;Copy table from system.
;Call with A/aobjn ptr to system table, C/ptr to place to store table.
;Clobbers B.
GETTAB:	MOVEI B,(A)		;just 18-bit address
	PEEK B,			;get error count
	MOVEM B,(C)		;save error count
	ADDI C,1		;next save location
	AOBJN A,GETTAB		;loop through system table
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                           ;tape copy -- adjust slice level ; MTCBKN MTCNS3 MTLOS2 SLIWIN SLIINI SLRMIN SLICHK TOGSLI TOGSLC

;Routine to test MTA slice-correction wins and count of records from system.
;Direct return if current slice level seems to be winner.
;Skip return if we should toggle slice level to improve reads.
;A "slice-correction win" counts a read error on first try and a read success
;on the second try by the system, which always toggles slice level on retries.
;Clobbers A and B.
MTCBKN__5	;offset of record-count cell from MTCLPE cell (CACDAT).
MTCNS3__12	;offset of slice-correction win count from MTCLPE cell (CACDAT).
MTLOS2__15	;offset of table of cnts: losses & successful reads by retry count
SLIWIN:	SETZM NREADS		;don't check slice wins now till we've read a lot
	MOVEI A,PMTCLP		;lowcore location
	PEEK A,			;get offset of error counts in MT DDB
	ADD A,.JBJDA+MTA	;add in DDB address for input magtape
	MOVEI B,(A)		;copy ptr to MTCLPE
	ADDI A,MTCBKN		;make pointer to record-count cell
	PEEK A,
	SUB A,SAVBKN		;calculate increment in record count
	ADDI B,MTCNS3		;make ptr to slice-correction win count
	PEEK B,
	SUB B,SAVNS3		;calculate increment in slice win count
	ADDM A,SAVBKN		;update saved record count
	ADDM B,SAVNS3		;update saved slice-correction win count
	SUB A,B			;remainder of records that didn't get slice-corr win
	CAMGE A,B		;if remainder is smaller than correction wins,
	AOS (P)			;  extra skip return means slice change may help
	POPJ P,			;  else no use changing slice

;Initialize saved counts of tape records read and slice-correction wins.
;Clobbers A and B.
SLIINI:	MOVEI A,0		;shortest possible sleep
	SLEEP A,		;make sure JOBJDA is set up with DDB address
	PUSHJ P,SLIWIN		;get record and slice-correction win counts
	 POPJ P,		;slice level OK
	POPJ P,			;says we should change slice, but only starting

SLRMIN__=70	;minimum number of records read before we consider slice change

;Maybe toggle the slice level if that would appear to read better on first try.
;Here from TCOPFI before reading each file during tape copy.
;Clobbers A and B.
SLICHK:	MOVE A,NREADS		;get number of new records read by MTAINP
	CAILE A,SLRMIN		;don't check unless have read this much recently
jfcl;	PUSHJ P,SLIWIN		;see if we should toggle slice level
	 POPJ P,		;slice level looks OK or too soon to check
	OUTSTR [ASCIZ /
TRYING ALTERNATE SLICE LEVEL: /]
	JRST TOGSLC		;toggle the tape slice level

;Here from TREAD1 after operator said ESC 9 I to toggle input tape slice level.
TOGSLI:	PUSHJ P,SLIINI		;re-init our counts of records
;Enter here when SLICHK wants to change slice level automatically.
TOGSLC:	SETCMB A,SLILVL		;complement slice level, pick up result
	TLNN A,1		;skip if want slice level set to 1
	SLICE0 MTA,		;set slice to 0
	TLNE A,1		;skip if want slice level set to 0
	SLICE1 MTA,		;set slice to 1
	SETZM TSLICE		;we carried out the request
	HRRI A,[ASCIZ/1 (old tapes). /]
	TLNN A,1
	HRRI A,[ASCIZ/0 (new tapes). /]
;	OUTSTR [ASCIZ/ Slice level set to /]
;	OUTSTR (A)
	POPJ P,
                                                                                                                           ;tape copy -- re-position output tape ; MFIXO

;Fix position of output tape.  Leaves output tape device open.
;Note: FIXPOS releases the output tape and re-inits it later from MTDEV.
;Also: FIXPOS reads the output tape on the INPUT tape channel, hence
;the input tape must be released before getting here.
MFIXO:	SETZM MBUFLG		;let MTINIR in FIXPOS use compiled-in buffers.
	PUSH P,TSLICE		;save change-slice flag
	PUSH P,MTDEV		;save input device
	MOVE A,RSTDEV		;output device is one to be repositioned
	MOVEM A,MTDEV		;set output device to reopen in FIXPOS below
	OUTSTR [ASCIZ/
OUTPUT tape.../]
	PUSH P,MEMSAV+MTAFIL	;save input tape info while reading output tape
	PUSH P,MEMSAV+MTAFI2
;	PUSH P,MEMSAV+MTQPOS
	PUSH P,MEMSAV+MTAPOS
	PUSH P,MEMSAV+MTIDAT
;Here we make sure at compile time that the PRVMTM bit, which was added to the
;RHDATE word, is looked for in the right word by FIXPOS, namely the ext word.
IFN <RHDATE-RHDCOP-<WCWD+DVWD+DDEXT>>,<.FATAL RHDATE doesn't parallel (FF)EXT word>
	MOVSI A,PRVMTM		;maybe output tape had this bit added
	SKIPE MEMSAV+FUPRVH	;skip if no bit added
	IORM A,MEMSAV+FFEXT	;turn on the expected bit
	MOVE A,MEMSAV+REEABE	;get saved rel and absolute dump numbers
	MOVEM A,MEMSAV+RELABS	;restore them
	SETZM TSLICE		;don't mess up input slice counters with output tape
	PUSHJ P,FIXPOS		;position ourselves at beginning of good MT file
	;The output tape is now open, using MBUF1,2,3.
	POP P,MEMSAV+MTIDAT	;restore input tape info
	POP P,MEMSAV+MTAPOS
;	POP P,MEMSAV+MTQPOS
	POP P,MEMSAV+MTAFI2
	POP P,MEMSAV+MTAFIL
	POP P,MTDEV		;restore input device
	POP P,TSLICE
IFN DBGSW,<
	SKIPN DBGNTP		;avoid tape ops if debugging without tape
>;IFN DBGSW
	PUSHJ P,MT2SKF		;skip forward over last good magtape file output
	SOS MEMSAV+MT2FIL	;correct output tape file count (OK before MT2SKF)
	MOVE A,MEMSAV+MTFPOS	;restore output tape position after EOF
	MOVEM A,MEMSAV+MT2POS	;this is where we last wrote an EOF
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ;tape copy -- re-position input tape ; MFIXIB MFIXI MFIXI2 MFIXIE

;Get brand of input tape, then fix input tape position
MFIXIB:	PUSHJ P,GBRAND		;ask operator for brand and model of input tape
;Fix position of input tape.  Leaves input tape device open.
MFIXI:	SKIPE A,MEMSAV+CUSER	;set up file for FIXP00 to look for
	JRST MFIXI2
	MOVE A,MEMSAV+CFILE	;bugtrap, avoid zero CUSER
	CAME A,['*HEAD*']	;unless we have a header or trailer
	CAMN A,['*TAIL*']
	TDZA A,A		;header or trailer is OK, restore zero
	PUSHJ P,MFIXIE		;bugtrap to catch zero CUSER
MFIXI2:	PUSH P,MEMSAV+FUSER	;save output tape pickup filename
	PUSH P,MEMSAV+FFILE
	PUSH P,MEMSAV+FFEXT
	MOVEM A,MEMSAV+FUSER	;file we started copying in new output MT file
	MOVE A,MEMSAV+CFILE
	MOVEM A,MEMSAV+FFILE
	HLLZ A,MEMSAV+CEXT
	MOVEM A,MEMSAV+FFEXT
	OUTSTR [ASCIZ/
INPUT tape.../]
	MOVE A,MEMSAV+MTAFIL	;total MT files on input tape, minus MT files at
	SUB A,MEMSAV+MTAFI2	; last output EOF is nbr of input MT files to backup
	SKIPGE A		;safety check, count shouldn't be negative
	MOVEI A,0		;fix errant offset count
	ADDI A,3		;backup extra to ensure right place (1 at least)
	MOVE B,MEMSAV+MTAFI2	;nbr of input tape MT files BEFORE reposition point
	ADDI B,1		;count reposition MT file as well
	PUSHJ P,FIXP00		;reposition input tape (leaves tape released)
	MOVE A,MEMSAV+MTAFI2	;restore count of MT files on input tape to here
	MOVEM A,MEMSAV+MTAFIL	; as total number of MT files on input tape
	MOVE A,MEMSAV+MTOPOS	;restore input tape's old position
	MOVEM A,MEMSAV+MTAPOS	; to place where we repositioned it
	MOVE A,MEMSAV+MTEDFI	;get disk file count for input tape
	MOVEM A,MEMSAV+MTADFI	;restore saved disk file count for input tape
;	SUB A,MEMSAV+MTADFI	;figure how much we're backing it up
;	ADDM A,MEMSAV+MTADFI	;back up input tape's disk file count
;	ADDM A,MEMSAV+MCODFI	;back up master copy's disk file count
	MOVE A,MEMSAV+MTEDFE	;get disk file error count for input tape
	MOVEM A,MEMSAV+MTADFE	;restore disk file error count for input tape
;	SUB A,MEMSAV+MTADFE	;figure how much we're backing it up
;	ADDM A,MEMSAV+MTADFE	;back up input tape's bad file count
;	ADDM A,MEMSAV+MCODFE	;back up master copy's bad file count
	SETZM MEMSAV+MTQPOS	;input tape position isn't questionable, I guess
	SETOM MTFBEG		;we're at beginning of input magtape file
	SETOM MBUFLG		;make MTINIR/W use two sets of buffers optimally
	PUSHJ P,MCREIN		;re-open input tape device (released by FIXP00)
	POP P,MEMSAV+FFEXT
	POP P,MEMSAV+FFILE
	POP P,MEMSAV+FUSER	;restore output tape pickup filename
	MOVE A,MEMSAV+MCITAP	;get input tape number
	SKIPN THSTAP		;make sure this is nonzero, to avoid safety check
	MOVEM A,THSTAP		;  at MASPIK (tape must be right, we positioned it)
	PUSHJ P,MASPI0		;save new MTAFIL count, since tape is positioned
	POPJ P,			; (avoids backing up a lot again since already done)

MFIXIE:	OUTSTR [ASCIZ\
%%% CUSER is zero at MFIXI (not header/trailer); won't be able to position tape!!
%%% Find a wizard.
\]
	HALT .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ;tape copy -- compare file found with terms given ; TCOPMT TCOPM0 TCOPM1 TCOPM2 TCOPM3 TCOPM4 TCOPM5 TCOPM6 TCOPUF

;Skip unless file in FILINF matches a term.
TCOPMT:	MOVE W,TBASE		;get the base of term block.
TCOPM0:	HRRZ X,FSEXT(W)		;get flags
	TRNE X,ALLFIL		;any file?
	JRST TCOPM1		;yes. skip match
	MOVE Y,FSNAM(W)		;get the name
	CAME Y,FILINF+DDNAM	;same as magtape name?
	JRST TCOPM6		;no. no match with this term.
TCOPM1:	TRNE X,ALLEXT		;wild extension?
	JRST TCOPM2		;yes.
	HLLZ Y,FSEXT(W)		;get ext from this term
	HLLZ Z,FILINF+DDEXT	;get ext from mt
	CAME Y,Z		;same as mag tape extension?
	JRST TCOPM6		;no match
TCOPM2:	TRNE X,ALLPRJ		;any project?
	JRST TCOPM3		;yes.
	HLLZ Y,FSPPN(W)		;get project name
	HLLZ Z,FILINF+DDPPN	;get mt project name
	CAME Y,Z
	JRST TCOPM6		;lose
TCOPM3:	TRNE X,ALLPRG		;any programmer
	JRST TCOPM4		;yes. win.
	HRRZ Y,FSPPN(W)
	HRRZ Z,FILINF+DDPPN
	CAME Y,Z
	JRST TCOPM6		;no match
;Here with a match
TCOPM4:	TRNE X,ALLMSK		;skip if there is no wildness.
	JRST TCOPM5		;wild term. do not flush term.
	MOVNI X,FSLEN		;load - length of block.
	ADDB X,FSPTR		;shrink term block storage
	MOVSI Z,(X)		;source of blt
	HRRI Z,(W)		;destination
	BLT Z,FSLEN-1(W)	;blt last term down onto this one.
TCOPM5:	HRRZ X,@R.EXT(K)	;get the wild flags into x from restore side
	JRST CPOPJ2		;take success return

;Here if current term doesn't match current file.  Any more terms?
TCOPM6:	XCT R.NXT(K)		;point to next term
	XCT R.END(K)		;is this overrun yet?
	 JRST TCOPM0		;no. continue looking thru term blocks
;Here if no term matches current file.
	PUSHJ P,RDFILX		;flush through the end of this file
	TRNE FL,MTAEOT		;skip unless logical eot
	JRST CPOPJ1		;need new tape, I guess
	POPJ P,			;look for another file on the tape

;Here for user mode copy, to set up output filename.
TCOPUF:	TRNN X,ALLFIL		;is restore file name wild?
	MOVE A,@R.NAM(K)	;not wild we take this name.
	TRNN X,ALLEXT		;is restore extension wild?
	HLL B,@R.EXT(K)		;not wild, take this extension.  date75
	TRNN X,ALLPRJ		;is project wild?
	HLL D,@R.PPN(K)		;no. slurp this up.
	TRNN X,ALLPRG		;is programmer wild?
	HRR D,@R.PPN(K)		;no. slurp it up.
	MOVEM A,FILINF+DDNAM	;save output filename (in case diff from input)
	HLLM B,FILINF+DDEXT	; and extension
	MOVEM D,FILINF+DDPPN	; and PPN
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ;tape copy -- pickup-point definitions and documentation ; NOITAP NOIFIX NOOTAP NOOFIX NODTAP MCPIK$code MCPIK MCPIKT

;Left-half bits in MCPIK table below.
NOITAP__1	;don't need to pre-mount an input tape (time for new input tape)
NOIFIX__2	;don't need to position input tape (done later)--release input tape
NOOTAP__4	;don't need to pre-mount an output tape (time for new output tape)
NOOFIX__10	;don't need to position output tape (will be done later, NOIFIX required)
NODTAP__20	;don't need to position output to DTAPES.DAT

;Pickup table for master tape copy.
;(These pickup codes are unrelated to those for normal P/T dumps.)
;Index into table with checkpoint number (pickup code).
;Right half of entry is dispatch address, left half holds various bits.
;The macro below defines offsets MCPIK0,MCPIK1,... with values 0,1,....
;It references addresses where pickups resume, with names TCPIK0, TCPIK1,....

DEFINE ALLPIK <
PK(0,0,<Middle of both input and output tapes, need reposition both.>)
PK(A,NOITAP,<End of Input tape (rewound), about to finish DTAPES data file.>)
PK(B,NODTAP!NOITAP,<End of Input tape (rewound), about to merge closed data file.>)
PK(C,NODTAP!NOITAP,<End of Input tape (rewound), merge done, about to ask for new tape.>)
PK(D,NODTAP!NOITAP,<End of Input tape, merge & verify done, about to ask for new tape.>)
PK(X,NOIFIX!NOOFIX,<End of Output tape, about to write tape trailer.>)
PK(Y,NOIFIX!NOOTAP,<End of Output tape (rewound), about to ask for new tape.>)
PK(S,NODTAP!NOITAP!NOOTAP,<?? BEGINNING of MCOPY, unexpected state!>) ;must be last
>;ALLPIK
; S is not a pickup point, but actual start of master copy.
; S must be last code, used for range check.

;Define an MCOPY pickup state table entry and corresponding code.
DEFINE PK $ (code,bits,text)<
MCPIK$code__.-MCPIK		;define offset with name like MCPIK1
	bits,,TCPIK$code	;dispatch to address like TCPIK1
>;PK
;Table of bits,,dispatch address for the various MCOPY pickup codes.
MCPIK:	ALLPIK

;Define pointer to text describing pickup state.
DEFINE PK $ (code,bits,text)<
[ASCIZ/text/]
>;PK
;Table parallel to MCPIK table -- pointers to text explaining each pickup state.
MCPIKT:	ALLPIK

Comment 

Here's the order MCOPGO does things, and the bits that suppress them:
MCIMNT(NOITAP)
MCOMNT(NOOTAP)
MFIXO(NOOTAP,NOOFIX)
MFIXI(NOITAP,NOIFIX)
MFIXD(NODTAP)
So here's what the various pickup types do, in order
(in MCOPGO::after MCOPGO at TCPIKx):

0 -- MCIMNT,MCOMNT,MFIXO,MFIXI,MFIXD::--
A -- MCOMNT,MFIXO,MFIXD::MCIMNT
B -- MCOMNT,MFIXO::MERGE0,MCIMNT
C -- MCOMNT,MFIXO::MCIMNT
D -- MCOMNT,MFIXO::MCIMNT
X -- MCIMNT,MCOMNT,MFIXD::MFIXO,MT2REL,MFIXI,MCOMNT
Y -- MCIMNT,MFIXD::MFIXI,MCOMNT
S -- ::MCIMNT,MCOMNT

And here's what happens at end of output and input tapes, respectively:

TCPEOT -- MTAREL,MFIXO,TAPTAI,MT2REL,MFIXD,MFIXI,MCOMNT
MCLEOT -- MTAREL,MFIXD,MERGE0,MCIMNT

MCOPY does a SETOM MBUFLG to default to having output buffers in compiled-in
area and input buffers in additional core.

MFIXO wants to use the compiled-in buffers to reposition the tape (reading
the tape with the "output" area buffers), so it does a SETZM MBUFLG before
FIXPOS is called.  If the compiled-in buffers are free (should be), they
will also be used for the output channel that MFIXO/FIXPOS leaves open.

MFIXI, on the other hand, wants to leave the compiled-in buffers for
output, so it does a SETOM MBUFLG before calling MCREIN (which re-inits
the input channel).  That makes MCREIN and MTINIR use additional buffers
for the input channel.

MEMSAV+FUSER (etc.) is used to reposition output tape.
MEMSAV+CUSER (etc.) is used to reposition input tape.

STOIFN copies MTFPPN to CUSER (etc.).
NEWMTF copies CUSER  to FUSER (etc.).


Normal state of output tape:

BOT    EOF	EOF	EOF	EOF		phys EOT
+------+--------+--   --+-------+-----------------+
|HEADER|	|  ...	|	|                 |
+------+--------+--   --+-------+-----------------+
			 ^	 ^
			FUSER	CUSER

end of comment 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ;tape copy -- copy input tape file to output tape ; TCDUMP TCDU2 TCDU0 TCDU1 TCDU4 TCXTAB TCDUX0 TCDUX1 TCDUX2 TCDUX3 TCDUXX TCDUXY TCDUME FAKERR TCOPI0 TCOPI1 TCOPI2 TCOPI3 TCOPIN TCOPS0 TCOPS4 TCIADJ

;;  FILINF: BLOCK LLEAD3 ;set up with retrieval information and rest of leader
;;  WC:     BLOCK 1      ;set with word count available in current output record
;;  FSIZE:  0            ;will be set to word count of file

;; Copy input tape file to output tape.
;; Will skip return unless physical end of tape is found.
TCDUMP:	SETOM FSTRT		;indicate ready for file-start record on output
	MOVE A,SRCTST+LEDONE	;check test word of all ones
	PUSHJ P,TSTONE		;test word for all ones
	SKIPE A,SRCTST+LEDZER	;check test word of all zeroes
	PUSHJ P,TSTZER		;test word for all zeroes
	MOVM A,FILINF+DDLNG	;get the file word count.
	MOVEM A,FSIZE		;initialize remaining output file size in words
	PUSHJ P,DBLO10		;log wd cnt word in circular buffer for debugging
	MOVEM A,IFSIZE		;initialize remaining input file size in words
	MOVE A,IWC		;get input word count
	PUSHJ P,TCIADJ		;adjust input counts past this input block
	AOS IWC			;we haven't picked up a word yet, so fix counter
	MOVE A,WC		;get remaining word count left in output record
	CAILE A,200+WCWD+LLEAD3+LMEDER+CKWD ;enough left to make it worth it?
	JRST TCDU0		;yes. continue on this tape record
;Loop here for each output block, start a new output buffer.
TCDU2:	SETZM TOBUF+2		;zero output buffer count to force new buffer
	MOVE A,WRCSZ		;re-init output word count to full buffer amount
	MOVEM A,WC		;output buffer is empty so far
TCDU0:	SUBI A,WCWD+LLEAD3+LMEDER+CKWD ;file data space is room minus overhead words
	MOVE B,FSIZE		;remaining amount of output file to do
	CAILE B,(A)		;skip if it all fits in current output buffer
	MOVEI B,(A)		;too big, write only amount that fits in buffer
	MOVNM B,FWC		;save neg wd cnt of file words in this record
	AOSE FSTRT		;skip if doing file start block
	TDZA A,A		;doing file continuation, zero the LH of wd ct wd
	MOVSI A,-IOVER		;negative ioversion number
	HRRI A,LLEAD3+LMEDER(B)	;set up wd ct=leader+media error data+file data
;* NEXT CALL MAY FAIL
	PUSHJ P,TWRITE		;write word count word (file-start or continuation)
	 POPJ P,		;return with error (phys end of tape)
	MOVNI B,WCWD+LLEAD3+LMEDER+CKWD(B) ;will write wc+leader+media+checksum+FILE
	ADDM B,WC		;reduce output buffer space left after this block
	ADDM B,TOBUF+2		;decrement the output buffer count too
	MOVE A,SRCDEV		;get the device name
	MOVE C,A		;initialize checksum
	IDPB A,TOBUF+1		;write device name on tape
IFN IRCPPN,<
	MOVE B,FILINF+DDPPN	;turn ircam ppn into sail ppn
	TLNE B,770000		;for transportability
	TLO B,400000
	TRNE B,770000
	TRO B,400000
	MOVEM B,FILINF+DDPPN
>;IFN IRCPPN
	MOVSI B,-INFOSI		;make aobjn pointer for leader
TCDU1:	MOVE A,FILINF(B)	;get a leader word
	XOR C,A			;adjust the checksum
	IDPB A,TOBUF+1
	AOBJN B,TCDU1		;loop through leader
IFN IRCPPN,<
	MOVE B,[400000,,400000]	;put back ircam ppn
	ANDCAM B,FILINF+DDPPN	;in case anyone cares
>;IFN IRCPPN
	SKIPLE FSTRT		;skip if doing file-start block
	SKIPA B,['CON',,IOVER]	;indicate continuation block
	MOVE B,['*FILE*']	;indicate file-start block
	PUSHJ P,WRXINF		;insert extra leader info into output buffer
	SKIPLE TIBUF+2		;make sure we won't overrun the input buffer
	JRST TCDU4		;won't run out of input data early
	PUSHJ P,SHRTBF		;oops, not enough input data to satisfy wd cnt
	OUTSTR [ASCIZ/  Will replace missing data in above file with zeroes.
/] 	;buffer has zeroes	;we'll no doubt also get a resultant checksum error
TCDU4:	MOVE B,FWC		;get neg data word cnt for current tape output record
	ADDM B,FSIZE		;reduce amt of output file left for later
	MOVE A,B		;copy of output wc for debugging
	PUSHJ P,DBLO11		;log wd cnt word in circular buffer for debugging
	MOVEI X,3		;we use open code below for 4 words at a time
	AND X,B			;pickup 2 bits from B (remainder mod -4)
	ASH B,-2		;make cnt of neg multiples of 4 words
	MOVE D,TOBUF+1		;pickup byte pointer
	TLZE D,770000		;zero the byte position
	SUBI D,1		;oops, was a 444400
	SUBI D,(X)		;backup ptr to prev 4-word boundary
	JUMPE B,TCDUXX		;if B is zero, write checksum only (data finished)
	JRST @TCXTAB(X)		;and jump wildly into the open code

TCXTAB:	TCDUX0
	TCDUX1
	TCDUX2
	TCDUX3

TCDUX0:	SOSGE IWC		;is there data in buffer?
	PUSHJ P,TCOPI0		;get another input block
	ILDB A,TIBUF+1		;load a word from the file
	XORM A,CHKSUM		;update input checksum
	XOR C,A			;save output checksum
	MOVEM A,1(D)		;put word into output buffer
TCDUX1:	SOSGE IWC		;is there data in buffer?
	PUSHJ P,TCOPI1		;get another input block
	ILDB A,TIBUF+1		;load a byte from the file
	XORM A,CHKSUM		;update input checksum
	XOR C,A			;save checksum
	MOVEM A,2(D)		;save word
TCDUX2:	SOSGE IWC		;is there data in buffer?
	PUSHJ P,TCOPI2		;get another input block
	ILDB A,TIBUF+1		;load a byte from the file
	XORM A,CHKSUM		;update input checksum
	XOR C,A			;save checksum
	MOVEM A,3(D)		;save byte
TCDUX3:	SOSGE IWC		;is there data in buffer?
	PUSHJ P,TCOPI3		;get another input block
	ILDB A,TIBUF+1		;load a byte from the file
	XORM A,CHKSUM		;update input checksum
	XOR C,A			;save checksum
	MOVEM A,4(D)		;save byte
	ADDI D,4
	AOJL B,TCDUX0		;loop reading/writing until output block finished
	;Here when all the file data has been collected for current output block.
TCDUXX:	PUSHJ P,ICKSU0		;maybe check input tape checksum & prev media errors
TCDUXY:	MOVSI B,-LMEDER		;aobjn ptr to previous media error table
TCDUME:	MOVE A,MEDERR(B)	;get previous media error datum
	XCT MRGERR(B)		;combine new media errors with prev media errors
	IDPB A,D		;output combined error datum from MEDERR and REDERR
	XOR C,A			;adjust checksum
	AOBJN B,TCDUME		;loop through table
	IDPB C,D		;write the checksum into the buffer
	MOVEM D,TOBUF+1		;points to last byte deposited
	SKIPLE FSIZE		;remaining part of output file
	JRST TCDU2		;loop back for more of this file
	SKIPN TAPERR-REDERR+MEDERR ;skip if any previous media errors
	SKIPE TAPERR		;skip if no errors in this file
	PUSHJ P,CKPAUS		;make sure user knows of errors
	JRST CPOPJ1		;end of this file

;This constant is XOR'd with checksum to cause a checksum error that
;indicates a previous media error occurred when a copy was being done.
;In that case, the next tape block should indicate the previous media errors.
FAKERR:	123456,,352041		;special constant to flag previous media error

;Here when input block runs out in middle of output block for file being copied.
;Check input checksum and get another input block.
;Must preserve B,C,D.
TCOPI0:	JSP A,TCOPIN
TCOPI1:	JSP A,TCOPIN
TCOPI2:	JSP A,TCOPIN
TCOPI3:	JSP A,TCOPIN
TCOPIN:	MOVEI A,-TCOPI0(A)	;make number from 1 to 4 -- index of caller in loop
	HRLM A,(P)		;save it in case needed for error recovery
	AOSN IWC		;skip checksum if checked at end of output blk
	PUSHJ P,ICKSUM		;check input tape checksum and prev media errors
TCOPS0:	PUSHJ P,TREADY		;read the WC from next record
	TRNE FL,MTAEOT		;skip unless hit premature logical EOT
	JRST TCOPIE		;already told user, just truncate the file
	TLNE A,-1		;skip if supposedly a file-continuation record
	JRST TCOPSS		;not a file-continuation record!
	JUMPE A,TCOPS6		;zero is a bad word count always
TCOPS4:	PUSHJ P,IWCCHK		;check validity of the input word count in A
	 JRST TCOPS0		;no room in buffer for any data!  read new buffer
	 PUSHJ P,BADIWC		;XCT'd: not a valid word-count word, try to recover
TCIADJ:	SUB A,PSTDAT		;reduce count by size of any trailer info
	pushj p,iwcdbg		;make sure RH A isn't negative or otherwise bad
	MOVEM A,IWC		;store new input block word count
	PUSHJ P,DBLOGA		;log wd cnt word in circular buffer for debugging
	SOS IWC			;count down for word we're about to pick up
	MOVN A,A		;get - word count
	ADDM A,TIBUF+2		;count down the buffer count
	SOS TIBUF+2		;count down for checksum word
	ADDM A,IFSIZE		;update remaining input file size
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ;tape copy -- errors during copy of tape file ; TCOPSS TCOPS5 TCOPS3 TCOPS2 TCOPS6 TCOPIE

;Here if don't have the expected file-continuation block.  See what we have.
TCOPSS:	PUSH P,B
	PUSHJ P,FMTCH0		;check format of word we found
	 JRST TCOPS2		;bad format, assume clobbered data from file
	 JFCL			;marginal file cont block, can't happen here
	 JFCL			;file-continuation, can't happen here
	 JFCL			;file start block with too-short buffer
;This WC word looks OK, but it isn't what we expected, so we'll truncate
;current output file at end of current output buffer.
	PUSHJ P,RFDT2S		;report file appearing too short, backup input ptr
	POP P,B
TCOPS5:	POP P,A			;we're not going to return, but need caller's index
	HLRZ A,A		;get index of place we came from (1 to 4)
	JRST TCOPS3-1(A)	;jump into loop to zero rest of output block
TCOPS3:	SETZM 1(D)		;clear rest of output block
	SETZM 2(D)		;clear rest of block
	SETZM 3(D)		;clear rest of block
	SETZM 4(D)		;clear rest of block
	ADDI D,4
	AOJL B,TCOPS3		;loop clearing
	SETZM FSIZE		;truncate the output file unceremoniously
	PUSHJ P,DBLO12		;log passing through here
	JRST TCDUXY		;now finish off the file

;Here if first word of new block is garbage -- assume it is data, not word count.
TCOPS2:	POP P,B
TCOPS6:	MOVSI A,300000		;force a bad-word-count error with huge "word count"
	JRST TCOPS4

;Here with logical EOT in the middle of a file being copied.
;Fill in remainder of input file with zeroes by setting the input
;byte pointer to zero and setting the input count as needed.
TCOPIE:	PUSHJ P,MTABKF		;backspace over the first EOF mark to see EOT again
	JRST TCOPS5		;truncate file at end of current output buffer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ;tape copy -- check checksum, handle previous media error data ; ICKSU0 ICKSU1 ICKSUM ICKSU2 ICKBAD ICKBA2 ICKICK SERDAT SERDAL SERDA2

;Here from TCDUXX when output block has been filled up in tape copy.
;Check input checksum (and media errors) if input block is used up.
;Must preserve C and D.
ICKSU0:	SKIPG FSIZE		;skip unless output (and hence input) file done
	SKIPG IWC		;make sure we're really at end of input block
	CAIA
	JRST ICKICK		;output file ended but not the input file!!
	SKIPN IWC		;skip if haven't reached trailer/checksum
	PUSHJ P,ICKSU1		;process trailer and check input checksum
	SKIPG FSIZE		;have we finished output file now?
	SKIPN TAPERR-REDERR+MEDERR ;yes, skip if any previous media errors
	POPJ P,			;haven't finished output or no errors
	PUSH P,C		;preserve new checksum
	PUSHJ P,TYPMER		;type out prev media error data
	POP P,C			;restore new checksum
	POPJ P,

;check input tape checksum at end of data block, after reading prev media errors.
;here only from TCOPIN and from ICKSU0 above.
ICKSU1:	SOS IWC			;make sure we don't check checksum at TCOPIN.
ICKSUM:	PUSHJ P,SERDAT		;save any previous media error data at end of block
ICKSU2:	ILDB A,TIBUF+1		;get input block checksum
	XORB A,CHKSUM		;check the checksum
	JUMPE A,CPOPJ		;jump if checksum OK
IFN FTDBMC,<
; popj p,  printx We're ignoring checksum errors for now.
>;IFN FTDBMC
ICKBAD:	SKIPN RECERR		;skip if we saw an MT read error in this record
	AOS MEMSAV+CHKSUE	;cnt a checksum error on this tape, w/o read error
	PUSH P,B
	IORM A,CHEIOR		;remember bits that failed
	MOVEI B,[ASCIZ/ Checksum failure, bits = /]
	SKIPG NRETRY		;skip if we're retrying
;	JRST [	MOVEI B,[ASCIZ/ Cksum? /]
;		PUSHJ P,STROUT
;		JRST ICKBA2]	;limit typeout if lots of errors
	MOVEI B,[ASCIZ/ Cksm err=/]
	PUSHJ P,STROUT
	PUSHJ P,TYPOCH		;print octal (clobbers B).
ICKBA2:	AOS CHKERR		;count an error of this type
	AOS TAPERR		;count an error of any type
	POP P,B
	POPJ P,

;This really should never happen, because IWCCHK should have prevented it.
;So this is a bug in error recovery probably.
ICKICK:
repeat 0,<
	OUTSTR [ASCIZ/
%%% Inconsistent word counts -- output file ended but not input file.
%%% This would seem to be a bug in error recovery.  Please find a wizard!
%%% (Wizard: Examine DBLBUF.)
/]
	HALT .			;only a wizard knows how to get past this
>;repeat 0
	OUTSTR [ASCIZ/ Inconsistent word counts -- output file ended but not input file.
/]
	AOS BADWCS		;count an error of this type
	AOS TAPERR		;count an error of any kind
	MOVE A,IWC		;skip forward by amount it says, I guess
	ADDM A,TIBUF+1		;  ignoring the data in between
    pushj p,tibufc	;check tibuf+1 for overflow
	MOVN A,A
	ADDM A,TIBUF+2		;reduce byte count
	SETZM IWC		;reduce input word count
	POPJ P,

;Save any previous media error data at end of block.
;Note that a subsequent continuation block for the same input file
;will overwrite prev media error data from this block, but that's OK,
;because such subsequent error data includes this data and maybe more.
SERDAT:	MOVE A,[POINT 36,MEDERR]
	MOVEM A,MEDPTR		;initialize byte ptr for saving media error data
	JRST SERDA2

SERDAL:	ILDB A,TIBUF+1		;get media error data
	XORM A,CHKSUM		;adjust checksum
	IDPB A,MEDPTR		;save media error data
SERDA2:	SOSL PSTDAT		;skip if no (more) media error data
	JRST SERDAL
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               subttl	check file-continuation block ; IWCCHK IWCER3 IWCCOA IWCCO4 IWCCO2 IWCERR IWCER2 IWCER4 IWCER0

;Here when we have a file-continuation word count in A.
;Make sure it's reasonable, and if not, we put a better word count into A.
;If there is no room left in input buffer for any data, then we take direct
;return (after zeroing TIBUF+2) -- caller should read a new wd-cnt word.
;Otherwise, if word count in A is not reasonable,
;we recover by XCTing second instr following call -- at that
;point RH C contains the amount of room left in current buffer before checksum.
;Returns the word count in RH A, with LH zero.
;Double skips (without XCT'ing intervening instruction) if no error.
;Also reads any leader info (preceding file info) into CONDEV/CONINF array,
;adjusting the word count downward (and the input byte pointer and count forward).
;Doesn't adjust word count downword for trailing info, which is left included in A,
;but does set up PSTDAT to the number of trailing words following the file data.
;Call--	PUSHJ P,IWCCHK
;	 <return here if no more room in buffer at all>
;	 <this instruction XCT'd if word count not reasonable>
;	<return here unless no more room in buffer>
IWCCHK:	PUSH P,B		;notice AOS -2(P) below
	PUSH P,C
	SETZM CHKSUM		;start new checksum for new block
	SETZM PSTDAT		;assume no data following file data
	;See how much data space left in current buffer.
	MOVE B,TIBUF		;get ptr to current input buffer
	LDB C,[POINT 17,(B),17]	;get buffer size + 1 out of buffer overhead word
	ADDI C,-1(B)		;make address of last word of buffer, - 1
	SUB C,TIBUF+1		;how many words left in buffer before checksum word
	TRNE C,-1		;better not be zero words left
	TRNE C,400000		;18-bit count better not be negative
	JRST IWCER0		;zero or negative count is impossible, return direct
	AOS -2(P)		;now we won't take the direct return
printx Perhaps IWCCHK should limit to remaining data words according to content cnt.
	;See if word count is reasonable.
IWCER3:	ADDI A,1		;Dart WC should be more than this below buffer cnt
	CAML A,TIBUF+2		;WC should be less than buffer's byte count
	SOJA A,IWCER2		;bad word count, undo the ADDI and go fix something
	SUBI A,1		;undo the ADDI above
	CAILE A,(C)		;shouldn't exceed amt of space left in buffer
	JRST IWCERR		;bad word count, goes beyond phys end of buffer
	PUSH P,C		;remember buffer free space count
	;See if any leading info precedes file data in continuation block.
	MOVE B,TIBUF+2		;get remaining word count for buffer
	CAIGE B,LLEAD3+LMEDER	;if not this much,
	JRST IWCCO2		; then must be early format
	MOVE B,TIBUF+1		;get byte ptr to word count word
	MOVE C,CONDAR(B)	;get possible 'DART' word
	CAME C,['DART  ']	;skip unless tape format is before IOVER3
	JRST IWCCO2		;no extra data in this record
	HLRZ C,CONFMT(B)	;check 'CON',,n continuation tape format word
	CAIE C,'CON'		;skip unless tape format is before IOVER3
	JRST IWCCO2		;no extra data in this record
	HRRZ C,CONFMT(B)	;check 'CON',,n continuation tape format word
	CAIG C,VERMSK		;make sure reasonable version nbr
	CAIGE C,IOVER3		;skip unless tape format is before IOVER3
	JRST IWCCO2		;no extra data in this record
	;Have now verified that this continuation block has extra data words.
	POP P,C			;restore buffer free count before IWCERR
	CAIGE A,LLEAD3+LMEDER	;better be at least enough count for IOVER3 info
	JRST IWCERR		;oops
	PUSH P,C		;save buffer free space count again
	SUBI A,LLEAD3		;reduce count for leader words
	PUSH P,A
	MOVSI B,-LLEAD3		;IOVER3 format has more info before file data
IWCCOA:	PUSHJ P,TREAD		;read a word from the file
	MOVEM A,CONDEV(B)	;store in different place from file start info
	XORM A,CHKSUM		;adjust checksum
	AOBJN B,IWCCOA		;loop reading info preceding file data
	POP P,A
	MOVEI C,LMEDER		;number of error data words
	MOVEM C,PSTDAT		;have to read these words later
	MOVSI B,4		;see if cont block has same file as that in progress
IWCCO4:	MOVE C,FILINF(B)	;check name of current file
	CAME C,CONINF(B)	;against name of file in cont block
	PUSHJ P,CONDIF		;cont block filename differs!! (always skips)
	 AOBJN B,IWCCO4		;check 4 words of filename
IWCCO2:	POP P,C			;restore buffer free count before IWCERR
	MOVE B,IFSIZE		;amount of input file left to be read
	ADD B,PSTDAT		;length of any trailer data counted in A's wd ct
	CAMLE A,B		;make sure no more data than file has left
IWCERR:	XCT @-2(P)		;not a valid word-count word, try to recover
	POP P,C
	POP P,B
	JRST CPOPJ1

;Here if buffer is shorter than cont wd cnt would imply.
;We may get here twice for same buffer (if bad wd cnt is in middle of buf),
;but we won't loop forever, because ZEREND won't skip on second call from here.
IWCER2:
;	CAIE A,RECSIZ-WCWD-CKWD	;does wd count have standard value?
;	JRST IWCERR		;no, maybe isn't really word count
	CAIE A,(C)		;does wd count reach just to end of phys buffer?
	JRST IWCERR		;no, maybe isn't really word count
	PUSH P,C		;preserve distance to end of buffer
	PUSHJ P,ZEREND		;zero out end portion of buffer, fix buffer cnt
	 JRST IWCER4		;buffer was already full of data, nothing zeroed
	POP P,C			;restore distance to end of buffer
	PUSHJ P,RFDB2S		;file cont block, but MT buffer is short (MT lost)
	JRST IWCER3		;now see if things are fixed up enough

IWCER4:	POP P,C			;restore distance to end of buffer
	JRST IWCERR		;go call error recovery routine

IWCER0:	OUTSTR [ASCIZ/ Bad continuation block, starts at buffer end; word-count word = /]
	PUSHJ P,TYBWCW		;type bad wd-cnt word and CRLF
	SETZM TIBUF+2		;clear byte cnt to force us to read from a new buf
	AOS BUFEND		;count error of this type
	AOS TAPERR		;count error of any type
	POP P,C
	POP P,B
	POPJ P,			;direct return means need to read another wd cnt
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        subttl	continuation block with different filename ; CONDIF

;Filename in continuation block isn't same as preceding block's filename.
;Here only from above, with B and C pushed.
CONDIF:	PUSH P,A		;preserve ACs
	PUSH P,D
	PUSH P,FL
	TLZ FL,LSTON		;force tty output
	OUTSTR [ASCIZ/
** Filename in continuation block: /]
	MOVE D,[CONINF,,A]
	BLT D,D
	PUSHJ P,TYFIL		;type file from A-D
	CLOSE LST,		;force tty buffer out
	OUTSTR [ASCIZ/
   doesn't match file being read:  /]
	MOVE D,[FILINF,,A]
	BLT D,D
	PUSHJ P,TYFIL		;type file from A-D
	CLOSE LST,		;force tty buffer out
	OUTSTR CRLF
	AOS CONDFF		;count error of this type
	AOS TAPERR		;count error of any type
	;For now, we just go right on without stopping at this error!
	POP P,FL
	POP P,D
	POP P,A
	JRST CPOPJ1		;always skip
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      subttl	recover from bad continuation block ; BADIWC BADIW0 BADIW2 ZERERR ZEREND TYBWCW

;On WC error, try to recover (after telling user)
;by making up a word count consistent with the remaining size of the file
;in progress and the remaining space in the current buffer.
;Here always from XCT within IWCCHK -- with RH C specifying maximum count of
;data words that could fit in remaining buffer space (followed by checksum word).
BADIWC:	SKIPG NRETRY
	JRST [	OUTSTR [ASCIZ/ Bad cont blk. /] ;short form
		JRST BADIW0]
	OUTSTR [ASCIZ/ Bad continuation block for input file; word-count word: /]
	PUSHJ P,TYBWCW		;type bad wd-cnt word and CRLF
BADIW0:	SETZM PSTDAT		;assume no trailer info, couldn't find it anyway
	AOS BADWCW		;count error of this type
	AOS TAPERR		;count error of any type
;no!	ADDI C,1		;allow one more data word (the bad word) in wd cnt
	MOVE A,IFSIZE		;remaining input file size incl. this new block
	CAILE A,(C)		;wd cnt is min of remaining file size and buf space
	MOVEI A,(C)		;limit word count to space left in buffer
	ADDI A,2		;minimum buf cnt, to include cksum wd & SOSG TIBUF+2
	CAMG A,TIBUF+2		;is buffer count big enough?
	JRST BADIW2		;yup
	PUSHJ P,ZEREND		;zero out end portion of buffer, fix buffer cnt
	 PUSHJ P,ZERERR		;buffer was already full of data, nothing zeroed
BADIW2:	SUBI A,2		;undo above ADDI, return as if real wd cnt word
repeat 0,< ;assume data was real WC word that was clobbered (say, bit picked)
	LDB B,TIBUF+1		;get back the bad word-count word
	CAIN B,(C)		;does WC look like normal Dart WC?
	POPJ P,			;yes, don't backup over it
	AOS TIBUF+2		;put back the bad word-count word, assuming that
	SOS TIBUF+1		;  it is really a data word (back up byte ptr/cnt)
>;repeat 0
	POPJ P,

ZERERR:	OUTSTR [ASCIZ/
%%% Didn't find expected additional words in input buffer during
%%% error recovery!  Find a wizard.
/]
	HALT .

;Here we're going to increase the input word count as if the buffer held more
;data, right up to its end.  Since the system
;doesn't zero the words beyond the returned byte count, we zero them here.
;Must preserve A, clobbers B and C.
;Direct return if buffer already full.
;Skips iff has to zero anything.
ZEREND:	PUSH P,A
	MOVE A,TIBUF		;get ptr to buffer whose last part we want to zero
	HRRZ B,1(A)		;get word count from buffer overhead word
	LDB C,[POINT 17,(A),17]	;get buffer size + 1 out of buffer overhead word
	SUBI C,1(B)		;number of words to zero
	JUMPLE C,POPAJ		;jump if none, take direct return, nothing zeroed
	ADDM C,TIBUF+2		;increase input byte count
	ADDM C,1(A)		;increase buffer count in overhead word (for recursion)
	ADDI B,3(A)		;make address of second unfilled word in buffer
	ADDI C,-2(B)		;make addr of last data word in buffer
	SETZM -1(B)		;clear first unfilled word, preparing for BLT
	HRLI B,-1(B)		;set source address for BLT as word just zeroed
	CAIL C,(B)		;skip if only one unfilled word
	BLT B,(C)		;clear to end of buffer
	JRST POPAJ1		;restore A and take skip return

;Type last word read (a word-count word).
TYBWCW:	PUSH P,FL
	TLZ FL,LSTON		;force tty output
	LDB A,TIBUF+1		;get back the bad word-count word
	PUSHJ P,TYPOCH		;type octal halfwords
	POP P,FL
	OUTSTR CRLF
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ;initialize DTAPES.DAT ; DTDINI DTDRAM

;Initialize an empty DTAPES.DAT for output, in read-alter mode.
;Here only for master tape copy.
DTDINI:	MOVE A,['DTAPES']
	MOVSI B,'DAT'
	MOVEI C,0		;zero protection
	MOVE D,DUMPER
	ENTER DSKMSC,A
	 JRST [	OUTSTR [ASCIZ/%%% Unable to enter DTAPES.DAT.
/]
		HALT DTDINI]
	SETZM ARCWC		;no data in DTAPES.DAT yet
	SETZM MEMSAV+MERGFL	;will need another merge for this tape
	SETZM MEMSAV+DTAMAX	;file's max length so far is zero
	SETZM MEMSAV+PTRSAV	;no validated data in file yet
	SETZM MEMSAV+LUSER	;no PPN in validated data
	SETZM MEMSAV+DTAOOO	;no out of order PPNs yet in DTAPES
	PUSHJ P,DMINIC		;clear buffer
;Get DTAPES.DAT open in read-alter mode, without clobbering buffer.
DTDRAM:	MOVE A,['DTAPES']
	MOVSI B,'DAT'
	CLOSE DSKMSC,		;close so we can open in RA mode
	MOVE D,DUMPER
	LOOKUP DSKMSC,A
	 JRST [	OUTSTR [ASCIZ/%%% Unable to lookup DTAPES.DAT.
/]
		HALT DTDRAM]
	LSH D,-7		;turn length into whole records
	MOVEM D,DSKMM0		;remember number of records in file (see MFIXD)
	MOVE D,DUMPER
	ENTER DSKMSC,A		;go into read-alter mode
	 JRST [	OUTSTR [ASCIZ/%%% Unable to enter DTAPES.DAT for read-alter mode.
/]
		HALT DTDRAM]
	SETOM DSKMM3		;set binary mode
	PUSHJ P,DMINIP		;init buffer pointer and count
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ;tape copy -- re-position output to DTAPES.DAT ; MFIXD MFIXD4 MFIXD2 MFIXDE MFIXDI

;Position output in DTAPES.DAT according to saved word count.
;Note that if wd cnt is multiple of 200, then we may have a full buffer
;in REELBF that never got written out.  In any case, there is probably
;some data in REELBF, although we may want to backup to before that data.
;Here when doing pickup or after hitting physical end of output tape.
MFIXD:	PUSHJ P,DMINIP		;set up output ptr, assuming end of record boundary
	MOVE C,DSKMM0		;DTAPES.DAT file length in whole records
	MOVE A,MEMSAV+LUSER	;get PPN as of saved ptr into DTAPES.DAT
	MOVEM A,SPPN		;restore it
	MOVE A,MEMSAV+PTRSAV	;get word count for DTAPES.DAT
	MOVEM A,ARCWC		;restore for ongoing use
	IDIVI A,200		;make it record count and offset
	MOVEM A,DSKMM0		;save desired record count
	CAIN A,(C)		;if nbr of records before REELBF is whole file,
	JRST MFIXD4		; just adjust byte count and byte ptr within REELBF
	CAIN A,1(C)		;if wd cnt is whole rec past file, B better be 0
	JUMPE B,[SETZM DSKMM2	;B zero means REELBF is full, force it out soon
		 SOS DSKMM0	;haven't actually written last record to file
		 SOJA A,MFIXD2]	;position us to write the new record ready in REELBF
	CAIL A,(C)		;record to be read better be within existing file
	JRST MFIXDE		;record is beyond file, and beyond hope!
	JUMPE B,MFIXD2		;jump if at exact end of record
	USETI DSKMSC,1(A)	;prepare to read back the partial record
	INPUT DSKMSC,[IOWD 200,REELBF
			0]	;read in the record of interest
	STATZ DSKMSC,740000
	 PUSHJ P,MFIXDI		;input error
MFIXD4:	ADDM B,DSKMM1		;advance byte pointer by whole words of offset
	MOVN B,B
	ADDM B,DSKMM2		;reduce byte count by offset
MFIXD2:	USETO DSKMSC,1(A)	;make next output go to same record
	POPJ P,

;Here if wd cnt is beyond end of existing file.  Make sure the wd cnt points
;into REELBF within the next record after the existing file.
MFIXDE:	OUTSTR [ASCIZ/%%% Unable to reposition DTAPES.DAT output to given word.
/]
	HALT .

MFIXDI:	OUTSTR [ASCIZ/%%% Disk file input error (DSKMSC).
/]
	HALT .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ;tape copy -- bugtraps for word count and filename ; IWCDBG DUPCHK DUPLUP DUPDIF DUPINI

;Here when about to store RH of A into IWC.
;Make sure RH A isn't negative or otherwise bad.
IWCDBG:	TRNN A,740000		;A can be at most 24000 (BRCSIZ)
	POPJ P,			;all OK
	OUTSTR [ASCIZ/%%% Bad word count value in RH A at IWCDBG, called from: /]
	PUSH P,A
	PUSH P,B
	PUSH P,FL
	TRZ FL,LSTON		;force output to TTY
	MOVE A,-3(P)		;get return address
	PUSHJ P,TYPOCH		;type half word form
	OUTSTR CRLF
	POP P,FL
	POP P,B
	POP P,A
	HALT .

;Skip unless filename in FILINF matches a recently encountered filename.
;If there's a match, then we're probably rereading a bad piece of tape
;over and over, so we take direct return so someone can handle that situation.
DUPCHK:	MOVE D,FILINF+DDPPN	;get PPN
	CAME D,FAKEFI+3		;don't check file if fake PPN
	SKIPN MASCOP		;nor if not MCOPY
	JRST CPOPJ1		;don't check
	HLLZ B,FILINF+DDEXT	;get extension
	MOVE A,FILINF+DDNAM	;file name
	MOVSI C,-NCPFIL		;number of filenames to check
DUPLUP:	CAMN A,CPFIL(C)
	CAME B,CPEXT(C)
	JRST DUPDIF		;not a match
	CAMN D,CPPPN(C)
	POPJ P,			;exact match, take direct return
DUPDIF:	AOBJN C,DUPLUP		;loop through list of recent filenames
	AOS C,PCPFIL		;increment the pointer into the list
	CAIL C,NCPFIL		;end of buffer?
	SETZB C,PCPFIL		;yes, wrap to beginning of buffer
	MOVEM A,CPFIL(C)	;save this new filename in the buffer
	MOVEM B,CPEXT(C)	;save ext
	MOVEM D,CPPPN(C)	;save PPN
	JRST CPOPJ1		;all OK, no match

;Clear the array of saved filenames to avoid a match after a new tape
;is mounted.  We would get a match after a new output filename because
;we've backed up the input tape.
DUPINI:	PUSH P,A
	SETZM CPFIL		;just zero the primary filenames
	MOVE A,[CPFIL,,CPFIL+1]
	BLT A,CPFIL+NCPFIL-1	;of the whole array
	POP P,A
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ;logging of master tape copy typeout ; MCLINI MCLIN2 MCLEMP MCLIER UUOTRP MCLHLT MCLCH0 MCLCHL MCLCH2 MCLCH1 MCLCR MCLINS MCLTAB MCLSIX MCLSI2 MCLCHR UUOXFC UUOXIT UUOXI0 MCLSTR MCLSTL MCLFRC MCLCHI MCLCLR PPSAV PPSAVX PPSAVE PPSAVP REENTD REENTE MCLREX DBLOG0 DBLOG1 DBLOG2 DBLOG3 DBLOG4 DBLOG5 DBLOG6 DBLOG7 DBLO10 DBLO11 DBLO12 DBLO13 DBLO14 DBLOG DBLOGA DBLOGB DBLINI

;Keep log file for master tape copy: MCLINI.

;Also, maintain debugging log in circular buffer: DBLINI

Comment 

We log in a disk file all characters typed out on, or in from, the
terminal during MCOPY.  We do this by using the UUOSIM UUO to trap all
UUOs, from whence we detect certain TTY input and output UUOs, whose
actions we re-execute and log.  Other UUOs are simply handed back to the
system to execute.

Each time an MCOPY command is given, we create a new log file,
called mmddx.LOG, where mm is the number of the current month,
dd is the current day of the month, and x is a letter allowing
the filename to be unique.  E.g., 0102A.LOG and 0102B.LOG for Jan 2.

We create the log file and re-open it in Read-Alter mode.  We write it in
dump mode, with one 200-wd buffer.  We force the buffer out (A) whenever
we write a LF via OUTCHR/MASOUT, (B) whenever an OUTSTR string ends, and
(C) whenever the user gives the REENTER monitor (or Dart) command.  When
we force the buffer out, we backup the output USETO pointer one record so
we can overwrite that buffer with new data later.  Whenever we write out a
record, we use MTAPE 17 to force the retrieval out.

end of comment 

;Initialize log file for master tape copy.
MCLINI:	MOVEI A,17
	MOVSI B,'DSK'
	SETZB C,MCLOPN		;no file open yet
	OPEN COPLOG,A
	 PUSHJ P,NODEV
	DATE B,			;get today's date
	IDIVI B,=31		;year/month into B, day into C
	ADDI C,1		;make first day of month be 1
	PUSH P,C		;save day of month
	IDIVI B,=12		;month into C, year into B
	MOVEI B,1(C)		;make January be number 1 (forget year)
	MOVE A,['0000A ']	;form of log file names
	IDIVI B,=10		;make two digits for month
	DPB B,[POINT 4,A,5]	;first digit in sixbit name
	DPB C,[POINT 4,A,11]	;second digit in sixbit name
	POP P,B
	IDIVI B,=10		;make two digits for day
	DPB B,[POINT 4,A,17]	;third digit in sixbit name
	DPB C,[POINT 4,A,23]	;fourth digit in sixbit name
MCLIN2:	MOVSI B,'LOG'		;standard extension
	MOVEI D,0		;write log on current area!
	LOOKUP COPLOG,A		;see if file already exists
	 TRNE B,-1		;skip if no such file
	JRST [	ADDI A,000100	;increment letter in filename
;		OUTCHR ["."]
		JRST MCLIN2]	;and try again
	MOVEI C,0		;no protection bits
	ENTER COPLOG,A		;create file
	 JRST MCLIER		;failed!
	CLOSE COPLOG,		;allow us to reopen the file in RA mode
	MOVEI D,0
	LOOKUP COPLOG,A
	 JRST MCLIER		;can't reopen file
	MOVEI D,0
	ENTER COPLOG,A		;go into read-alter mode
	 JRST MCLIER		;can't?
	MOVEM A,MCLNAM		;save log file name for inserting into log file
	MOVEI A,1
	MOVEM A,MCLREC		;number of next record to be output in log file
	SETZM UUOBLK+1		;enable UUO trapping
	MOVEI A,MCLWID		;number of output cols before we insert a CRLF
	MOVEM A,MCLCOL		;output columns left
	MOVEI A,UUOBLK		;Trap address for UUOs
	UUOSIM A,		;tell system we want to trap UUOs
	SETOM MCLOPN		;file is open now
	PUSHJ P,MCLEMP		;clear and initialize the buffer
	MOVE B,MCLNAM		;get back name of file
	PUSHJ P,MCLSIX		;output filename into log file itself
	MOVEI A," "
	PUSHJ P,MCLCHL		;output a space after filename
	POPJ P,

MCLEMP:	MOVEI A,LMCLBF*5	;Number of chars log buffer will hold
	MOVEM A,MCLCNT
	SETZM MCLBUF
	MOVE A,[MCLBUF,,MCLBUF+1]
	BLT A,MCLBUF+LMCLBF-1	;clear out the buffer
	MOVE A,[POINT 7,MCLBUF]
	MOVEM A,MCLBP		;Initialize byte pointer for queue text
	POPJ P,

MCLIER:	OUTSTR [ASCIZ/%%% LOOKUP or ENTER of log file failed.  Find a wizard.
/]
	HALT .

;Here with a UUO trapped to us by the system.  Effective addr calculation done.
UUOTRP:	PUSH P,A
	HLRZ A,UUOBLK+1		;UUO LH (can't have index or indirect field)
	CAIN A,(<OUTCHR>)
	JRST MCLCHR		;One character output
	CAIN A,(<OUTSTR>)
	JRST MCLSTR		;ASCIZ output
	CAIE A,(<INCHWL>)
	CAIN A,(<INCHRW>)
	JRST MCLCHI		;get char from user
	CAIN A,(<INCHRS>)
	JRST MCLCHI		;get char from user
	CAIN A,(<CLRBFI>)
	JRST MCLCLR		;clear input buffer (by reading/logging it all)
	CAIN A,(<HALT>)
	JRST MCLHLT		;trap HALT because it undoes UUOSIM!
	POP P,A
	AOS UUOBLK		;Maybe the uuo will skip
	AOS UUOBLK		;Maybe the uuo will skip
	AOS UUOBLK		;Maybe the uuo will skip
	XCT UUOBLK+1		;Not our uuo, let system handle it
	 SOS UUOBLK		;Didn't skip after all
	 SOS UUOBLK		;Didn't skip after all
	 SOS UUOBLK		;Didn't skip after all
	JRST UUOXI0		;return

;Here when trapping a HALT.
;If user continues, we need to redo the UUOSIM UUO because HALT undoes it.
MCLHLT:	POP P,A			;restore AC
	HALT .+1		;execute the halt (this one won't be trapped)
	PUSH P,A		;get an AC
	MOVEI A,UUOBLK		;Trap address for UUOs (HALT undid UUOSIM)
	UUOSIM A,		;tell system we want to trap UUOs once again
	MOVE A,UUOBLK+1		;get effective addr of halt
	MOVEM A,UUOBLK		;that's the place to continue at
	POP P,A
	JRST UUOXI0		;on we go, to wherever the halt said
    ;This doesn't really seem to work, the halt seems to happen again anyway.


;Output one character, to both terminal and log file.
MCLCH0:	OUTCHR A		;first we type it out!  then stuff in disk buffer.
;Here from LSTOUT to copy char in A to the log file for master copy.
;Also here from trapped input UUOs to log the char typed.
MCLCHL:	CAIN A,15		;CR?
	JRST MCLCR		;Yes
MCLCH2:	SOSGE MCLCOL		;Filled up this line?
	JRST MCLINS		;Yes, insert a CRLF
	CAIN A,11		;Tab?
	JRST MCLTAB		;Yes, must count right number of spaces
MCLCH1:	IDPB A,MCLBP
	SKIPE STATLG		;collecting statistics?
	SOSGE STATFR		;and still have room?
	CAIA			;no to one of these, forget it
	IDPB A,STATBP		;save char for stats
	SOSLE MCLCNT		;Make sure there is still room in buffer
	POPJ P,
	OUTPUT COPLOG,[IOWD LMCLBF,MCLBUF ;write the buffer out
			0]
	AOS MCLREC		;new record now
	JRST MCLEMP		;clear the buffer, reset the pointer and counter

;Reset line position for a CR (note: we don't do anything special for LFs).
MCLCR:	MOVEI A,MCLWID+1
	MOVEM A,MCLCOL		;Reset to left margin, assuming next char is LF!
	MOVEI A,15
	JRST MCLCH1		;Go output the CR

;Insert a CRLF in middle of long line.
MCLINS:	PUSH P,A
	PUSHJ P,MCLCR		;Insert a CR
	MOVEI A,12
	PUSHJ P,MCLCH2		;And a LF
	POP P,A
	JRST MCLCH2		;Now go retry outputting this normal char

;Count spaces in a tab.
MCLTAB:	MOVE A,MCLCOL		;cols to go
	ANDI A,7		;this gives number of extra spaces to count
	MOVN A,A
	ADDM A,MCLCOL		;Remember new column
	MOVEI A,11
	JRST MCLCH1		;Output the tab

;Here to convert a sixbit name in B to ASCII, outputting it to log file.
MCLSIX:	MOVEI C,6		;max number of chars
MCLSI2:	MOVEI A,0
	LSHC A,6		;shift first char from B into A
	ADDI A,40		;make it ASCII
	PUSHJ P,MCLCHL		;output to log file
	JUMPN B,MCLSI2		;loop till nothing left but spaces
	POPJ P,

;Here for OUTCHR uuo.
MCLCHR:	MOVE A,(P)		;Restore A in case it holds the char
	HRRZ A,@UUOBLK+1	;Get char to output
	PUSHJ P,MCLCH0
	CAIN A,12		;was it a LF we output?
UUOXFC:	PUSHJ P,MCLFRC		;yes, force out the log file buffer
UUOXIT:	POP P,A			;restore AC for main program
UUOXI0:	SETZM UUOBLK+1		;Re-enable UUO trapper
	JRST @UUOBLK		;Return from trap to main program

;Here for OUTSTR uuo.
MCLSTR:	MOVEI A,440700
	HRLM A,UUOBLK+1		;Make byte pointer to string to output
MCLSTL:	MOVE A,(P)		;Restore A in case it holds string
	ILDB A,UUOBLK+1
	JUMPE A,UUOXFC		;String ends with null, force out buffer, return
	PUSHJ P,MCLCH0
	JRST MCLSTL

;Force out the buffer, update retrieval, then backup USET pointer since buffer
;isn't full, so we can output same one again.
MCLFRC:	SKIPN MCLBUF		;skip unless the buffer is empty
	POPJ P,			;empty buffer is easy to handle
	OUTPUT COPLOG,[IOWD LMCLBF,MCLBUF ;write the buffer out
			0]
IFN STANSW,<
	MTAPE COPLOG,['GODMOD'  17] ;force retrieval updated to include new length
>;IFN STANSW
	USETO COPLOG,@MCLREC	;enable us to re-output this buffer next time
	POPJ P,

;Here when trapping UUO that reads a char from the user (INCHWL,INCHRS,INCHRW).
MCLCHI:	MOVE A,(P)		;restore AC before UUO
	SETZM @UUOBLK+1		;clear result in case no char returned
	AOS UUOBLK		;Maybe the uuo will skip
	XCT UUOBLK+1		;Not our uuo, let system handle it
	 SOS UUOBLK		;Didn't skip after all
	MOVEM A,(P)		;save an AC
	SKIPE A,@UUOBLK+1	;pick up the character, if any
	PUSHJ P,MCLCHL		;put the character into the log file
	JRST UUOXFC		;finish up trap code, forcing out log buffer

;Here to simulate CLRBFI UUO, so we can log all characters typed.
MCLCLR:	INCHRS A		;get a char
	 JRST UUOXFC		;none, CLRBFI is done, update log file and return
	PUSHJ P,MCLCHL		;put the character into the log file
	JRST MCLCLR		;loop until nothing to read

;Here to save page printer text by starting PPSAV as a detached job.
;We start PPSAV via starting addr - 1, with 'DET',,<our line number> in AC 1.
PPSAV:	PUSH P,0		;preserve all ACs
	PUSH P,1
	HRROI 1,[3000,,1]	;get our line number
	TTYSET 1,
	TLNN 1,DMLIN!DDDLIN!DISLIN ;are we on a display?
	JRST PPSAVE		;no, too bad, can't PPSAV
	HRLI 1,'DET'		;signal for PPSAV program running detached
	MOVEI 0,PPSAVP		;ptr to swap block
	PUSH P,.JBOPC		;next UUO clobbers this?!
	SWAP 0,			;start up PPSAV as a detached job to save our PP
	POP P,.JBOPC		;restore old PC, in case here from REENTER
	SKIPE 0			;skip unless we started a job
	OUTSTR [ASCIZ/PPSAV started on detached job OK.
/]
	MOVEI 1,2		;give PPSAV a couple of seconds
	SLEEP 1,		; to do its job
PPSAVX:	POP P,1
	POP P,0
	POPJ P,

PPSAVE:	OUTSTR [ASCIZ/Can't PPSAV the output from this non-display terminal.
Better remember it yourself.
/]
	JRST PPSAVX

PPSAVP:	'SYS   '
	'PPSAV '
	'DMP',,14		;start as separate job and phantom
	0,,-1			;startup address - 1 to get detached feature
	'  1  3'		;irrelevant but redundant
	0			;login with our PPN (and alias?)

;Here from Dart REENTER command.  Essentially same as monitor command.
REENTD:	PUSH P,[CPOPJ]
	POP P,.JBOPC		;set up address to continue at after EXIT
;Here from monitor REENTER command.  Force out log file buffer, if any.
;Note: Preserves all ACs.  Assumes only that P is set up.
REENTE:	DPYCLR			;normalize display, in case from RAID
	PUSHJ P,PPSAV		;run PPSAV as detached job
	SKIPE MASCOP		;are we doing master copy?
	SKIPN MCLOPN		;yes, is log file open?
	JRST MCLREX		;nope
	PUSHJ P,MCLFRC		;force out the log file buffer
	OUTSTR [ASCIZ/MCOPY log file has been updated OK.
/]
MCLREX:	EXIT 1,
	JRST @.JBOPC		;try to resume interrupted main program on CONTINUE

;PUSHJ to one of these to insert data in A into circular debugging buffer.
DBLOG0:	JSR DBLOG	;RDFIL0 file start
DBLOG1:	JSR DBLOG	;RDFILS skipping file
DBLOG2:	JSR DBLOG	;RDERR wc was garbage, using buffer count - 2 instead
DBLOG3:	JSR DBLOG	;RDCON cont block when file start expected
DBLOG4:	JSR DBLOG	;RFDTCN setting up continuation block amt
DBLOG5:	JSR DBLOG	;RDCON setting up estimated file size (FSIZE)
DBLOG6:	JSR DBLOG	;RDERR3 (from RDERR or RDCON), setting up FSIZE
DBLOG7:	JSR DBLOG	;RFIL2 setting up FSIZE, new file at RFIL1
DBLO10:	JSR DBLOG	;TCDUMP setting up FSIZE at start of new file
DBLO11:	JSR DBLOG	;TCDU4 adjusting FSIZE down by amt going into output block
DBLO12:	JSR DBLOG	;TCOPS3 truncating output file prematurely (ignore data)
DBLO13:	JSR DBLOG	;RFIL2 storing primary filename of new file (RFIL1)
DBLO14:	JSR DBLOG	;RDERR wc was garbage and buffer count was 1 or smaller.

;DBLOGA is called from TCIADJ after reading new input block, setting IWC.

;Main routine called from above.
;Logs a prefix offset count derived from caller above, along with value in A.
;DBLOGA can be called directly to log value in A without a prefix code.
DBLOG:	0
	PUSH P,A		;free up an AC
	HRRZ A,DBLOG		;get return address of JSR
	SUBI A,DBLOG0+1		;generate offset of 0 for first caller, etc.
	HRLI A,400004		;unusual LH datum to identify this type of entry
	PUSHJ P,DBLOGA		;log data in A -- which is offset indicating caller
	POP P,A			;retrieve the relevant data, fall through to log it
DBLOGA:	SOSL DBLCNT		;have we reached end of circular buffer?
	JRST DBLOGB		;no
	PUSH P,A		;save the datum
	PUSHJ P,DBLINI		;reset buffer count and ptr to beginning
	SOS DBLCNT		;count one item going into buffer
	POP P,A
DBLOGB:	IDPB A,DBLPTR		;insert into circular buffer
	POPJ P,

DBLINI:	MOVEI A,DBLLEN		;length of circular buffer in words
	MOVEM A,DBLCNT		;set up as words till end of buffer
	MOVE A,[POINT 36,DBLBUF] ;byte ptr to beginning of buffer
	MOVEM A,DBLPTR		;init ptr into buffer, at beginning
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  subttl	count files on each P tape, for Master Copy ; PTCNT PTCNT1 PTCNTR PTCNT2 PTCNTE PTCNTF

;Start here from DDT to count the files on each P tape, according to
;the database.  This info is then used during the Master Tape Copy
;to validate each input tape's logical end of tape (EOT), because
;sometimes a false logical EOT is detected on the old tape drives.
PTCNT:	DPYCLR			;reset display, since usually start from DDT/RAID
	PUSH P,.JBFF
	MOVE A,.JBFF		;place to put the table
	HRLI A,A		;set up indexing for indirect word in VERDAT
	MOVEM A,PTCNTP		;save ptr, which is flag for VERDAT/ARC.
	MOVEI A,PTCNTL(A)	;length of P tape table, tape number limit + 2
	MOVEM A,.JBFF		;advance free pointer
	CAMG A,.JBREL
	JRST PTCNT1
	CORE A,			;get core for table
	 JRST NOCORE
PTCNT1:	MOVE A,PTCNTP		;loc of count word for tape 0
	SETZM (A)		;clear first word in table
	MOVEI B,PTCNTL-1(A)	;BLT end
	HRLI A,(A)		;BLT source
	ADDI A,1		;BLT dest is next word
	BLT A,(B)		;clear the count array
	PUSH P,DUMPER		;save PPN
	MOVE A,['DMPSYS']	;use "normal" PPN in this count
	MOVEM A,DUMPER		;PPN to read following files from
	OUTSTR [ASCIZ/DART.DAT: /]
	PUSHJ P,VERDAT		;read DART.DAT, verifying and counting files
	OUTSTR [ASCIZ/DART.ARC: /]
	PUSHJ P,VERARC		;read DART.ARC, verifying and counting files
	POP P,DUMPER		;restore official PPN
	MOVEI A,17		;dump mode output
	MOVSI B,'DSK'
	MOVEM B,STRNAM
	MOVEI C,0
	OPEN UFD,A		;PTCNT.DAT output
	 PUSHJ P,NODEV
	MOVE D,[PTCNTF,,A]
	BLT D,D			;get filename to store counts in
	ENTER UFD,A		;open file for writing
	 JRST NOENT		;failed
	HRRZ A,PTCNTP		;address of table
	SUBI A,1		;make IOWD ptr
	HRLI A,-PTCNTL		;make IOWD cnt
	MOVEI B,0		;end of list
	OUT UFD,A		;write out the file
	 CAIA
	JRST NOOUT		;output failed
	RELEAS UFD,
	MOVE D,[PTCNTF,,A]
	BLT D,D			;get filename again
	PUSHJ P,TYFIL
	OUTSTR [ASCIZ/ written.
/]
	MOVEI A,PTCNTL-1
	SKIPE @PTCNTP		;see if last word in table is zero
	OUTSTR [ASCIZ/** Note: Some tape numbers exceed max index in table!
/]
	SETZM PTCNTP		;disable VERDAT/ARC from counting hereafter
	POP P,.JBFF		;restore free pointer
	POPJ P,			;return from call to DDT

;Read in the file of counts of files per old P tape.
PTCNTR:	MOVE D,[PTCNTF,,A]
	BLT D,D			;get filename to read
	LOOKUP DSKMEM,A		;read the file
	 JRST NOLOOK		;lookup failed, lose badly
	MOVS D,D		;get negative file length
	CAMLE D,[-PTCNTL]	;make sure file has enough tapes considered
	JRST PTCNTE		;PTCNT.DAT is too small for comfort
	MOVE A,.JBFF		;place to put the file
	HRROM A,PTCNTP		;save ptr to incore table, prevent VERDAT from counting
	SUB A,D			;make last address of table
	HRRZM A,.JBFF		;advance free ptr
	CAMG A,.JBREL
	JRST PTCNT2
	CORE A,			;get core for table
	 JRST NOCORE
PTCNT2:	HRRZ A,PTCNTP		;address of table
	SUBI A,1		;make IOWD ptr
	HRLI A,-PTCNTL		;make IOWD cnt
	MOVEI B,0		;end of list
	IN DSKMEM,A		;read in the file
	 CAIA
	JRST DSKRER		;disk error
	CLOSE DSKMEM,		;OK, got file into core
	POPJ P,

PTCNTE:	OUTSTR [ASCIZ/%%% PTCNT.DAT file doesn't have enough tape counts.
%%% Find a wizard.
/]
	HALT .

;File to hold P-tape counts.  Word N of file is count of disk files on P tape N.
;Last word of file is count of disk files with P tape number that high or bigger.
;So, first and last words of the file should normally be zero (no tape P0).
PTCNTF:	'PTCNT '
	'DAT   '
	0
	0			;write on current PPN
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         subttl	tell who last used a tape	 ; TURKEY TURK0 NONMBR TURK1 TURKL TURKL1 TURKL2 TURKD NOTURK NOBODY

TURKEY:	SKIPA A,SAVDEL		;GET DELIMITER WHICH FOLLOWED COMMAND NAME
TURK0:	INCHWL A		;SKIP SPACES AND TABS
	CAIE A,40
	CAIN A,11
	JRST TURK0
	TLO FL,L.TURK		;FLAG TURKEY COMMAND GOR GETANS
	PUSHJ P,GETA11		;GET TAPE NUMBER FROM COMMAND LINE
	 JRST NONMBR		;OOPS, NO TAPE NUMBER
	 JRST TURK1		;OK RETURN
NONMBR:	OUTSTR [ASCIZ /Must give P or T number with this command.
/]
	TLZ FL,L.TURK		;DON'T CONFUSE POSSIBLE FOLLOWING COMMAND
	JRST RESTAR

TURK1:	TLZE FL,L.TURK		;P OR T?
	MOVNS B			;T CLASS, NEGATIVE NUMBER
	MOVEI K,(B)		;SAVE NUMBER AS HALFWORD
	MOVEI	A,17
	MOVSI	B,'DSK'
	SETZB	C,Z		;Z WILL HAVE THE LUSER'S PPN LATER ON
	OPEN	DSKMSC,A
	 PUSHJ	P,NODEV
IFN STANSW,<
	MOVE	A,['DART  ']
	MOVSI	B,'REC'
	MOVEI	C,0
	MOVE	D,TAPREG	;' SSSYS' OR DBGPPN
	LOOKUP	DSKMSC,A
	 JRST NOTURK		;CAN'T FIND IT
	MOVS	D,D
	MOVN	W,D
>;IFN STANSW
IFE STANSW,<
	MOVEI A,.RBSIZ		;ARG COUNT = 5
	MOVE B,TAPREG
	MOVE C,['DART  ']
	MOVSI D,'REC'
	MOVEI W,0
	LOOKUP DSKMSC,A
	 JRST NOTURK		;CAN'T FIND IT
	MOVE W,X
>;IFE STANSW
	JUMPE W,NOTURK		;NO INFORMATION
	IDIVI W,200		;FILE SIZE AS RECORDS PLUS WORDS
TURKL:	MOVNI A,(X)		;RESIDUE IF TIME FOR LAST RECORD
	JUMPE W,.+2		;JUMP IF LAST RECORD
	MOVNI A,200		;ELSE THIS IS A FULL ONE
	HRLZS A			;MAKE IOWD
	HRRI A,MEMBLK-1
	MOVEI B,0		;END OF LIST
	INPUT DSKMSC,A		;READ THE POOP
TURKL1:	MOVE B,1(A)		;GET TAPE NUMBER AND DATE
	CAIE K,(B)		;SAME TAPE?
	JRST TURKL2		;NO
	MOVE Y,B		;YES, SAVE DATE
	MOVE Z,2(A)		;GET PPN TOO
TURKL2:	AOBJN A,.+1		;SKIP TO NEXT ENTRY
	AOBJN A,TURKL1		; (2 WDS/ENTRY)
	SOJGE W,TURKL		;NO MORE THIS RECORD, MAYBE GET NEXT RECORD
	JUMPE Z,NOBODY		;NOBODY USED THE TAPE
	MOVE A,Z		;PPN IN A
	PUSHJ P,PPNOUT		;TYPE IT
	OUTSTR [ASCIZ / last used it on /]
	HLRZ A,Y		;DATE INTO A
	PUSHJ P,TYDATE		;TYPE IT
	OUTSTR CRLF		;DONE
TURKD:	RELEAS DSKMSC,
	POPJ P,

NOTURK:	OUTSTR [ASCIZ /? Can't find tape user file!
/]
	JRST TURKD

NOBODY:	OUTSTR [ASCIZ /That tape has not been read with DART.
/]
	JRST TURKD
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    subttl	read sixbit command, file name, etc  Delim Spopj1 Spopj2 ; XGET6 GETSIX GETSX1 XGET6A QSET GETSX2 GETSX3 CPOPJ2 CPOPJ1 MAKLF CPOPJ SEMICO SEMIC1 SEMIC2 BLANK STAR ILSTAR ILLEG ILLEG1 DEVSCN DEVSC1 NUMCHR RDNUMB RDNUM0 RDNUM1 RDNUM2

XGET6:	SETZ	A,			;ZERO A
	EXCH	A,SAVDEL		;EXCHANGE WITH OLD DELIMITER
	JUMPE	A,GETSIX		;IF NO OLD DELIMITER
	SETZB	B,QMODE
	TRZ	FL,ALLFLG
	MOVE	C,[POINT 6,B]
	JRST	XGET6A

GETSIX:	SETZB	B,QMODE			;B ACCUMULATES TEXT. QMODE FOR QUOTING
	TRZ	FL,ALLFLG		;NO * SEEN YET.
	MOVE	C,[POINT 6,B]
GETSX1:	TRNN	FL,INDON
	INCHWL A			;READ A CHARACTER
	TRNE	FL,INDON
	PUSHJ	P,RINDIR		;get char from indirect file instead of tty
XGET6A:	ANDI	A,177			;STRIP OFF ANY BUCKY BITS
	MOVE	D,CHRTAB(A)		;GET NORMAL DISPATCH
	SKIPE	QMODE			;SKIP IF NORMAL
	MOVS	D,D			;USE QUOTE MODE DISPATCH
	JRST	(D)

QSET:	SETCMM	QMODE			;HERE FOR CTRL A (DOWN ARROW)
	JRST	GETSX1			;COMPLEMENT QUOTE FLAG AND GET MORE.

GETSX2:	TRZ	A,40			;HERE FOR LOWER CASE LETTER
GETSX3:	TRNE	FL,ALLFLG		;HAS A * BEEN SEEN?
	JRST	ILSTAR			;STAR MUST BE DELIMITED.
	SUBI	A," "			;HERE FOR UPPER CASE LETTER
	TLNE	C,770000		;BYTE OVERFLOW?
	IDPB	A,C			;NOT OVERFLOW. DEPOSIT BYTE
	JRST	GETSX1			;LOOP

CPOPJ2:	SPOPJ2::	AOS	(P)
CPOPJ1:	SPOPJ1::	AOSA	(P)
MAKLF:			MOVEI	A,12
CPOPJ:	DELIM::		POPJ	P,

SEMICO:	TRNE	FL,INDON		;INDIRECT FILE?
	JRST	SEMIC2			;YES.  FLUSH QUIETLY
SEMIC1:	INCHWL A
	CAIE	A,12
	JRST	SEMIC1
	POPJ	P,

SEMIC2:	PUSHJ	P,RINDIR		;HERE WHEN ";" SEEN IN INDIRECT FILE.
	CAIE	A,12
	JRST	SEMIC2
	POPJ	P,

BLANK:	JUMPN	B,CPOPJ			;TRAILING BLANK IS A DELIMITER
	JRST	GETSX1			;LEADING BLANKS, TABS ARE FLUSHED

STAR:	JUMPN	B,ILLEG			;* ILLEGAL IN NAME UNLESS QUOTED
	TLNE FL,L.SWIT
	JRST ILLEG			;ILLEGAL INSIDE PUMPKIN SWITCH
	TRO	FL,ALLFLG		;ANNOUNCE A * HAS BEEN SEEN SPECIALLY
	JRST	GETSX1			;MUST SEE A DELIMITER NEXT

ILSTAR:	OUTSTR	[ASCIZ/"*" must be delimited or quoted.
/]
	JRST	ILLEG1

ILLEG:	OUTSTR	[ASCIZ/Illegal character "/]
	CAIE	A,15
	OUTCHR A
	OUTSTR	[ASCIZ/" occurred in scan/]
	SKIPE	QMODE
	OUTSTR	[ASCIZ/ while in quote mode/]
	SETZM	QMODE
	OUTSTR	CRLF
ILLEG1:	CLRBFI
	SKIPE MASCOP	;if master copy
	SKIPN MASDAF	;skip if reading date in master copy
	JRST RESTAR
	JRST MASDAE	;don't restart whole program for bad date!

DEVSCN:	MOVE	A,SAVDEL		;GET BACK THE DELIMITER OF OLD COMMAND
	CAIE	A,12
	CAIN	A,ALTMOD
	POPJ	P,			;RETURN QUICK IF THERE IS NO MORE.
	PUSHJ	P,GETSIX		;GET SOME SIXBIT QUANTITY.
	MOVEM	B,MTDEV			;SAVE DEVICE NAME.
	CAIE	A,":"			;WAS THE DELIMITER A COLON?
	JRST	DEVSC1			;NO
	PUSHJ	P,GETSIX		;GET MORE
	JUMPN	B,SYNTAX		;EXPECT TO SEE NOTHING BUT A CRLF
DEVSC1:	MOVEM	A,SAVDEL		;SAVE DELIMITER NAME
	POPJ	P,

NUMCHR:	TRNN	FL,INDON
	INCHWL A			;READ A CHARACTER
	TRNE	FL,INDON
	PUSHJ	P,RINDIR		;
	ANDI	A,177			;STRIP OFF ANY BUCKY BITS
	POPJ P,

RDNUMB:	MOVEI B,0			;READ DECIMAL INTEGER
RDNUM0:	PUSHJ P,NUMCHR			;SKIP SPACES
	CAIE A,40
	CAIN A,11
	JRST RDNUM0
RDNUM1:	CAIL A,"0"
	CAILE A,"9"
	JRST RDNUM2
	IMULI B,12
	ADDI B,-"0"(A)
	PUSHJ P,NUMCHR
	JRST RDNUM1

RDNUM2:	CAIN A,12			;SKIP TO EOL
	POPJ P,
	PUSHJ P,NUMCHR
	JRST RDNUM2
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        subttl switch scanning stuff for pumpkin command	 ; SWTCH0 SWTCH SWTCH3 MASDA0 GOTMON GETYR REBILD EXYEAR SYSYR SLRET MASDAP HYPHEN MONSIX MMDDYY SIXNUM SIXNU1 SIXNU9 SIXTAP BADATE MASDAE MASDAT SIXTA1 SIXTA2 RRLDMP RRLDM2 SWRELD

;Check for a switch coming, namely, a tape/dump number or a date.
;If we find one, we return resulting info in B and skip.
;Otherwise, we take direct return.

;If we return a date, it is in the RH of B.
;If we return a tape number, it is in the LH of B.
;If we return a relative dump number, it is split into two parts, in LH/RH of B.

;(We no longer dispatch here from GETSIX -- SCAN now calls SWTCH explicitly
;wherever a switch can occur.  The slash char is now a DELIMiter in CHRTAB.
;Consequently, we don't return via XGET6A any more.)

;Here if char to scan may have been saved away.
;Skip returns if any switch seen.
SWTCH0:	SETZ A,			;get and clear
	EXCH A,SAVDEL		;  any old delimiter
	SKIPN A			;skip if have old delimiter
	PUSHJ P,NUMCHR		;read first char to scan
	PUSHJ P,SWTCH		;process any switch
	 SOS (P)		;didn't skip, so we won't
	MOVEM A,SAVDEL		;save delimiter
	JRST CPOPJ1

;Here with char to scan already in A.
;Skip returns if any switch seen.
SWTCH:	CAIE A,"/"
	POPJ P,			;direct return for no switch seen
	SKIPN SWITOK		;switches OK here?
	JRST ILLEG		;no
SWTCH3:	AOS (P)			;skip to flag switch seen, return value in B
MASDA0:	TLO FL,L.SWIT		;allow hyphen now
	PUSH P,C			;ALSO SAVE BPT TO B
	PUSHJ P,GETSIX			;READ TAPE NUMBER OR BEG OF DATE
	JUMPL B,SIXTAP			;STARTS WITH LETTER, BETTER BE P OR T
	SKIPE MASCOP		;if this is master tape copy,
	SKIPE MASDAF		; then we better be reading a date
	CAIA			;OK
	JRST ILLSW2		;date is illegal in master tape copy cmd line
	SETZM YEAR			;ASSUME THIS YEAR BY DEFAULT
	CAIN A,"/"			;DATE, IS IT /MM/DD/YY?
	JRST MMDDYY			;YES
	CAIE A,"-"			;NO, IS IT /DD-MON-YY?
	JRST SWRELD			;maybe just relative dump number
	PUSHJ P,SIXNUM			;CONVERT SIXBIT DIGITS TO NUMERIC DAY
	CAILE C,37
	JRST BADATE			;FUNNY CALENDAR YOU GOT THERE
	MOVEM C,DAY
	PUSHJ P,GETSIX			;READ MONTH NAME
	JUMPGE B,[	PUSHJ P,SIXNUM	;MONTH NUMBER IS OK TOO
			SOJA C,GOTMON ]	;S/HE TYPED JAN=1, WE WANT JAN=0
	HLLZS B				;IGNORE CHARS PAST THIRD
	MOVSI D,-NMOS			;NUMBER OF MONTHS
	CAME B,MONSIX(D)		;FIND MONTH IN TABLE
	AOBJN D,.-1
	JUMPGE D,BADATE			;NO SUCH MONTH
	MOVEI C,(D)			;JAN=0
GOTMON:	CAILE C,14
	JRST BADATE
	MOVEM C,MONTH
	CAIE A,"-"
	JRST REBILD			;PUT THE DATE TOGETHER AGAIN
GETYR:	TLZ FL,L.SWIT			;NO LONGER INSIDE A SWITCH
	PUSHJ P,GETSIX			;EXPLICIT YEAR
	JUMPL B,BADATE			;ALPHABETIC YEAR?
	PUSHJ P,SIXNUM
	MOVEM C,YEAR
REBILD:	SKIPE B,YEAR			;PUT THE DATE TOGETHER
	JRST EXYEAR			;EXPLICIT YEAR
	SKIPE MASCOP		;must have explicit year if master copy
	JRST MASDAE		;bad date in master tape copy
	DATE B,				;WHAT YEAR IS THIS PLEASE?
	IDIVI B,14*37
	JRST SYSYR			;SYSTEM FORMAT YEAR

EXYEAR:	SUBI B,100			;HUMAN TYPED YEAR, SUBTRACT OFFSET
	CAILE B,1750			;MAYBE 4-DIGIT YEAR? (1750 := =1000)
	SUBI B,3554			;IF SO, FIX IT (=1900)
	JUMPL B,BADATE			;RIDICULOUS YEAR
SYSYR:	IMULI B,14
	ADD B,MONTH
	IMULI B,37
	ADD B,DAY
	MOVEI B,-1(B)			;WE WANT 1=0
SLRET:	POP P,C
	TLZ FL,L.SWIT
	SKIPN MASDAF
	POPJ P,			;not master copy or not date being returned in B
	SETZM MASDAF		;no longer reading date in master copy
	SKIPN MASCOP		;special check if master tape copy
	POPJ P,			;return datum in B (should never be here)
	CAMG B,TODAYD		;should not be in future
	JRST MASDAP		;OK, check against previous tape's date, if any
	OUTSTR [ASCIZ/That date is in the future!  Are you a time traveler?
/]
	JRST MASDAE

MASDAP:	SKIPE A,PRDATE		;skip if no previous date
	CAIL B,(A)		;date better not go backwards
	POPJ P,			;OK
	OUTSTR [ASCIZ/Impossible -- your date is earlier than the last tape's date.
/]
	JRST MASDAE

HYPHEN:	TLNN FL,L.SWIT
	JRST ILLEG			;HYPHEN ILLEGAL OUTSIDE SWITCH
	POPJ P,				;DELIMITER INSIDE ONE

MONSIX:	'JAN',,0
	'FEB',,0
	'MAR',,0
	'APR',,0
	'MAY',,0
	'JUN',,0
	'JUL',,0
	'AUG',,0
	'SEP',,0
	'OCT',,0
	'NOV',,0
	'DEC',,0
SDEF(NMOS,<.-MONSIX>)			;NEW SEMICONDUCTOR TECHNOLOGY

MMDDYY:	SKIPE MASCOP
	JRST MASDAE		;bad date in master tape copy
	PUSHJ P,SIXNUM			;THIS IS THE MONTH IN B
	CAILE C,14
	JRST BADATE
	SUBI C,1			;JAN=0 PLEASE
	MOVEM C,MONTH
	PUSHJ P,GETSIX			;NOW READ THE DAY
	JUMPL B,BADATE			;MUST BE NUMBER
	PUSHJ P,SIXNUM
	CAILE C,37
	JRST BADATE
	MOVEM C,DAY
	CAIE A,"/"
	JRST REBILD			;IMPLICIT YEAR
	JRST GETYR			;EXPLICIT YEAR

SIXNUM:	PUSH P,A			;SAVE DELIMITER
	MOVEI C,0			;ACCUMULATE NUMBER HERE
	MOVE D,[POINT 6,B]
SIXNU1:	ILDB A,D			;GET NEXT CHAR FROM B
	JUMPE A,SIXNU9			;DONE WHEN NO MORE CHARS
	CAIL A,'0'
	CAILE A,'9'
	JRST BADATE			;NONDIGIT NOT ALLOWED
	IMULI C,12
	ADDI C,-'0'(A)
	JRST SIXNU1			;IF 6 CHARS IN B, NO PROBLEM, C LH 0

SIXNU9:	POP P,A
	POPJ P,

;Here if switch starts with letter, not number
SIXTAP:	MOVEI C,0			;/Pn OR /Tn
	ROTC B,6			;GET INITIAL LETTER IN C
	CAIN C,'P'			;WHICH?
	TDZA C,C			;C=0 FLAGS P
	CAIN C,'T'
	JRST SIXTA1
BADATE:	SKIPE MASCOP
	JRST MASDAE		;for master tape copy, ask again
	OUTSTR [ASCIZ Switch format is /Pnnn or /Tnnn for a specific tape, or
/mm/dd or /mm/dd/yy or /dd-mon or /dd-mon-yy for a date.
]
	JRST RESTAR

;Here if bad date given in master tape copy, give some help on format.
MASDAE:	CLRBFI		;flush input
	SKIPN P,MASDAF	;restore stack (don't restore C), skip if reading date
	JRST ILLSWT	;abort command via RESTART (no stack ptr needed)
	OUTSTR [ASCIZ /Date must be in this form:  1-Jan-64
/]
;Enter here for master copy to get tape's date from operator, return date in B.
;Asks again in case of error in date entry.
MASDAT:	OUTSTR [ASCIZ /Enter the date on which this tape was written: /]
	MOVEM P,MASDAF	;flag that we're reading date, save stack ptr
	JRST MASDA0

;Here if have seen /P or /T, expect tape number to follow.
SIXTA1:	PUSH P,C			;SAVE P/T FLAG
	PUSHJ P,SIXNUM			;MAKE TAPE NUMBER BINARY
	POP P,B				;RESTORE FLAG
	JUMPE B,SIXTA2			;JUMP IF P TAPE
	SKIPE MASCOP
	JRST MASDAE		;master tape copy -- /T12 not allowed in MCOPY
	TRO C,400000			;FLAG T TAPE
SIXTA2:	MOVSI B,(C)		;return tape number in LH of B
	CAIN A,"/"
	PUSHJ P,RRLDMP		;put relative dump number (e.g., /3) into B
	CAIN A,"-"
	JRST BADATE			;SAY WHAT?
	JRST SLRET

;Read relative dump number and stuff it into high and low dump number fields in B.
RRLDMP:	PUSH P,B		;preserve tape number
	SKIPE MASCOP
	JRST ILLSW2		;relative dump number not valid in master copy cmd
	PUSHJ P,GETSIX		;get dump number into sixbit in B
	PUSHJ P,SIXNUM		;convert to binary from sixbit
	POP P,B
RRLDM2:	DPB C,[POINT RDLBTS,B,RDLPOS] ;insert low bits of dump number
	LSH C,-RDLBTS		;shift out the low bits
	DPB C,[POINT RDHBTS,B,RDHPOS] ;insert high bits of dump number
	POPJ P,

;Here if looks like we have only a relative dump number.
;This is meaningful only for DUMP and RESTORE commands.
SWRELD:	SKIPE MASCOP
	JRST MASDAE		;bad date in master tape copy
	SKIPL SWITOK		;skip if rel dump number switch OK for this cmd
	JRST SYNTAX		;illegal format switch for this command
	PUSHJ P,SIXNUM		;convert to binary from sixbit dump number
	MOVEI B,0		;no tape number
	PUSHJ P,RRLDM2		;put rel dump nbr into B
	JRST SLRET		;return from switch processing
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               subttl	character table for command processing	 ; CHRTAB

;Left half is quote-mode dispatch, right half is normal dispatch address.
;See GETSIX.
CHRTAB:	GETSX1,,GETSX1		;NULL
	QSET,,QSET		;CTRL A = DOWN ARROW. SETS QUOTE MODE
	ILLEG,,ILLEG		;2
	ILLEG,,ILLEG		;3
	ILLEG,,ILLEG		;4
	ILLEG,,ILLEG		;5
	ILLEG,,ILLEG		;6
	ILLEG,,ILLEG		;7
	ILLEG,,ILLEG		;10
	ILLEG,,BLANK		;11
	ILLEG,,DELIM		;12
	ILLEG,,ILLEG		;13
	ILLEG,,MAKLF		;14 INVENT LF FOR FF
	ILLEG,,GETSX1		;15 IGNORE
	ILLEG,,ILLEG		;16
	ILLEG,,ILLEG		;17
REPEAT 33-20,<ILLEG,,ILLEG>	;20-32 ARE ALL ILLEGAL
	ILLEG,,DELIM		;33 DEC ALTMODE
REPEAT 40-34,<ILLEG,,ILLEG>
	GETSX3,,BLANK		;40 BLANK IS A DELIMITER
	GETSX3,,ILLEG		;41 !
	GETSX3,,ILLEG		;42 "
	GETSX3,,ILLEG		;43 #
	GETSX3,,GETSX3		;44 $ LEGAL IN FILE NAMES
	GETSX3,,ILLEG		;45 %
	GETSX3,,ILLEG		;46 &
	GETSX3,,ILLEG		;47 '
	GETSX3,,ILLEG		;50 (
	GETSX3,,ILLEG		;51 )
	GETSX3,,STAR		;52 *
	GETSX3,,ILLEG		;53 +
	GETSX3,,DELIM		;54 , COMMA
	GETSX3,,HYPHEN		;55 -
	GETSX3,,DELIM		;56 . PERIOD
	GETSX3,,DELIM		;57 / (formerly ,,SLASH)
REPEAT 72-60,<GETSX3,,GETSX3>	;60-71 (0-9) ARE LEGAL
	GETSX3,,DELIM		;72 : 
	GETSX3,,SEMICO		;73 ;
	GETSX3,,ILLEG		;74 <
	GETSX3,,ILLEG		;75 =
	GETSX3,,ILLEG		;76 >
	GETSX3,,ILLEG		;77 ?
	GETSX3,,DELIM		;100 @
REPEAT 133-101,<GETSX3,,GETSX3>	;101-132 (A-Z) ARE LEGAL
	GETSX3,,DELIM		;133 [
	GETSX3,,ILLEG		;134 \
	GETSX3,,ILLEG		;135 ]
	GETSX3,,ILLEG		;136 ^
	GETSX3,,DELIM		;137 _
	ILLEG,,ILLEG		;140 `
REPEAT 173-141,<GETSX2,,GETSX2>	;141-172 (a-z) ARE LEGAL AND ALWAYS CONVERTED
	ILLEG,,ILLEG		;173
	ILLEG,,ILLEG		;174
	ILLEG,,DELIM		;175
	ILLEG,,ILLEG		;176
	ILLEG,,ILLEG		;177
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        subttl	read a ppn	 ; RDPPN RDPPN1 RDPPN2 OCTPPN OCTPP1 SIXPP1 SIXPPN RDPPN9 RDPPN9 RDPPN3 RDPPN4 DPOPJ RDPPN5

;READ A PPN FROM TTY OR INDIRECT FILE.
;CALLING:
;		MOVE	A,<LAST CHARACTER READ>
;		PUSHJ	P,RDPPN
;		<RETURN HERE> 
;CLOBBERS C, RETURNS PPN IN B, DELIMITER IN A, FLAGS IN FL.


RDPPN:	MOVEI	B,0
	TRZ	FL,ALLFLG
	CAIE	A,"["			;WILL THERE BE A PPN?
	POPJ	P,			;NO. RETURN ZERO.
	PUSHJ	P,RDPPN1		;READ PRJ
	TRZE	FL,ALLFLG
	TRO	FL,ALLPRJ
	HRLZ	B,C
	CAIE	A,","
	JRST	ILLPPN			;DELIMITER MUST BE ,
	PUSHJ	P,RDPPN1		;READ PRG
	TRZE	FL,ALLFLG
	TRO	FL,ALLPRG
	HRR	B,C
	PUSH	P,B			;SAVE B
	MOVEI	B,0
	CAIN	A,"]"			;IF DELIMITER IS "]" THEN
	PUSHJ	P,GETSIX		; GET ANOTHER BARE DELIMITER
	JUMPN	B,SYNTAX
	POP	P,B
	POPJ	P,

RDPPN1:	PUSH	P,D
	SETZB	C,D
IFN IRCPPN,<
	PUSH P,B
	MOVEI B,0
>;IFN IRCPPN
RDPPN2:	TRNE	FL,INDON		;READING @ FILE?
	PUSHJ	P,RINDIR		;YES.
	TRNN	FL,INDON		;READING TTY?
	INCHRW A			;YES.
	CAIN	A,15
	JRST	RDPPN2			;FLUSH CR (LF WILL FOLLOW)
	CAIE	A," "
	CAIN	A,11
	JUMPE	C,RDPPN2		;FLUSH LEADING BLANKS AND TABS
	CAIN	A,"*"
	JRST	RDPPN5

IFE IRCPPN,<
IFE STANSW,<
	CAIL	A,"0"			;ELSEWHERE, ONLY DIGITS ARE LEGAL
	CAIL	A,"0"+PPNDIV
	JRST	RDPPN3
>;IFE STANSW
>;IFE IRCPPN

IFN IRCPPN,<
	JUMPN B,(B)		;IF NOT FIRST CHAR, DISPATCH ON TYPE
	CAIL A,"0"
	CAILE A,"7"
	JRST SIXPP1		;ELSE FIGURE OUT TYPE
	MOVEI B,OCTPPN
	JRST OCTPP1

OCTPPN:	CAIL A,"0"
	CAILE A,"7"
	JRST RDPPN3
OCTPP1:	LSH C,3
	ADDI C,-"0"(A)
	AOJA D,RDPPN2

SIXPP1:	MOVEI B,SIXPPN
SIXPPN:
>;IFN IRCPPN

IFN STANSW!IRCPPN,<
	CAIL	A,"0"		;AT STANFORD, LETTERS, DIGITS AND
	CAILE	A,"9"		;LOWER CASE LETTERS ARE LEGAL
	CAIA
	JRST	RDPPN9		;LEGAL DIGIT
	CAIL	A,"A"
	CAILE	A,"Z"
	CAIA
	JRST	RDPPN9		;LEGAL UPPER CASE
	CAIL	A,"A"+40
	CAILE	A,"Z"+40
	JRST	RDPPN3		;ILLEGAL
	TRZ	A,40		;TURN OFF LOWERCASE BIT
>;IFN STANSW!IRCPPN

IFE IRCPPN,<
RDPPN9:	IMULI	C,PPNDIV
	ADDI	C,-PPNADD(A)
	AOJA	D,RDPPN2		;COUNT CHARACTERS SEEN
>;IFE IRCPPN
IFN IRCPPN,<
RDPPN9:	LSH C,6
	ADDI C,-40(A)
	AOJA D,RDPPN2
>;IFN IRCPPN

RDPPN3:	TRNE	FL,ALLFLG
	JRST	RDPPN4
	TLNN	C,-1			;NO BITS SHOULD BET SET IN THE LEFT
	JUMPN	C,DPOPJ			;BUT SOMETHING SHOULD BE SET.
	JRST	ILLPPN

RDPPN4:	JUMPN	C,ILLPPN		;* SEEN. MUST BE ALONE
DPOPJ:
IFN IRCPPN,<
	TRZ C,400000			;SILLY IRCAM FORMAT
	POP P,B
>;IFN IRCPPN
	POP	P,D
	POPJ	P,

RDPPN5:	JUMPN	D,ILLPPN		;* SEEN. MUST BE FIRST
	TRON	FL,ALLFLG		;SET * SEEN.  MUSTN'T SEE ANYTHING ELSE
	JRST	RDPPN2			;LOOP TO DELIMITER
	JRST	ILLPPN

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             subttl	get FS block	 ; GETBLK GETBK1 PGTBLK PGTBK1 TGTBLK TGTBK1

GETBLK:	MOVEI	A,FSLEN			;GET A TERM BLOCK
	ADDB	A,FSPTR			;INCREMENT POINTER TO THE FREE BLOCK
	CAMG	A,.JBREL
	JRST	GETBK1
	CORE	A,
	 JRST	NOCORE
	MOVE	A,FSPTR
GETBK1:	MOVSI	R,-FSLEN(A)
	HRRI	R,1-FSLEN(A)
	SETZM	-FSLEN(A)
	BLT	R,-1(A)
	MOVEI	R,-FSLEN(A)
	POPJ	P,

PGTBLK:	MOVEI	A,FSPLEN		;GET A TERM BLOCK
	ADDB	A,W			;INCREMENT POINTER TO THE FREE BLOCK
	CAMG	A,.JBREL
	JRST	PGTBK1
	CORE	A,
	 JRST	NOCORE
	MOVE	A,W
PGTBK1:	MOVSI	R,-FSPLEN(A)
	HRRI	R,1-FSPLEN(A)
	SETZM	-FSPLEN(A)
	BLT	R,-1(A)
	MOVEI	R,-FSPLEN(A)
	POPJ	P,

TGTBLK:	MOVEI	A,3			;GET A TAPE BLOCK for PRESTORE/PLIST/UNPUMP
	ADDB	A,W			;INCREMENT POINTER TO THE FREE BLOCK
	CAMG	A,.JBREL
	JRST	TGTBK1
	CORE	A,
	 JRST	NOCORE
	MOVE	A,W
TGTBK1:	MOVSI	R,-3(A)
	HRRI	R,1-3(A)
	SETZM	-3(A)
	BLT	R,-1(A)
	MOVEI	R,-3(A)
	POPJ	P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                subttl	scan dump, restore, locate, pumpkin commands	 ; SCAN SCAN1 SCAN2 SCAN4 SCAN4A SCAN4B SCAN7 SCAN8

COMMENT $
DUMP {<DEST>_~<SOURCE>
RESTORE {<DEST>_~<SOURCE>

<DEST>  	{DEV:~{<FILNAM>{.<EXT>~~{[<PRJ>,<PRG>]~

<SOURCE>  {{DEV:~{[<PRJ>,<PRG>]~@~{DEV:~{<FILNAM>{.<EXT>~{[<PRJ>,<PRG>]~{,<SOURCE>~

$

SCAN:	SETZM	DEST			;LOCATION OF DESTINATION TERM
	MOVE	R,.JBFF
	MOVEM	R,FSPTR			;INITIALIZE FREE STORAGE POINTER
	MOVEM	R,TBASE			;SAVE BASE OF ALL TERMS.
	PUSHJ	P,GETBLK		;GET AN FSBLOCK. ADDRESS IN R.
	PUSHJ P,SWTCH0		;look for switches, skip if find tape or date
	 MOVEI B,0		;no global tape or date yet
	MOVEM B,GLOTAP		;save tape number, dump number, or date
	TRZ	FL,ALLMSK+INDEOF+INDON	;CLEAR WILD & INDIRECT COMMAND FLAGS
	PUSHJ	P,XGET6			;SCAN FOR A DESTINATION
	CAIE	A,":"			;IS THERE A DEVICE?
	JRST	SCAN1			;NO STRANGE DEVICE HERE.
	TRNE	FL,ALLFLG		;WILD DEVICE?
	JRST	ALLDEV			;YES. CAN'T DO THAT
	MOVEM	B,FSDEV(R)		;SAVE DEVICE NAME
	PUSHJ	P,GETSIX		;GET MORE
SCAN1:	MOVEM	B,FSNAM(R)		;SAVE THE FILE NAME
	TRNE	FL,ALLFLG		;WILD?
	TRO	FL,ALLFIL		;YES. SET BIT
	SETZM GOTDOT		;no dot seen yet
	CAIE	A,"."			;IS THERE AN EXTENSION TO SCAN?
	JRST	SCAN2			;NO.
	SETOM GOTDOT		;saw a dot, explicit extension
	PUSHJ	P,GETSIX
	HLLZM	B,FSEXT(R)		;SAVE IT
	TRNE	FL,ALLFLG		;WILD?
	TRO	FL,ALLEXT		;YES. SET BIT
SCAN2:	PUSHJ	P,RDPPN			;READ PPN IF ANY
	MOVEM	B,FSPPN(R)		;STORE IT.
	MOVEI	B,ALLMSK		;GET THE MASK
	AND	B,FL			;AND IN THE FLAGS
	SKIPE GOTDOT		;skip unless saw real extension (possibly wild)
	IORI B,GOTEXT		;flag explicit extension seen
	HRRM	B,FSEXT(R)		;SAVE THE WILD BITS
	PUSHJ P,SWTCH		;look for switches, skip if find tape or date
	 MOVE B,GLOTAP		;use any global info
	MOVEM B,FSTAP(R)	;save tape number, dump number, or date
	CAIE	A,"_"			;WAS THIS ALL REALLY THE DESTINATION?
	JRST	SCAN7			;NO. THERE IS NO EXPLICIT DESTINATION TERM
	MOVEM B,GLOTAP		;any tape or date in dest is global
	MOVEM	R,DEST			;SAVE ADDRESS OF DESTINATION BLOCK
	MOVE	R,FSPTR			;GET THE CURRENT FREE POINTER
	MOVEM	R,TBASE			;SOURCE TERMS START HERE.

SCAN4:	PUSHJ	P,GETBLK		;GET A BLOCK
	TRZ	FL,ALLMSK		;ZERO FLAGS
	PUSHJ	P,GETSIX		;GET A SIXBIT TERM.
	CAIE	A,":"			;IS THIS A DEVICE?
	JRST	SCAN4A			;NOT DEVICE
	MOVEM	B,FSDEV(R)		;SAVE DEVICE NAME
	TRNE	FL,ALLFLG		;WILD?
	JRST	ALLDEV			;YES: DEVICE * IS ILLEGAL.
	PUSHJ	P,GETSIX		;GET MORE!
SCAN4A:	MOVEM	B,FSNAM(R)		;SAVE FILENAME
	TRNE	FL,ALLFLG		;WILD NAME?
	TRO	FL,ALLFIL		;YES. SET BIT
	SETZM GOTDOT		;no dot seen yet
	CAIE	A,"."			;WILL THERE BE AN EXTENSION?
	JRST	SCAN4B			;NO.
	SETOM GOTDOT		;saw a dot, explicit extension
	PUSHJ	P,GETSIX		;GET THE EXTENSION
	HLLZM	B,FSEXT(R)		;SAVE IT
	TRNE	FL,ALLFLG		;WILD?
	TRO	FL,ALLEXT		;YES.
SCAN4B:	PUSHJ	P,RDPPN			;READ PPN IF ANY
	MOVEM	B,FSPPN(R)		;STORE IT
	MOVEI	B,ALLMSK
	AND	B,FL
	SKIPE GOTDOT		;skip unless saw real extension (possibly wild)
	IORI B,GOTEXT		;flag explicit extension seen
	HRRM	B,FSEXT(R)		;SAVE WILD FLAGS
	PUSHJ P,SWTCH		;look for switches, skip if find tape or date
	 MOVE B,GLOTAP		;use any global info
	MOVEM B,FSTAP(R)	;save tape number, dump number, or date
SCAN7:	SKIPN	FSDEV(R)
	SKIPE	FSNAM(R)
	JRST	SCAN8
	SKIPN	FSEXT(R)
	SKIPE	FSPPN(R)
	JRST	SCAN8
	SKIPE MASCOP		;master copy only allows a single tape number
	SKIPN B,GLOTAP
	CAIA
	CAMN B,FSTAP(R)		;same tape?
	CAIA			;yes
	JRST ILLMT2		;no, complain
	SKIPE B,FSTAP(R)	;maybe all we saw was a switch
	MOVEM B,GLOTAP		;if so, make it new sticky global value
	MOVEM	R,FSPTR			;RECLAIM STORAGE FROM NULL TERM
SCAN8:	CAIE	A,12			;LF?
	CAIN	A,ALTMOD		;OR ALTMODE
	POPJ	P,			;LF OR ALTMODE - TERMINATE SCAN.

	CAIN	A,","			;COMMA?
	JRST	SCAN4			;YES. FIND NEXT SOURCE TERM

	CAIN	A,"@"			;INDIRECTION.
	JRST	MSCAN			;OFF TO INDIRECT FILE
	JRST	SYNTAX			;SYNTAX ERROR. TERM ENDS
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        subttl	more scan - indirect commands.	 ; MSCAN MSCAN1 SCAN8A SCAN8B SCAN8C SCAN8D SCAN9 SCAN9A SCAN9B SCAN9D SCAN9E SCAN9F SCAN9G INDFLU INDFL1 INDFL2 SCAN10

MSCAN:	MOVEM	R,FSPTR			;RESET FREE STORAGE
	SKIPE	A,FSDEV(R)		;GET DEVICE
	MOVEM	A,DEFDEV		;SAVE DEFAULT DEVICE
	SKIPE	A,FSPPN(R)		;GET PPN
	MOVEM	A,DEFPPN		;SAVE PPN FOR THE REST OF COMMAND
	SKIPN	FSNAM(R)		;SKIP IF NAME PRESENT
	SKIPE	FSEXT(R)		;NO NAME. SKIP IF NO EXTENSION
	JRST	SYNTAX			;ATTEMPT TO SET STICKY NAME OR EXT
MSCAN1:	SETZM	IDEV			;ZERO BLOCK FOR THE INDIRECT FILE
	MOVE	A,[IDEV,,IDEV+1]
	BLT	A,IPPN
	PUSHJ	P,GETSIX
	CAIE	A,":"
	JRST	SCAN8A
	MOVEM	B,IDEV
	TRNE	FL,ALLFLG
	JRST	ALLDEV
	PUSHJ	P,GETSIX
SCAN8A:	MOVEM	B,INAM
	TRNE	FL,ALLFLG
	JRST	ALLIND			;CAN'T DO * IN INDIRECT NAME
	CAIE	A,"."			;PERIOD
	JRST	SCAN8B
	PUSHJ	P,GETSIX
	HLLZM	B,IEXT
	TRNE	FL,ALLFLG
	JRST	ALLIND			;CAN'T DO * IN INDIRECT EXTENSION
SCAN8B:	PUSHJ	P,RDPPN			;READ PPN IF ANY.
	MOVEM	B,IPPN			;STUFF IT.
	TRNE	FL,ALLPRJ+ALLPRG
	JRST	ALLIND			;ERROR IF [*,*] IN INDIRECT FILE NAME
SCAN8C:	CAIE	A,12
	CAIN	A,ALTMOD
	JRST	SCAN8D
	CAIE	A,","
	JRST	SYNTAX			;ERROR UNLESS COMMA, LF,ALTMODE
SCAN8D:	MOVEM	A,SAVDEL		;SAVE THE DELIMITER.
	MOVEI	A,0			;OPEN @ FILE IN ASCII MODE
	SKIPN	B,IDEV			;GET THE DEVICE
	MOVSI	B,'DSK'			;DEFAULT DEVICE IS DISK
	MOVEI	C,INDRBF		;INDIRECT BUFFER.
	OPEN	INDIR,A			;OPEN THE DEVICE.
	PUSHJ	P,NODEV			;DEVICE CAN'T BE OPENED.
	MOVEI	A,ALTBUF		;RECYCLE MAGTAPE BUFFERS FOR OUR USE
	EXCH	A,.JBFF
	INBUF	INDIR,2			;THESE BETTER FIT
	MOVEM	A,.JBFF			;RESTORE .JBFF
	MOVE	A,INAM
	MOVE	B,IEXT
	SETZ	C,
	SKIPN	D,IPPN
	MOVE	D,USRPPN
	MOVEM	D,IPPN
	LOOKUP	INDIR,A
	JRST	NOLOOK

	OUTSTR	[ASCIZ/(Reading /]	;TELL USER WHERE WE ARE
	MOVE	A,INAM
	HLLZ	B,IEXT
	MOVE	D,IPPN
	PUSHJ	P,TYFIL			;TYPE A FILE NAME
	OUTSTR	[ASCIZ/) /]

	TRZ	FL,INDEOF		;TURN OFF EOF.
	TRO	FL,INDON		;TURN ON INDIRECT COMMAND BIT
SCAN9:	PUSHJ	P,GETBLK		;GET A BLOCK
	TRZ	FL,ALLMSK		;ZERO FLAGS
	PUSHJ	P,GETSIX		;GET A SIXBIT TERM.
	CAIE	A,":"			;IS THIS A DEVICE?
	JRST	SCAN9A			;NOT DEVICE
	MOVEM	B,FSDEV(R)		;SAVE DEVICE NAME
	TRNE	FL,ALLFLG		;WILD?
	JRST	ALLDEV			;YES: DEVICE * IS ILLEGAL.
	PUSHJ	P,GETSIX		;GET MORE!
SCAN9A:	MOVEM	B,FSNAM(R)		;SAVE FILENAME
	TRNE	FL,ALLFLG		;WILD NAME?
	TRO	FL,ALLFIL		;YES. SET BIT
	SETZM GOTDOT		;no dot seen yet
	CAIE	A,"."			;WILL THERE BE AN EXTENSION?
	JRST	SCAN9B			;NO.
	SETOM GOTDOT		;saw a dot, explicit extension
	PUSHJ	P,GETSIX		;GET THE EXTENSION
	HLLZM	B,FSEXT(R)		;SAVE IT
	TRNE	FL,ALLFLG		;WILD?
	TRO	FL,ALLEXT		;YES.
SCAN9B:	PUSHJ	P,RDPPN			;SCAN PPN IF ANY
	MOVEM	B,FSPPN(R)		;SAVE IT
	MOVEI	B,ALLMSK
	AND	B,FL
	SKIPE GOTDOT		;skip unless saw real extension (possibly wild)
	IORI B,GOTEXT		;flag explicit extension seen
	HRRM	B,FSEXT(R)		;SAVE WILD FLAGS

	SKIPN	FSNAM(R)
	SKIPE	FSEXT(R)
	JRST	SCAN9D
	SKIPN	FSDEV(R)
	SKIPE	FSPPN(R)
	JRST	SCAN9D
	MOVEM	R,FSPTR			;FLUSH NULL TERMS
	JRST	SCAN9F			;FLUSH

SCAN9D:	SKIPN	B,FSPPN(R)		;SKIP IF EXPLICIT PPN
	TRNE	FL,ALLPRJ+ALLPRG	;NOT EXPLICIT. WAS IT WILD?
	JRST	SCAN9E			;WILD PPN OR EXPLICIT PPN
	MOVE	B,DEFPPN		;GET THE DEFAULT PPN SET BEFORE.
	MOVEM	B,FSPPN(R)		;SAVE IT
SCAN9E:	SKIPN	B,FSDEV(R)		;EXPLICIT DEVICE?
	MOVE	B,DEFDEV		;NO. USE DEFAULT
	MOVEM	B,FSDEV(R)		;SAVE IT BACK AGAIN
SCAN9F:	CAIN	A,","			;COMMA?
	JRST	SCAN9			;GOBBLE ANOTHER TERM
	CAIN	A,"@"			;INDIRECTION AGAIN?
	JRST	SCAN10			;YES.
	CAIE	A,ALTMOD		;ALTMODE IN FILE OR
	TRNE	FL,INDEOF		;END OF FILE YET?
	JRST	SCAN9G			;YES. FORCE THE RETURN UPLEVEL
	CAIN	A,12			;LF?
	JRST	SCAN9			;YES. CONTINUE UNTIL EOF.

SCAN9G:	MOVE	A,SAVDEL
	TRNE	FL,INDEOF		;Closing because of end of file?
	OUTSTR	[ASCIZ/(Eof on @ file)/]
	TRNN	FL,INDEOF		;
	PUSHJ	P,INDFLU		;type rejected parts of @ file
	OUTSTR	[ASCIZ/ (Closing @ file)
/]
	TRZ	FL,INDEOF+INDON
	CLOSE	INDIR,
	RELEAS	INDIR,
	JRST	SCAN8

INDFLU:	OUTSTR	[ASCIZ/
The remainder of this command file has been rejected.
The rejected text is

/]
INDFL1:	PUSHJ	P,RINDIR
	TRNE	FL,INDEOF
	JRST	INDFL2
	OUTCHR	A
	JRST	INDFL1

INDFL2:	OUTSTR	CRLF
	POPJ	P,

SCAN10:	SKIPN	FSDEV(R)
	SKIPE	FSNAM(R)
	JRST	SYNTAX
	SKIPN	FSEXT(R)
	SKIPE	FSPPN(R)
	JRST	SYNTAX
	OUTSTR	[ASCIZ/ (File switch)
/]
	JRST	MSCAN1			;DONT CHANGE DEFAULT DEVICE,PPN
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      subttl	documentation for system dumps ;

COMMENT	$	SYSTEM CLASS DUMPS.

	INITIALIZE
DEVSEL--SELECT THE NEXT FILE STRUCTURE TO DUMP
	READ THE MFD FROM THAT STRUCTURE AND SORT IT
GETUFD--LOOKUP A UFD FROM THE SORTED LIST
GETFIL--LOOKUP	EACH FILE TO SEE IF IT SHOULD BE DUMPED
	FOR EACH FILE, ADD AN ENTRY TO THE SNAPSHOT DIRECTORY
	IF A FILE MUST BE DUMPED, DO SO. RENAME IT WITH A NEW DUMP DATE.
	LOOP TO GETFIL
	WHEN UFD IS FINISHED, CLOSE THE MAGTAPE AND LOOP TO GETUFD
	WHEN MFD IS DONE, LOOP TO DEVSEL.

FILES THAT GET WRITTEN TO HELP US FIND THINGS LATER, FIND THINGS NOW?

ON CURRENT STRUCTURE IN [DUMPER] AREA:
ALLDIR.DAT	DIRECTORY OF ALL FILES ON THE STRUCTURE WITH THE TAPE NUMBER
		WHERE THEY WERE DUMPED LAST.
DART.DAT	MERGE OF PREVIOUS DART.DAT AND CURRENT P0000N.DAT AT END OF
		EACH TAPE. AND AT END OF EACH STRUCTURE.

ON DSK IN [DUMPER] AREA
ALLDIR.MEM	TEMPORARY VERSION OF ALLDIR.DAT, WITH DATE WRITTEN
		INFORMATION ADDED FOR EACH FILE DUMPED IN THIS DUMP.
DTAPES.DAT	CONTAINS WHERE DUMPED AND WHEN WRITTEN FOR ALL FILES
		ON ALL TAPES IN THIS DUMP. (CREATED FROM ALLDIR.MEM BY SPLIT.)
DART.MEM	REMEMBER CURRENT COMMAND, TAPE NUMBER, DUMP PHASE.
DART.TAP	NUMBERS OF THE TAPES THAT HAVE BEEN USED THUS FAR.



Various phases of a system class dump:

I. Dump phase
	DART.MEM	created at beginning of dump, holds current command,
			tape number, dump phase.
	ALLDIR.MEM	created at beginning of dump, holds list of all files
			scanned so far in the dump, with (1) for each such
			file, the number of the last tape the file is on
			(in RH of ext word, with 400000 bit on if T tape)
			and (2) the date written of the file iff it is
			being dumped in this dump; the 200000 bit is on in
			the RH of the ext word iff there is a date word
			following (i.e., iff the file is dumped in this dump).
	DART.TAP	permanent file, contains last P- and last T-tape
			numbers used.  This file is two words long.
			

II. SPLIT phase
	ALLDIR.MEM	read in (was written in phase I).
	ALLDIR.DAT	created with subset of data from ALLDIR.MEM,
			namely, the list of all files in the world along
			with the last system tape each one appears on.
			Thus the 200000 bit is never on in the RH of the ext word.
	DTAPES.DAT	created with all the info from ALLDIR.MEM for each
			file dumped in this dump (tape and date words)
			(since date word is always present, we don't know if
			the 200000 bit is ever on).

III. Intermediate phase (code at DPIK2)
	ALLDIR.MEM	is deleted
	ALLDIR.DAT	is dumped at the end of this dump

IV. MERGE phase
	DART.DAT and DTAPES.DAT are merged into new DART.DAT, while
		creating Pnnnnn.LST (text list of files dumped in this dump).
	(No longer spools Pnnnnn.LST.)
	Then deletes DTAPES.DAT.

V. Final phase
	Deletes ALLDIR.OLD and then renames ALLDIR.OLD_ALLDIR.DAT.
	Finally deletes DART.MEM, which indicates that no dump is in progress.

$
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  subttl pickup dump after a system crash ; PICKUP NOPICK MCLOUT LOKOUT TBEGOK TABPIK PICKP1 PICKP3 PICKP2 PICPNT TABPNT

PICKUP:	SETOM PICKON		;SIGNAL WE ARE DOING A PICKUP.
	SETZM MASCOP		;not doing master tape copy
IFN FTCOPY,<
	PUSHJ P,MCONLY		;Don't attempt pickup -- doesn't return
>;IFN FTCOPY
	GETPPN A,
	CAME A,DUMPER
	JRST NOPRV		;THIS LOSER CAN'T DO A PICKUP.
	PUSHJ P,SDFTDN		;maybe select default density
	MOVEI A,17		;INIT THE DISK.
	MOVSI B,'DSK'
	MOVEI C,0
	OPEN DSKMEM,A
	 PUSHJ P,NODEV
	PUSHJ P,CHKLOK		;check for lockout file
	 JRST LOKOUT		;LOCKOUT FILE EXISTS, LOSE
	PUSHJ P,RDMEM		;read DART.MEM
	 JRST NOPICK		;no file
	 POPJ P,		;disk input error
	JRST PICKP1

NOPICK:	OUTSTR [ASCIZ/File not found. DSK:DART.MEM; we can't do a PICKUP.
/]
	RELEAS DSKMEM,
	POPJ P,

MCLOUT:	OUTSTR [ASCIZ/*** NO MCOPY TAPE COPYING TODAY, PLEASE! ***/]
	CAIA
LOKOUT:	OUTSTR [ASCIZ/*** DON'T DO A SYSTEM CLASS DUMP TODAY!!! ***/]
	OUTSTR [ASCIZ/
A wizard has declared the dump facility unusable.
Do not try to do a dump without getting help!
/]
IFN STANSW!IRCPPN,<
	MOVNI A,1
	BEEP A,
>;IFN STANSW!IRCPPN
	RELEAS DSKMEM,
	JRST RESTAR

TBEGOK__400000			;(must be sign bit) OK to be starting new tape in this pickup
TABPIK:		PICKP3		;0 - MIDDLE OF A DUMP - POSITION TAPE - GETUFD
		PICKP2		;1 - END OF STRUCTURE - DMPSTR
		PICKP3		;2 - END OF STRUCTURE - POSITION TAPE, dump ALLDIR.DAT - DMPSTR
		PICKP2		;3 - END OF STRUCTURE. - DMPSTR
		PICKP2		;4 - END OF REEL, need tape trailer - GFREDO
	TBEGOK,,PICKP2		;5 - END OF REEL. NEED REWIND. - GFREDO
		PICKP2		;6 - END OF REEL & STRUCTURE. - DMPSTR
SDEF(TABPLN,.-TABPIK)

PICKP1:	PUSHJ P,MTINIW		;Init magtape for writing
	PUSHJ P,REELM0		;PREPARE TAPE NAMES AND THINGS
	MOVEI A,17		;INIT THE DISK.
	MOVSI B,'DSK'
	MOVEI C,0
	OPEN DSKMSC,A
	 PUSHJ P,NODEV
	PUSHJ P,PICPNT		;print data about pickup
	HRRZ A,MEMSAV+CHKNUM	;GET CHECKPOINT CODE.
	CAIGE A,TABPLN
	JRST @TABPIK(A)
	OUTSTR [ASCIZ/Cannot interpret checkpoint number for PICKUP.
/]
	POPJ P,

PICKP3:	PUSHJ P,DOMOUNT		;REQUEST OPR TO MOUNT TAPE.
	PUSHJ P,FIXPOS		;FIX POSITION BY LAST THING WE REMEMBER.
IFN DBGSW,<
	SKIPN DBGNTP		;DON'T PLAY WITH TAPE IF NOT USING IT
>;IFN DBGSW
	PUSHJ P,MT2SKF		;SKIP FORWARD, using writing channel
	SETZM MEMSAV+MTQPOS	;WE REALLY KNOW WHERE TAPE IS (MOSTLY)
PICKP2:	MOVE A,MEMSAV+MSTRNA	;PICKUP STRUCTURE NAME.
	JRST STRPIK		;JUMP TO PICKUP INSIDE A STRUCTURE.


PICPNT:	MOVEI B,[ASCIZ/Pickup data follows:
Class /]
	PUSHJ P,STROUT
	MOVE A,CLASS
	PUSHJ P,DECOUT
	TRNE FL,PCLASS
	OUTSTR [ASCIZ/  Permanent  /]
	TRNE FL,FULL
	MOVEI B,[ASCIZ/  Full permanent  /]
	TRNN FL,PCLASS
	MOVEI B,[ASCIZ/  Temporary /]
	PUSHJ P,STROUT
	MOVEI B,[ASCIZ/
Checkpoint code: /]
	PUSHJ P,STROUT
	HRRZ A,MEMSAV+CHKNUM	;GET CHECKPOINT CODE.
	PUSHJ P,DECOUT
	HRRZ A,MEMSAV+CHKNUM	;GET CHECKPOINT CODE.
	CAIL A,TABPLN
	POPJ P,			;return quick.  an error is coming
	MOVE B,TABPNT(A)
	PUSHJ P,STROUT
	MOVEI B,CRLF
	PUSHJ P,STROUT
	POPJ P,

TABPNT:	[ASCIZ/  middle of a dump - position tape - GETUFD/]
	[ASCIZ/  end of a structure - DMPSTR/]
	[ASCIZ/  end of a structure - position tape - DMPSTR/]
	[ASCIZ/  end of a structure - DMPSTR/]
	[ASCIZ/  end of reel in merge - GFREDO/]
	[ASCIZ/  end of reel; need rewind - GFREDO/]
	[ASCIZ/  end of reel & structure - DMPSTR/]
IFN TABPLN-<.-TABPNT>,<.FATAL TABPNT doesn't match TABPIK>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            subttl	system class dumps  fdump, pdump, tdump, purge	 ; PURGE PURGE0 FDUMP PDUMP TDUMP TDUMP1 PDUMP1 PDMP2Z PDUMP2 PDMP2A PDUMP3 GETSTR JUST1S STRPIK NNSTR NNST0

PURGE:	TRZ	FL,FULL			;PURGE IS NOT FULL
	TRO	FL,PURCOM+PCLASS	;IS A PURGE
	SKIPN	PPURGE			;PHONY PURGE?
	JRST	PURGE0
	OUTSTR	[ASCIZ/(This is a purger debugging run.  Nothing will be purged.)
DO NOT ATTEMPT TO USE THIS CORE IMAGE FOR ANYTHING ELSE BUT A SINGLE DEBUGGING RUN
/]
	MOVEI	A,0
IFE STANSW,<	GETPPN	A,	>;IFE STANSW
IFN STANSW,<	DSKPPN	A,	>;IFN STANSW
	MOVEM	A,DUMPER
	MOVE	A,['PPURGE']
	MOVEM	A,TAPNAM		;SET PHONY TAPE NAME
PURGE0:	MOVEI	A,2			;SET THE DUMP CLASS 2 = PERMANENT
	JRST	PDUMP1

FDUMP:	TROA	FL,FULL			;FLAG FOR FULL DUMP
PDUMP:	TRZ	FL,FULL			;CLEAR FULL DUMP FLAG
	TRZ	FL,PURCOM		;NOT PURGE COMMAND
	TRO	FL,PCLASS		;TURN ON PERMANENT CLASS
	MOVEI	A,2			;SET THE DUMP CLASS 2 = PERMANENT
	JRST	TDUMP1

TDUMP:	TRZ	FL,FULL!PCLASS!PURCOM	;NOT FULL - NOT PERMANENT - NOT PURGE
	MOVEI	A,1			;DUMP CLASS 1 = TEMPORARY
TDUMP1:	SKIPE	PPURGE
	JRST	[OUTSTR	[ASCIZ/PPURGE not zero.  You'd better get a new core image.
/]
		HALT CPOPJ]

PDUMP1:	PUSHJ	P,SDFTDN		;maybe select default density
IFN FTCOPY,<
	PUSHJ P,MCONLY		;Don't attempt system dump -- doesn't return
>;IFN FTCOPY

	MOVEM	A,CLASS			;SAVE DUMP CLASS.
	SETZM MASCOP		;not doing master tape copy
	SETZM	PICKON			;NOT DOING A PICKUP.
IFE IRCPPN,<
	GETPPN	A,			;GET THE REAL PPN (NOT DSKPPN)
	 JFCL				;DEC NEEDS THIS
>;IFE IRCPPN
IFN IRCPPN,<
	HRROI A,2			;REAL PPN COMES FROM GETTAB
	GETTAB A,
	 GETPPN A,
	  JFCL
>;IFN IRCPPN
	CAME	A,DUMPER		;IS THIS THE RIGHT NAME?
	JRST	NOPRV			;HE IS NOT THE RIGHT GUY.

	MOVEI	A,17			;CHANNEL FOR DART.TAP,DART.REC, ETC.
	MOVSI	B,'DSK'			;DEFAULT STRUCTURE.
	MOVEI	C,0
	OPEN	DSKMEM,A		;OPEN CHANNEL
	 PUSHJ	P,NODEV			;CAN'T HAPPEN
	OPEN	DSKMSC,A		;OPEN CHANNEL
	 PUSHJ	P,NODEV			;CAN'T HAPPEN
	MOVE	A,['NODUMP']
	MOVSI	B,'PLS'
	MOVEI	C,0
	MOVE	D,DUMPER
	LOOKUP	DSKMEM,A		;SEEK LOCKOUT FILE
	 JRST	PDMP2Z
	JRST LOKOUT

PDMP2Z:	MOVE	A,['DART  ']
	MOVSI	B,'MEM'
	MOVEI	C,0
	MOVE	D,DUMPER
	LOOKUP	DSKMEM,A		;SEEK MEMORY FILE
	 JRST	PDUMP2
	OUTSTR	[ASCIZ/I still have a memory file!
If you intend to continue the interrupted dump, do a PICKUP.
Otherwise, you need help -- get a wizard.
/]
	EXIT

PDUMP2:	SETZM	MEMSAV
	MOVE	A,[MEMSAV,,MEMSAV+1]
	BLT	A,MEMSAV+MEMLEN-1	;ZERO THE PICKUP DATA.
	HRRZ	A,CLASS			;
	HRL	A,FL			;GET THE FLAGS
	MOVEM	A,MEMSAV+DCLASS		;SAVE FLAGS AND CLASS.

	PUSHJ	P,SCAN			;SCAN THE WORLD.
	SKIPN	R,DEST			;IS THERE A DESTINATION TERM?
	PUSHJ	P,GETBLK		;NO MAKE ONE
	MOVEM	R,DEST			;AND SAVE THE ADDRESS OF THE DESTINATION
	MOVE	A,FSDEV(R)		;GET THE DEVICE NAME.
	MOVEM	A,MTDEV			;SAVE WHERE MTINIW WILL SEE IT
	MOVEM	A,MEMSAV+MMTDEV		;SAVE DEVICE NAME HERE TOO.
	TRNN	FL,PURCOM		;PURGE?
	JRST	PDUMP3			;NO.  SKIP ANALYSIS OF SCANNED INPUT
	MOVE	R,FSPTR
	MOVEM	R,.JBFF			;SET .JBFF ABOVE ALL THE SOURCE TERMS
	HRRZ	R,TBASE			;GET BASE OF SOURCE TERMS
	CAML	R,FSPTR			;IF NONE, ERROR.
	JRST	PURERR			;IF NONE, ERROR.
	MOVSI	A,'DSK'			;DEFAULT SOURCE DEVICE.
PDMP2A:	CAML	R,FSPTR			;END OF THE LIST YET?
	JRST	PDUMP3
	SKIPN	B,FSDEV(R)		;SKIP IF THERE'S AN EXPLICIT SOURCE DEVICE
	MOVE	B,A			;NO. USE THE STICKY ONE LEFT FROM LAST TIME
	MOVE	A,B			;SAVE THE STICKY ONE
	MOVEM	A,FSDEV(R)		;SAVE IT IN THE TERMBLOCK TOO
	ADDI	R,FSLEN
	JRST	PDMP2A

PDUMP3:
IFE STANSW,<
;; this is a bug, we get here (if not a purge) with MTAn in A!!
	CAMN A,['DSK   ']
	MOVEI A,0
	MOVEM A,UNQSTR
>;IFE STANSW
	TLO	FL,MOUNT		;REMEMBER WE NEED TO MOUNT A TAPE.
	PUSHJ	P,GETTAP		;FIND OUT WHAT TAPE NUMBER TO USE.
	MOVE	A,TAPNO			;GET THE TAPE NUMBER
	MOVEM	A,MEMSAV+TAPNUM		;SAVE TAPE NUMBER HERE TOO.

IFE STANSW,<
	SKIPE A,UNQSTR
	JRST JUST1S			;IF EXPLICIT STRUCTURE, NO SYSSTR STUFF
>;IFE STANSW
	SETZM	STRNAM			;ZERO THE STRUCTURE NAME.
GETSTR:	MOVE	A,STRNAM		;SELECT THE FILE STRUCTTURE TO DO NEXT
IFE STANSW,<
	SYSSTR A,			;ASK SYSTEM FOR THE NEXT NAME
>;IFE STANSW
	 MOVSI A,'DSK'			;UNIMPLEMENTED UUO. ASSUME DEVICE DSK
	CAMN	A,STRNAM		;SAME AS THE CURRENT NAME?
	SETZ	A,			;YES. ZERO THE NAME
JUST1S:	MOVEM	A,MEMSAV+MSTRNA		;SAVE TO REMEMBER

;CONTINUE HERE IN PICKUPS
STRPIK:	MOVEM	A,STRNAM		;SAVE THE STRUCTURE NAME.
	JUMPE	A,NNSTR			;NO NEXT STRUCTURE.
	PUSH	P,.JBFF			;SAVE .JBFF ON THE STACK
	PUSHJ	P,DMPSTR		;DUMP SELECTED STRUCTURE.
	POP	P,.JBFF			;RESTORE .JBFF TO RECYCLE BUFFERS
IFE STANSW,<
	SKIPN UNQSTR			;DONE IF JUST ONE STR
>;IFE STANSW
	JRST	GETSTR			;GET ANOTHER STRUCTURE.

NNSTR:	SKIPE	PPURGE
	JRST	NNST0			;AVOID STUFF IF PHONY PURGE
IFN DBGSW,<
	SKIPN	DBGNTP			;AVOID REWIND IF NO TAPE OUTPUT
>;IFN DBGSW
	PUSHJ	P,MT2REW		;START THE REWIND
	PUSHJ	P,PUTTAP		;UPDATE TAPE NUMBERS ON DART.TAP
NNST0:	CLOSE	DSKMEM,
	SETZB	A,B
	SETZ	C,
	MOVE	D,DUMPER
	RENAME	DSKMEM,A		;DELETE DART.MEM
	JFCL

	PUSHJ	P,MT2REL		;RELEASE THE TAPE.
	RELEAS	DSKMEM,
	RELEAS	DSKMSC,
	OUTSTR	[ASCIZ/Dump complete.
/]
	SKIPE	PPURGE
	OUTSTR	[ASCIZ/(You might delete DART.DAT from this area.)
/]
	PUSHJ	P,REAPCL		;Close reap-log file if open
	POPJ	P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   subttl	dump an entire file structure	 ; DMPSTR DMPST0 DMPST3 DPIK2 DMPSTW DMPSTZ DMPSTY PIK6 DMPSTX DPIK1 DMPST1 DMPST2 DPIK3 DPICKT DMPSTP DMPSP0 DMPSP1 DMPSP2

DMPSTR:	MOVEM	A,DEVNAM		;SAVE DEVICE NAME FOR PUT

	MOVEI	A,10+GARBIT		;READ MFD. PREVENT LOSSAGE FROM BAD RETR.
	MOVE	B,STRNAM		;DEVICE
	MOVEI	C,UFDBUF		;BUFFER HEADER FOR INPUT
	OPEN	UFD,A			;CHANNEL FOR MFD AND UFDS
	 PUSHJ	P,NODEV			;LOSE BIG
	INBUF	UFD,NBUFS		;UFD'S ARE USUALLY SMALL. THE MFD IS READ ONCE
					;BUT STILL, UFD READS MAY BE LOTS OF DSKOPS

	MOVEI	A,10+DMPBIT+GARBIT	;READ FILES. 6 WORD LOOKUP/RENAME.
	MOVE	B,STRNAM		;ERROR RETURN ON BAD RETR.  NO REFTIM UPDATE
	MOVE	C,[FOBUF,,FIBUF]
	OPEN	FILE,A
	 PUSHJ	P,NODEV
	INBUF	FILE,NBUFS		;ALLOCATE MORE BUFFERS FOR READING FILES.

	MOVEI	A,17			;DUMP MODE FOR MEMORY CHANNEL
	MOVE	B,STRNAM		;STRUCTURE NAME
	MOVEI	C,0			;NO BUFFERS FOR DUMP MODE
	OPEN	MEM,A			;OPEN CHANNEL
	 PUSHJ	P,NODEV			;LOSE.

	PUSHJ	P,MFDSOR		;READ AND SORT THE MFD.
	CLOSE	UFD,			;CLOSE THE FILE.

	SKIPE	PICKON
	JRST	DMPSTP			;DO THE PICKUP.
DMPST0:	MOVE	A,['ALLDIR']		;NAME OF THE FILE
	MOVSI	B,'MEM'	
	MOVEI	C,0
	MOVE	D,DUMPER
	ENTER	MEM,A
	 JRST	[OUTSTR	[ASCIZ/ENTER to make ALLDIR.MEM failed.
/]
		HALT	DMPST0]
	CLOSE	MEM,			;CLOSE-TO CREATE DIRECTORY ENTRY(EMPTY FILE)
	PUSHJ	P,ALLMIN		;RE-OPEN ALLDIR.MEM, INIT ALLSIZ

	MOVE	Q,MFDPTR		;GET THE POINTER TO THE MFD.
DMPST3:	MOVE	A,(Q)			;GET UFD NAME
	PUSHJ	P,GETUFD		;DUMP AN ENTIRE UFD
	AOBJN	Q,DMPST3		;LOOP DOING UFDS
	CLOSE	MEM,			;CLOSE ALLDIR.MEM


	PUSHJ	P,SPLIT			;CREATE ALLDIR.DAT(IF NOT PURGE), DTAPES.DAT

;PICKUP TYPE 2
DPIK2:	MOVEI	A,2
	MOVEM	A,MEMSAV+CHKNUM
	SETZM	MEMSAV+MERGFL
	SETZM	PICKON			;NOT NOW DOING A PICKUP.
	PUSHJ	P,SAVMEM		;SAVE DATA.

	MOVE	A,['ALLDIR']
	MOVSI	B,'MEM'
	SETZ	C,
	MOVE	D,DUMPER
	LOOKUP	UFD,A
	 JRST	DMPSTW			;IF NO ALLDIR.MEM, DON'T DELETE IT
	SETZB	A,B
	MOVEI	C,0
	MOVE	D,DUMPER
	RENAME	UFD,A			;DELETE ALLDIR.MEM
	 JFCL
DMPSTW:	TRNE	FL,PURCOM		;SKIP UNLESS PURGE
	JRST	DMPSTX			;AVOID ALLDIR HACKING FOR PURGE

DMPSTZ:	MOVE	A,['ALLDIR']		;NOW GOBBLE THE MASTER DIRECTORY.
	MOVSI	B,'DAT'
	MOVEI	C,0
	MOVE	D,DUMPER
	MOVE	W,[A,,FILBLK]
	BLT	W,FILBLK+3
IFN STANSW,<
	LOOKUP	FILE,A
	 JRST	DMPSTX			;LOSE SOMEHOW
	MTAPE	FILE,['GODMOD'
			14
			IOWD 20,FILINF]
	 JFCL			
	MTAPE	FILE,RDOFFS		;READ OFFSET FROM THE OFFSET BLOCK.
	MOVE	A,RDOFFS+2		;GET THE OFFSET NUMBER.
	MOVEM	A,FILINF+DDOFFS		;SAVE IT IN THE RETRIEVAL.
>;IFN STANSW
IFE STANSW,<
	PUSHJ P,DMPLKP
	 JRST DMPSTX
>;IFE STANSW
	LDB	A,PDATE				;GET THE FILE WRITE DATE
	LDB	B,PDATEH			;HIGH DATE - DATE75
	DPB	B,[POINT 3,A,23]		;STUFF HIGH DATE - DATE75
	HLL	A,FILINF+DDEXT			;GET THE EXTENSION.
	MOVEM	A,DATDAT			;SAVE EXT,,DATE FOR MERGE
	MOVE	A,WRCSZ			;get record size
	MOVEM	A,WC			;SAVE AS WC
	SETZM	MTFILN
	MOVE	D,[FILBLK,,A]
	BLT	D,D
	PUSHJ	P,TYFIL
IFN STANSW,<
	MOVEI	A,2
	SUB	A,FILINF+DDOFFS
	USETI	FILE,(A)		;USETI TO THE FIRST REAL RECORD.
>;IFN STANSW	;THANK YOU MR. GORIN
	TLZ FL,IGNEOT		;CAN'T IGNORE EOT.
	PUSHJ P,DUMP
	 JRST DMPSTY		;LOSE.  NEED A NEW REEL OF TAPE
	PUSHJ P,MT2CLZ		;close output, write EOF
	PUSHJ P,MT2CTS		;skip if EOF written OK, remember where written
	 JRST DMPSTY		;phys end of tape
	OUTSTR CRLF
	JRST DMPSTX

DMPSTY:	OUTSTR	[ASCIZ/- not saved. Physical end of tape.
/]
IFN DBGSW,<
	SKIPN	DBGNTP			;NO TAPE OPERATIONS IF NOT USING IT
>;IFN DBGSW
	PUSHJ	P,MT2REW
	PUSHJ	P,PUTTAP
	AOS	A,TAPNO
	MOVEM	A,MEMSAV+TAPNUM
	PUSHJ	P,REAPCL		;Close reap log file
PIK6:	MOVEI	A,6
	MOVEM	A,MEMSAV+CHKNUM
	SETZM	PICKON
	PUSHJ	P,SAVMEM
	PUSHJ	P,DOMOUNT
	JRST	DMPSTZ

DMPSTX:	SETZM	MEMSAV+MERGFL		;ZERO THE MERGE FLAG
;PICKUP TYPE 1
DPIK1:	MOVEI	A,1			;PICKUP CODE 1
	MOVEM	A,MEMSAV+CHKNUM		;SAVE PICKUP CODE.
	SETZM	PICKON			;PICKUP IS NOT CURRENTLY IN PROGRESS.
	TRNN	FL,PURCOM		;SKIP IF PURGE
	PUSHJ	P,SAVMEM		;SAVE DATA.
	SKIPN	MEMSAV+MERGFL		;IS THIS A PICKUP THAT LOSES?
	PUSHJ	P,MERGE			;DO THE MERGE INTO DART.DAT ON THIS STRUCTURE

	RELEAS	FILE,
	RELEAS	MEM,
	TRNE	FL,PURCOM
	JRST	[RELEAS	UFD,
		POPJ	P,]			;RETURN QUICK FROM PURGE
	MOVE	A,['ALLDIR']
	MOVSI	B,'DAT'
	SETZ	C,
	MOVE	D,DUMPER
	LOOKUP	UFD,A			;IF THIS IS NOT HERE, DON'T LOOK AT .OLD
	 JRST	[OUTSTR [ASCIZ/ALLDIR.DAT got lost: ALLDIR.OLD will not be deleted.
/]
		JRST	DMPST2]
	MOVE	A,['ALLDIR']
	MOVSI	B,'OLD'
	SETZ	C,
	MOVE	D,DUMPER
	LOOKUP	UFD,A			;SEEK OLD 
	 JRST	DMPST1			;NONE THERE.
IFN STANSW,<
	CLOSE	UFD,			;CLOSE
>;IFN STANSW
	SETZB	A,B
	MOVE	D,DUMPER
	RENAME	UFD,A			;RENAME TO DELETE
	 OUTSTR	[ASCIZ/Unable to delete ALLDIR.OLD
/]
DMPST1:	MOVE	A,['ALLDIR']
	MOVSI	B,'DAT'
	SETZ	C,
	MOVE	D,DUMPER
	LOOKUP	UFD,A			;SEEK FILE.
	 JRST	DMPST2
IFN STANSW,<
	CLOSE	UFD,
>;IFN STANSW
	MOVE	A,['ALLDIR']
	HRLI	B,'OLD'			;DATE75 - PRESERVE HIGH DATE.
	MOVE	D,DUMPER
	RENAME	UFD,A			;RENAME THE FILE.
	 OUTSTR	[ASCIZ/Unable to rename ALLDIR.DAT to ALLDIR.OLD
/]
DMPST2:	CLOSE	UFD,			;CLOSE.
	RELEAS	UFD,
;PICKUP TYPE 3.
DPIK3:	MOVEI	A,3
	MOVEM	A,MEMSAV+CHKNUM		;SAVE CODE
	SETZM	PICKUP
	PUSHJ	P,SAVMEM
	POPJ	P,			;NO UFDS LEFT. GET ANOTHER STRUCTURE.

DPICKT:	DPIK1
	DPIK2
	DPIK3

DMPSTP:	MOVE	A,MEMSAV+CHKNUM		;GET THE PICKUP CODE
	CAIL	A,1
	CAILE	A,3			;CODES 1 AND 3 ARE PROCESSED HERE.
	JRST	DMPSP0			;OUT OF RANGE
	JRST	@DPICKT-1(A)		;DISPATCH FOR CODES 1,2,3

DMPSP0:	CAIN	A,6
	JRST	PIK6			;PICKUP TYPE 6
	PUSHJ	P,ALLMIN		;OPEN ALLDIR.MEM, SET UP ALLSIZ
	MOVE	Q,MFDPTR		;GET THE POINTER TO THE UFD.
	MOVE	A,MEMSAV+LUSER		;GET THE NAME OF THE LAST GUY.
DMPSP1:	CAMN	A,(Q)			;GET THE NAME OF A UFD.
	JRST	DMPST3			;GOT IT! TRICKLE DOWN ANOTHER LEVEL.
	AOBJN	Q,DMPSP1		;LOOP LOOKING.
	SETZM	PICKON			;WILL NOT BE A PICKUP.
	PUSHJ	P,UFDCNV		;CONVERT TO SORT FORMAT.
	MOVEM	A,DNX
	MOVE	Q,MFDPTR
DMPSP2:	MOVE	A,(Q)
	PUSHJ	P,UFDCNV
	MOVEM	A,TNX
	PUSHJ	P,PPNCMP		;COMPARE PPNS.
	JRST	DMPST3			;D<T THIS WILL DO. TRICKLE DOWN
	AOBJN	Q,DMPSP2		;LOOP LOOKING
	JRST	DPIK1			;UFD NAME WAS BIGGER THAN ANYTHING THAT
					;EXISTS NOW.  WE MUST HAVE BEEN DONE.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       subttl dump files from one ufd ; GETUFD GPUR1 GPUR2 GETUD1 ALLINI GETFIL GETFL1 GETFL2 GFLOOK GFTEST GFALLM GFPTS3 GFPTST GFPTS1 GFPTS2 GFTXL GFDUMP GFDMP1 GFDMP2 GFDP2A GFDP3A GDP3AA GFDP3B GDP3BA NNFIL GFDMP3 YMTA3 GFDMP4 GDP4BA GFDP4B GFDP4C GFDP4A TAPCMP TAPCP1 FIXPDU PUTEST PUTST0 PUTST1 PUTST2 MONTHB DATCNV REAPLG LOGIT0 LOGZ0 LOGOUT LOGZ REAPL2 REAPLX REAPSR REAPS1 REAPOU LOGOK REAPCL

GETUFD:	MOVE A,THSDAT
	PUSHJ P,DATCNV		;SYSTEM FORMAT DATE
	MOVEM A,THSDAX		; TO NUMBER OF DAYS SINCE 1/1/64
	SKIPE PICKON		;ARE WE IN THE MIDDLE OF A PICKUP?
	JRST GFPICK		;YES. GO DO IT.
	TRNN FL,PURCOM		;PURGE COMMAND?
	JRST GETUD1		;NO. ORDINARY.

;HERE FOR PURGE COMMAND - SEE IF THERE'S ANYTHING TO FLUSH IN THIS UFD
	HRRZ R,TBASE		;BASE OF ALL PURGE TERMS SCANNED
GPUR1:	CAML R,FSPTR		;FIRST ADDRESS ABOVE PURGE TERMS
	POPJ P,			;THERE ARE NO PURGE TERMS (LEFT ANYMORE)
	MOVE A,FSDEV(R)
	CAME A,STRNAM		;DEVICE NAME MATCHES THIS STRUCTURE?
	JRST GPUR2		;NO.  GET NEXT TERM
	MOVE B,FSEXT(R)		;GET FLAGS
	MOVE A,(Q)		;GET PROJ,PROG
	CAMN A,FSPPN(R)		;MATCHES THIS TERM EXACTLY?
	JRST GETUD1		;YES.  WE'LL HAVE TO DO SOMETHING HERE.
	HRRZ C,FSPPN(R)
	CAIE C,(A)
	TRNE B,ALLPRG
	JRST .+2		;PRG MATCHES OR IS *
	JRST GPUR2
	HLRZ A,(Q)
	HLRZ C,FSPPN(R)
	CAIE A,(C)
	TRNE B,ALLPRJ
	JRST GETUD1		;THIS MATCHES SOMEWHAT
GPUR2:	ADDI R,FSLEN
	JRST GPUR1


GETUD1:	MOVE A,(Q)		;PICKUP A UFD NAME
	MOVSI B,'UFD'
	SETZB C,PICKON
	MOVE D,GOD
	MOVE X,[A,,FILBLK]
	BLT X,FILBLK+3
	LOOKUP UFD,A
	JRST [	TRZ FL,SAFETY
		PUSHJ P,LCHECK
		JFCL
		CLOSE UFD,
		SETZM PICKON	;A PICKUP CANNOT SURVIVE THIS
		POPJ P,]	;RETURN UPLEVEL
	MOVEM A,MEMSAV+LUSER
	SKIPE PPURGE		;PHONY PURGE?  (DEBUGGING ONLY!)
	TLZ FL,MOUNT		;FOR PHONY PURGE, MOUNT NO TAPES!
	TLZE FL,MOUNT
	PUSHJ P,DOMOUNT		;REQUIRE TAPE MOUNT FIRST.

	PUSHJ P,DPYSER		;DISPLAY USER NAME ON DPY
	 MEMSAV+LUSER,,DPYPPN	;PPN ONLY (ALSO NO. OF FEET)

ALLINI:	MOVE S,[IOWD 200,REELBF] ;INITIALIZE POINTER TO REEL DIRECTORY
	PUSH S,(Q)		;SAVE THE UFD NAME
	MOVEM S,REELPT		;SAVE POINTER TO REEL DIRECTORY
	MOVE S,[IOWD 400,ALLBUF] ;INITIALIZE POINTER FOR ALLDIR
	PUSH S,(Q)		;SAVE THE UFD NAME.
	MOVEM S,ALLPTR		;SAVE THE POINTER.
	SETZM 1(S)		;INITIALIZE FOR EMPTY

GETFIL:	HLRZ S,ALLPTR		;GET THE COUNT OF SPACE LEFT
	CAILE S,-4		;NEED ROOM FOR 3 WORDS + A ZERO WORD
	JRST GFDMP3		;IF NOT 4 WORDS LEFT, WE HAVE OVERFLOW
	PUSHJ P,UFDRD		;READ THE UFD
	 JRST NNFIL		;NO NEXT FILE
	MOVEM A,FILBLK		;SAVE A FILE NAME
	SKIPE A
	MOVEM A,MEMSAV+LFILE
	PUSHJ P,UFDRD
	 JFCL
	MOVEM A,FILBLK+1
	SKIPE FILBLK
	HLLZM A,MEMSAV+LEXT
IFN STANSW,<
	MOVE D,[-UFDN+2,,2]	;READ MORE
GETFL1:	PUSHJ P,UFDRD
	 JFCL
	MOVEM A,FILBLK(D)
	AOBJN D,GETFL1
>;IFN STANSW
	SKIPN FILBLK
	JRST GETFIL		;GET THE NEXT FILE. NAME WAS 0.
	TRNE FL,PURCOM		;SKIP UNLESS PURGING.
	JRST PUTEST		;(RETURN TO GFLOOK TO PURGE, ELSE TO GETFIL)
GETFL2:				;ENTER HERE TO RESTART P,T,FDUMP AFTER EOT
IFE STANSW,<
	MOVE D,(Q)		;GET PPN
	HLRZ B,FILBLK+1		;AND EXT
	CAIN B,'SYS'
	CAME D,SYSPPN
	JRST .+2
	JRST GETFIL		;DON'T DUMP SYS:*.SYS
>;IFE STANSW

IFN STANSW,<
	HLRZ A,FILBLK+1		;GET THE EXTENSION
;	CAIE A,'TMP'		;Don't flush TMP any more (09/04/78 EJG)
;	CAIN A,'RPG'		;Don't flush RPG any more (12/05/77)
;	JRST GETFIL		;FLUSH RPG AND TMP FILES.
;	CAIN A,'SND'	
;	JRST GETFIL		;FLUSH SOUND FILES
	HRRZ A,FILBLK+3
	MOVEM A,RRD1		;SAVE TRACK NUMBER FOR MTAPE
	TRZ FL,LOOKDN		;SET A FLAG TO SAY NO LOOKUP DONE YET.
IFE FTLUFD,<
	MOVE A,FILBLK		;GET FILE NAME
	HLLZ B,FILBLK+1		;EXT ONLY
	MOVE D,(Q)		;GET PPN
IFE DBGSW,<
	MTAPE FILE,RRD		;DO ABSOLUTE MODE READ TO READ RETRIEVAL
>;IFE DBGSW
	 JRST GFLOOK		;LOSE SOMEHOW. DO A LOOKUP
	CAMN D,FILINF+DDPPN	;CHECK FILE RETRIEVAL
	CAME A,FILINF+DDNAM	;PPN AND NAME
	JRST GFLOOK		;BAD RETRIEVAL. TRY THRU THE SYSTEM
	HLLZ C,FILINF+DDEXT	;GET EXT
	CAMN B,C
	JRST GFTEST		;RETRIEVAL IS GOOD ENOUGH
>;IFE FTLUFD
IFN FTLUFD,<
	MOVE A,FILBLK+UNAM
	MOVEM A,FILINF+DDNAM
	MOVE A,FILBLK+UEXT
	MOVEM A,FILINF+DDEXT
	MOVE A,FILBLK+UPRO
	MOVEM A,FILINF+DDPRO
	MOVE A,(Q)
	MOVEM A,FILINF+DDPPN
	MOVE A,FILBLK+ULOC
	MOVEM A,FILINF+DDLOC
	MOVE A,FILBLK+ULEN
	MOVEM A,FILINF+DDLNG
	MOVE A,FILBLK+UREFT
	MOVEM A,FILINF+DREFTM
	MOVE A,FILBLK+UDMPT
	MOVEM A,FILINF+DDMPTM
	MOVE A,[FILBLK+UQINFO,,FILINF+DQINFO]
	BLT A,FILINF+DQINFO+3
	MOVE A,FILBLK+UOFFST	;offset from retrieval -- NOTE: This isn't used.
	MOVEM A,FILINF+DDOFFS	;GFDMP1 gets real offset data (retr value plus 1).
	JRST GFTEST		;"RETRIEVAL" FROM UFD IS GOOD ENOUGH
>;IFN FTLUFD
>;IFN STANSW

GFLOOK:	MOVEI C,0		;A,B,D ALREADY SET WITH NAME,EXT AND PPN
	TRZ FL,SAFETY		;REAL LOOKUP
IFN STANSW,<
	MOVE Y,[A,,FILBLK]
	BLT Y,FILBLK+3
	LOOKUP FILE,A		;SEEK FILE.
				;BEWARE: W,X ARE CLOBBERED BY 6 WORD LOOKUP
	 JRST [	PUSHJ P,LCHECK
		 JFCL
		JRST GETFIL]
	TRO FL,LOOKDN		;LOOKUP DONE.
	MTAPE FILE,['GODMOD'
			14
		     IOWD 20,FILINF]
	 JFCL			;CANT LOSE. HA HA.
>;IFN STANSW
IFE STANSW,<
	MOVE A,FILBLK
	MOVEM A,FILINF+DDNAM
	HLLZ B,FILBLK+1
	MOVE D,(Q)
	MOVEM D,FILINF+DDPPN
	PUSHJ P,DMPLKP		;THIS SETS UP FILINF TOO
	 JRST GETFIL		;NOT FOUND
>;IFE STANSW
	TRNE FL,PURCOM		;PURGE COMMAND?
	JRST GFALLM		;YES.  GO OUTPUT TO ALLDIR.MEM, THEN DUMP
GFTEST:	MOVE B,FILINF+DDMPTM	;GET DUMP INFO WORD
	TLNE B,REAPBT		;SKIP UNLESS TO BE REAPED
	TRNN FL,PCLASS		;REAPEE.  PDUMP?
	JRST .+2		;NO REAP, OR TDUMP
	JRST GFALLM		;PDUMP AND REAP, IGNORE NO-DUMP FLAG
IFN STANSW,<
	SKIPL FILINF+DDPRO	;SKIP IF DUMP NEVER
>;IFN STANSW
IFE STANSW,<
	MOVE B,LKBLK+.RBSTS
	TRNE B,240000		;NO-FAILSAFE OR IMPERVIUM BITS
	JRST GFTXL		;PREVENT DUMP
	MOVE B,FILINF+DDMPTM
	TLNN B,4000		;NON-STANFORD DUMP-NEVER BIT
>;IFE STANSW
	SKIPG B,FILINF+DDLNG	;SKIP IF NOT EMPTY FILE (ALSO GET LENGTH)
	JRST GFTXL		;IGNORE EMPTY FILES AND DUMP NEVER FILES
				;DUMP NEVER = 400 BIT IN PROTECTION
IFE STANSW,<
	HLRZ C,FILINF+DDEXT
	TRNN FL,PCLASS		;IF TEMPORARY DUMP,
	CAIN C,'MSB'		; THEN THE LENGTH LIMIT ONLY APPLIES
>;IFE STANSW
	SKIPN MAXLEN		; TO MUSIC SAMPLE FILES
	JRST GFALLM		;NO LENGTH LIMIT, OR TDUMP AND NOT .MSB
	CAMLE B,MAXLEN		;COMPARE FILE LENGTH TO LIMIT
	JRST GFTXL		;DON'T SAVE MOBY MUSIC FILES ETC
				;..OR FILES THAT WON'T FIT ON A TAPE
GFALLM:	MOVE S,ALLPTR		;GET POINTER
	PUSH S,FILINF+DDNAM	;SAVE THE NAME OF THE FILE.
	LDB B,PTAPEN		;GET THE LAST TAPE # IN THE RIGHT
IFN STANSW,<
	MOVSI L,17000		;DDMPTM BITS TO LEAVE ALONE
	JUMPG B,.+2		;JUMP IF DUMPED ON A REAL DART TAPE
	ANDM L,FILINF+DDMPTM	;RESTORED BY DAEMON(?) (WAS SETZM)
>;IFN STANSW
	HLL B,FILINF+DDEXT	;GET THE EXTENSION
	SKIPGE FILINF+DDMPTM	;WAS THIS T-DUMPED?
	IORI B,400000		;YES. MARK IT.
	PUSH S,B		;SAVE THIS FOR ALLDIR.MEM
	MOVEM S,ALLPTR		;SAVE POINTER
	TRNE FL,PURCOM		;PURGE COMMAND?
	JRST GFDUMP		;YES.  SELECT THIS FILE FOR OUTPUT

				;DECIDE ABOUT DUMPING THIS FILE.
	MOVE B,(Q)		;GET PPN OF THE UFD WE'RE DUMPING
IFN STANSW,<
	CAMN B,['  1  4']	;IS THIS [1,4]?
	JRST GFTXL		;YES. DON'T DUMP ANY [1,4] FILES.
>;IFN STANSW
	CAME B,DUMPER		;IS THIS THE DUMPER
	JRST GFPTS3		;NO.
	HLRZ A,FILINF+DDEXT	;GET THE EXTENSION
	CAIN A,'LST'
	JRST GFTXL		;FLUSH DUMPER'S LST FILES.
	CAIN A,'MEM'
	JRST GFTXL		;FLUSH DUMPER'S MEM FILES.
	CAIE A,'DAT'
	JRST GFPTS3
	MOVE A,FILINF+DDNAM	;GET FILE NAME
	CAMN A,['ALLDIR']
	JRST GFTXL		;FLUSH DUMPER'S ALLDIR.DAT

GFPTS3:	TRNE FL,FULL		;FULL DUMP?
	JRST GFDUMP		;YES. DUMP THIS.
	LDB A,PINVAL		;PICKUP THE DUMP DATE INVALID BIT
	JUMPN A,GFDUMP		;THIS HAS TO BE DUMPED SINCE INVALID.
	TRNE FL,PCLASS		;IS THIS A PERMANENT DUMP?
	JRST GFPTST		;YES. GO DECIDE WHETHER TO PDUMP

;This is a temporary dump.  Don't dump this file if it has been dumped before.
	LDB A,PTAPEN		;GET TAPE NUMBER OF LAST DUMPING, IF ANY
	JUMPE A,GFDUMP		;JUMP IF NEVER DUMPED, DUMP IT NOW
	SKIPL FILINF+DDMPTM	;WAS THIS LAST DUMPED IN A T DUMP?
	JRST GFTXL		;THIS WAS PDUMPED. DON'T DUMP IT AGAIN.
	PUSHJ P,TAPCMP		;WAS THIS DUMPED IN CURRENT SERIES (USES A)?
	 JRST GFTXL		;THIS WAS T-DUMPED AT SOME OTHER TIME.
	JRST GFDUMP		;THIS WAS DUMPED IN THIS SERIES.
				;DUMP IT AGAIN TO AVOID FUCKUP.

GFPTST:	MOVE A,FILINF+DDMPTM
	TLNE A,REAPBT		;CHECK REAP (DELETE AFTER DUMPING) BIT
	JRST GFDUMP		;YES, DUMP IT
	SKIPG FILINF+DDMPTM	;WAS THIS PDUMPED BEFORE?
	JRST GFPTS2		;NEVER.
	LDB A,PTAPEN		;GET THE TAPE NUMBER
	PUSHJ P,TAPCMP		;WAS THIS DUMPED IN THIS SERIES?
	JRST GFPTS1		;NO THIS HAS BEEN DUMPED ELSEWHERE.
	LDB A,PCOUNT		;THIS WAS DUMPED IN THIS SERIES.
	SOJL A,.+2		;DECREASE COUNT. DON'T DEPOSIT NEGATIVE
	DPB A,PCOUNT
	JRST GFDUMP		;FORCE THIS ONE TO BE DUMPED.

GFPTS1:	LDB A,PCOUNT		;GET THE DUMP COUNT
	CAILE A,1		;LESS THAN TWICE?
	JRST GFTXL		;THIS HAS BEEN DUMPED ENOUGH
	JRST GFDUMP		;THIS WAS PDUMPED BEFORE. DO IT AGAIN.

GFPTS2:	LDB A,PDATE		;NEVER PDUMPED. GET THE DATE.
	LDB B,PDATEH		;GET HIGH DATE
	DPB B,[POINT 3,A,23]	;STUFF HIGH DATE
	PUSHJ P,DATCNV		;CONVERT TO NUMBER OF DAYS SINCE 1/1/64
	ADDI A,4		;ADD SOMETHING TO THE CREATION DATE
	CAMG A,THSDAX		;HOW DOES IT COMPARE WITH THE DUMP DATE?
	JRST GFDUMP		;OLD ENOUGH TO DUMP.
	MOVE A,(Q)		;GET PPN AGAIN
	CAMN A,DUMPER
	JRST GFDUMP		;FOR DUMPER, WE DUMP REGARDLESS OF DATE.
GFTXL:	TRZE FL,LOOKDN		;WAS A LOOKUP DONE?
	CLOSE FILE,NUPACC	;YES. ZERO FLAG AND CLOSE FILE
	JRST GETFIL		;GO GET ANOTHER FILE.

;HERE TO REALLY DUMP A FILE.
GFDUMP:	TRZE FL,LOOKDN		;WAS A LOOKUP DONE YET?
	JRST GFDMP1		;YES. SKIP THIS
IFN STANSW,<
	MOVE D,[FILINF+DDNAM,,A] ;GET THE FILE NAME FROM RETREIVAL
	BLT D,D
	MOVE X,[A,,FILBLK]
	BLT X,FILBLK+3
	LOOKUP FILE,A
	 JRST [	TRZ FL,SAFETY
		PUSHJ P,LCHECK
		 JFCL
		JRST GETFIL]
IFN FTLUFD,<
	PUSH P,FILINF+DDMPTM	;PRESERVE POSSIBLY CHANGED DUMP WORD
	MTAPE FILE,['GODMOD'	;READ THE RETRIEVAL FOR REAL
			14	;(UFD "RETRIEVAL" IS NOT COMPLETE)
		     IOWD 20,FILINF]
	 JFCL			;CANT LOSE. HA HA.
	POP P,FILINF+DDMPTM
>;IFN FTLUFD
>;IFN STANSW
GFDMP1:	TLZ FL,IGNEOT		;CAN'T IGNORE THE END OF TAPE
	MOVE D,[FILINF+DDNAM,,A] ;GET THE NAME
	BLT D,D
	PUSHJ P,TYFIL		;AND TYPE THE NAME.
	SKIPE PPURGE		;SKIP UNLESS PHONY PURGE
	JRST GFDP2A		;DON'T DUMP IF PHONY PURGE/DEBUGGING
IFN STANSW,<
	MTAPE FILE,RDOFFS	;READ OFFSET FROM THE OFFSET BLOCK.
	MOVE A,RDOFFS+2		;GET THE OFFSET NUMBER.
	MOVEM A,FILINF+DDOFFS	;SAVE IT IN THE RETRIEVAL.
>;IFN STANSW
	TLZN FL,MCLOSE		;IS THIS FIRST OPERATION ON MT FILE?
	JRST GFDMP2		;NO. NOT THE FIRST
	MOVE A,WRCSZ		;get record size
	MOVEM A,WC	
	SETZM MTFILN		;ZERO RECORD COUNT INSIDE FILE
	MOVE A,FILINF+DDNAM
	MOVEM A,MEMSAV+FFILE
	HLLZ A,FILINF+DDEXT
	MOVEM A,MEMSAV+FFEXT
	MOVE A,(Q)
	MOVEM A,MEMSAV+FUSER
GFDMP2:

IFN STANSW,<
	MOVEI A,2
	SUB A,FILINF+DDOFFS
	USETI FILE,(A)		;USETI TO THE FIRST REAL RECORD.
>;IFN STANSW

	PUSHJ P,DUMP		;DUMP THE FILE.
	 JRST GFREDX		;OOPS.	WE HIT EOT.
GFDP2A:	CLOSE FILE,NUPACC	;RELEASE USER'S FILE.
	MOVE S,ALLPTR		;GET POINTER TO ALLBUF
	MOVE L,MTAPNO		;TAPE NUMBER+ IF T THEN 400000
	TRO L,200000		;MARK DUMPED THIS TIME(DATE FOLLOWS)
	HRRM L,(S)		;SAVE IT.
	LDB A,PDATE		;GET THE FILE WRITE DATE
	LDB B,PDATEH		;HIGH DATE - DATE75
	DPB B,[POINT 3,A,23]	;STUFF HIGH DATE - DATE75
	PUSH S,A		;SAVE THE DATA
	MOVEM S,ALLPTR		;PUT BACK POINTER TO ALLBUF
	MOVE D,[FILINF+DDNAM,,A] ;GET THE NAME INTO A,B,C,D
	BLT D,D
	MOVE W,FILINF+DREFTM	;GET THE REFERENCE TIME
	DATE K,			;GET THE DATE
	DPB K,PDDATE		;SAVE DATE
	DPB L,PTAPEN		;SAVE THE REEL NUMBER
	MOVSI L,420000
	MOVE X,FILINF+DDMPTM
	TLZE X,20000		;CLEAR DUMP DATE INVALID
	JRST GFDP3A
	ANDCAM L,FILINF+DDMPTM	;CLEAR TDUMP AND INVALID.
	MOVSI L,400000
	TRNN FL,PCLASS		;IS THIS PERMANENT?
	IORM L,FILINF+DDMPTM	;TURN ON THE TDUMP BIT.
	LDB L,PCOUNT		;GET THE COUNT
	ADDI L,1
	CAILE L,7
	MOVEI L,7
	TRNN FL,PCLASS		;ONLY INCREMENT FOR PCLASS DUMPS
	MOVEI L,0
	DPB L,PCOUNT
	MOVE X,FILINF+DDMPTM	;GET THE OLD DUMP TIME

GFDP3A:
IFE STANSW,<
	MOVEM X,LKBLK+.RBNCA
>;IFE STANSW
	SKIPN NOREAP		;Skip if deletion of reaped files is disabled
	TRNN FL,PCLASS		;Skip if Permanent-class dump
	JRST GDP3AA		;We're not gonna reap-delete this file
	LDB L,PCOUNT		;HOW OFTEN P-DUMPED
	TLNE X,REAPBT		;REAP BIT ON?
	CAIGE L,2		;YES, DUMPED TWICE?
	JRST GDP3AA		;NOT REAPING, OR NOT DUMPED TWICE
	JRST GFDP3B		;YES, TREAT LIKE PURGE
GDP3AA:	TRNE FL,PURCOM
	JRST GFDP3B
IFN DBGSW,<
	JRST GFDP3B
>;IFN DBGSW
IFN STANSW,<
	RENAME FILE,A		;LONG RENAME TO UPDATE DUMPTIME
>;IFN STANSW
IFE STANSW,<
	RENAME FILE,LKBLK
>;IFE STANSW
	 OUTSTR [ASCIZ/ - RENAME to update dump time failed. /]
GFDP3B:	MOVE S,REELPT		;GET POINTER TO REEL BLOCK
	PUSH S,FILINF+DDNAM	;SAVE THE FILE NAME
	LDB A,PDATE		;GET THE FILE WRITE DATE
	LDB B,PDATEH		;HIGH DATE - DATE75
	DPB B,[POINT 3,A,23]	;STUFF HIGH DATE - DATE75
	HLL A,FILINF+DDEXT	;GET THE EXTENSION.
	PUSH S,A		;SAVE THE DATA
	MOVEM S,REELPT		;SAVE REEL POINTER
	TRNE FL,PURCOM
	SKIPE PPURGE
	JRST .+2		;NOT PURGE, OR PHONY PURGE
	JRST GFDMP3		;IN PURGE, CLOSE MTA AFTER EACH FILE
	SKIPN PPURGE		;DON'T REAP IF PPURGE
	TRNN FL,PCLASS
	JRST GDP3BA		;JUMP UNLESS P-CLASS
	SKIPE NOREAP		;Skip unless deletion of reaped files is disabled
	JRST GDP3BA		;No reap-deletion here
	LDB L,PCOUNT		;HOW OFTEN P-DUMPED
	MOVE X,FILINF+DDMPTM
	TLNE X,REAPBT		;REAP BIT ON?
	CAIGE L,2		;YES, DUMPED TWICE?
	JRST GDP3BA		;NOT REAPING, OR NOT DUMPED TWICE
	JRST GFDMP3		;YES, TREAT LIKE PURGE
GDP3BA:	HLLO S,S
	AOJE S,GFDMP3		;REELPTR IS ABOUT TO OVERFLOW
	MOVE A,MTFILN		;HOW MANY RECORDS ON THIS TAPE?
	CAIL A,100		;
	JRST GFDMP3		;MT FILE IS LONG ENOUGH. CLOSE IT.
	OUTSTR CRLF
	PUSHJ P,DPYSER		;DISPLAY USER NAME ON DPY
	 MEMSAV+LUSER,,DPYPPN	;PPN ONLY (ALSO NO. OF FEET)
	JRST GETFIL

NNFIL:	CLOSE UFD,		;NO FILES LEFT IN UFD. CLOSE IT
	TLO FL,UFDEOF		;END OF FILE ON UFD
GFDMP3:	SKIPN PPURGE		;DON'T FUTZ MTA IF PHONY PURGE
	TLNE FL,MCLOSE		;AVOID CLOSE IF ALREADY CLOSED
	JRST GFDMP4
	PUSHJ P,MT2CLZ		;TIME TO CLOSE TAPE FILE.
	PUSHJ P,MT2CTS		;skip if EOF written OK, remember where written
	 JRST GFREDO		;phys end of tape (SHIT, WHAT A BAD TIME TO LOSE)
GFDMP4:	TRNE FL,PURCOM		;PURGE?
	JRST GFDP4A		;YES. DO SPECIAL
	SKIPN NOREAP		;Skip if deletion of reaped files is disabled
	TRNN FL,PCLASS		;Skip if Permanent-class dump
	JRST GDP4BA		;We're not gonna reap-delete this file
	LDB L,PCOUNT		;HOW OFTEN P-DUMPED
	MOVE X,FILINF+DDMPTM
	TLNE X,REAPBT		;REAP BIT ON?
	CAIGE L,2		;YES, DUMPED TWICE?
	JRST GDP4BA		;NOT REAPING, OR NOT DUMPED TWICE
	JRST GFDP4A		;YES, TREAT LIKE PURGE

GDP4BA:	PUSHJ P,ALLMEM		;UPDATE ALLDIR.MEM
	SETZM MEMSAV+CHKNUM	;PICKUP CLASS 0
	PUSHJ P,SAVMEM
GFDP4B:	TLZE FL,UFDEOF		;WAS THIS END OF FILE ON UFD?
	JRST GFDP4C		;YES.
	TLON FL,MCLOSE		;REMEMBER THAT WE JUST CLOSED TAPE
	OUTSTR CRLF		;CRLF FOR DONE WITH FILE.
	PUSHJ P,DPYSER		;DISPLAY USER NAME ON DPY
	 MEMSAV+LUSER,,DPYPPN	;PPN ONLY (ALSO NO. OF FEET)
	JRST ALLINI		;CONTINUE THE DUMP OF THIS AREA

GFDP4C:	TLO FL,MCLOSE		;WE'LL HAVE TO OPEN A NEW MTA FILE
	POPJ P,			;YES. RETURN.

GFDP4A:	PUSHJ P,ALLMEM		;SAVE REEL DATA (IN ALLDIR.MEM)
	SKIPN PPURGE		;OR PHONY PURGE?
	TLNE FL,UFDEOF		;END OF UFD?
	JRST GFDP4B		;YES - NOTHING TO DELETE
	MOVEI A,0
	MOVE D,(Q)		;GET PPN
IFN DBGSW,<
	JRST GFDP4B
>;IFN DBGSW
	MOVE X,FILINF+DDMPTM
	TLNE X,REAPBT		;REAP BIT ON?
	PUSHJ P,REAPLG		;Yes, log this reaped file
	RENAME FILE,A
	 OUTSTR [ASCIZ/ - DELETE failed /]
	JRST GFDP4B

TAPCMP:	MOVE B,MEMSAV+TTCNT
TAPCP1:	JUMPE B,CPOPJ		;DIRECT RETURN IF NOT IN THIS DUMP
	HLRZ C,MEMSAV+TTBUF-1(B) ;LOW BOUND
	HRRZ D,MEMSAV+TTBUF-1(B) ;HIGH BOUND
FIXPDU:	CAIA			;PATCH THIS TO JFCL WHEN RESTARTING P-DUMP AFTER FIRST TAPE
	TRNN FL,PCLASS		;SKIP IF PERMANENT DUMP
	CAMG A,D		;SKIP IF A TOO HIGH
	CAMGE A,C		;SKIP IF A IS NOT LOW ENOUGH
	SOJA B,TAPCP1		;OUT OF BOUNDS. TRY ANOTHER TERM
	JRST CPOPJ1		;TAPE WAS INCLUDED IN THIS DUMP.

PUTEST:	HRRZ R,TBASE		;BASE OF ALL PURGE TERMS SCANNED
	JRST .+2
PUTST0:	ADDI R,FSLEN
	CAML R,FSPTR		;FIRST ADDRESS ABOVE PURGE TERMS
	JRST GETFIL		;THERE ARE NO PURGE TERMS (LEFT ANYMORE)
	MOVE A,FSDEV(R)
	CAME A,STRNAM		;DEVICE NAME MATCHES THIS STRUCTURE?
	JRST PUTST0		;NO.  GET NEXT TERM
	MOVE B,FSEXT(R)		;GET FLAGS
	MOVE A,(Q)		;GET PROJ,PROG
	CAMN A,FSPPN(R)		;MATCHES THIS TERM EXACTLY?
	JRST PUTST1		;YES.  LOOK FURTHER
	HRRZ C,FSPPN(R)
	CAIE C,(A)
	TRNE B,ALLPRG
	JRST .+2		;PRG MATCHES OR IS *
	JRST PUTST0		;PRG DOESN'T MATCH.
	HLRZ A,(Q)
	HLRZ C,FSPPN(R)
	CAIE A,(C)
	TRNE B,ALLPRJ
	JRST PUTST1		;THIS MATCHES SOMEWHAT
	JRST PUTST0

PUTST1:	MOVE A,1(R)
	CAME A,FILBLK
	TRNE B,ALLFIL
	JRST .+2
	JRST PUTST0
	HLLZ A,FILBLK+1
	HLLZ C,2(R)
	CAME A,C
	TRNE B,ALLEXT
	JRST .+2
	JRST PUTST0
;ACCEPT THIS FILE NAME.
	TRNE B,ALLEXT!ALLFIL!ALLPRJ!ALLPRG ;ANYTHING WILD?
	JRST PUTST2		;YES.  WE'LL HAVE TO KEEP THIS TERM
	HRLI R,FSLEN(R)		;SOURCE IN R LEFT, DEST IN RIGHT
	MOVNI B,FSLEN
	ADDB B,FSPTR		;CALC ENDING ADDRESS+1
	BLT R,-1(B)		;POSSIBLY MOVE "NOTHING"
PUTST2:	MOVE A,FILBLK
	HLLZ B,FILBLK+1
	MOVE D,(Q)
	SKIPN PPURGE		;PHONY PURGE?
	JRST GFLOOK		;REAL PURGE
	MOVE B,FILBLK+1
	MOVE C,FILBLK+2		;DATE AND TIME FROM UFD
	MOVE Y,[A,,FILINF]	;HERE IF DOING PHONY PURGE!
	BLT Y,FILINF+3		;STUFF NAME,EXT,PPN WHERE THEY'RE NEEDED
	JRST GFDMP1	

	RADIX 5+5
MONTHB:	0			;JAN
	31			;FEB
	59			;MAR (ASSUMING LEAP YEAR!)
	90			;APR
	120			;MAY
	151			;JUN
	181			;JUL
	212			;AUG
	243			;SEP
	273			;OCT
	304			;NOV
	334			;DEC
	RADIX 5+3

;CALL WITH A CONTAINING SYSTEM FORMAT DATE.
;RETURN A CONTAINING NUMBER OF DAYS SINCE JAN 1, 1964
;B AND D CLOBBERED
DATCNV:	IDIVI A,37		;DAY OF THE MONTH INTO B
	MOVEI D,1(B)		;DAY INTO D
	IDIVI A,14		;MONTHS IN B, YEARS IN A
	ADD D,MONTHB(B)		;ADD NUMBER OF DAYS BEFORE THE 1st OF MONTH
	TRNN A,3		;SKIP UNLESS LEAP YEAR
	CAIGE B,2		;LY. SKIP IF AFTER FEBRUARY
	SUBI D,1		;NOT LEAP YEAR. OR BEFORE MARCH
	MOVEI B,3(A)
	LSH B,-2		;NUMBER OF LY SINCE '64 NOT INCLUDING THIS YEAR
	IMULI A,555		;NUMBER OF YEARS TIMES 365
	ADDI A,(B)		;PLUS NUMBER OF PRIOR LEAP YEARS
	ADDI A,(D)		;PLUS NUMBER OF DAYS SO FAR THIS YEAR.
	POPJ P,


;Routine to record name of file being reaped in REAPED.LOG[DMP,SYS].
REAPLG:	PUSH P,A		;Save some ACs so we can play around
	PUSH P,B
	PUSH P,C
	PUSH P,D
	OUTSTR [ASCIZ/ - Reaping /]
	SETOM REAPLS		;Force output to reap-log file
	SKIPE REAPOP		;Is reap log file open?
	JRST REAPL2		;Yes, avoid re-opening it
	SETZM LOGBUF
	MOVE A,[LOGBUF,,LOGBUF+1]
	BLT A,LOGBUF+200	;Clear whole buffer plus extra word at end
	MOVEI A,GARBIT!17	;Dump mode
	MOVSI B,'DSK'
	MOVEI C,0
	OPEN REAPCH,A		;Open channel for reap log file in dump mode
	 JRST REAPLX		;Lost!  Give up.
	MOVE D,[REAPNM,,A]
	BLT D,B			;Get reap log filename into A and B
	MOVE D,DUMPER		;Put onto dumper's disk area
	LOOKUP REAPCH,A		;Open reap log file
	 JRST LOGIT0		;Maybe doesn't exist yet
	MOVS D,D		;Unswap the word count
	MOVN D,D		;Make wc positive
	SOJL D,LOGZ0		;JUMP IF FILE EMPTY
	LSH D,-7
	ADDI D,1		;CALCULATE RECORD NUMBER
	MOVEM D,LOGPTR
	USETI REAPCH,@LOGPTR
	IN REAPCH,LOGCMD	;Read (up to) 200 words into LOGBUF
	 JRST LOGOUT
	STATO REAPCH,IOEOF	;EOF IS OK.
	 JRST REAPLX		;Oh well, some error, skip log file
	JRST LOGOUT

LOGIT0:	TRNE B,-1		;Skip if LOOKUP error was file not found
	JRST REAPLX		;BARF (WASN'T FILE NOT FOUND), give up
LOGZ0:	SETZM LOGPTR
	AOS LOGPTR		;SET POINTER TO RECORD 1
LOGOUT:	MOVE D,[REAPNM,,A]	;Get filename again
	BLT D,C			; into ACs A thru C
	MOVE D,DUMPER		;Put onto dumper's disk area
	ENTER REAPCH,A		;Open log file for output
	 JRST REAPLX		;CAN'T READ/ALTER THE FILE, give up
	SETOM REAPOP		;OK, file is finally open
	MOVE B,[POINT 7,LOGBUF]	;LOOK FOR NULL BYTE AT END
LOGZ:	ILDB A,B
	JUMPN A,LOGZ		;Loop until see null (note zero word after buffer)
	ADD B,[70000,,0]	;BACKUP WHEN WE SEE ONE
	JUMPG B,.+2
	SUB B,[430000,,1]	;Backup to final byte of previous wd, for end test
	MOVEM B,LOGBP
	MOVEI B,CRLF
	PUSHJ P,STROUT		;Output CRLF
	DATE A,			;Get current date
	PUSHJ P,TYDATE		;Output date to file
	MOVEI B,CRLF
	PUSHJ P,STROUT		;Output CRLF
REAPL2:	TIMER A,		;Get time in ticks
	IDIVI A,74*74		;Want time in minutes
	PUSHJ P,TYTIME		;Put out time of day
	MOVEI A,11		;A tab
	PUSHJ P,OUT.CH		;Put out tab
	MOVE D,[FILINF+DDNAM,,A] ;GET THE NAME INTO A,B,C,D
	BLT D,D
	PUSHJ P,TYFIL		;Put out filename
	MOVEI A,11
	PUSHJ P,OUT.CH		;Output a tab
	MOVE A,FILINF+DDLNG	;Get file length
	PUSHJ P,DECOUT		;Output in decimal
	MOVEI B,CRLF
	PUSHJ P,STROUT		;Put out CRLF
	USETO REAPCH,@LOGPTR	;Write out buffer to make sure file is up to date
	OUTPUT REAPCH,LOGCMD	;Write 200 words from LOGBUF
IFN STANSW,<
	MTAPE REAPCH,UPDRET	;Update retrieval of file
>;IFN STANSW
REAPLX:	SETZM REAPLS		;No longer outputting text to reap log
	POP P,D
	POP P,C
	POP P,B
	POP P,A
	POPJ P,

REAPSR:	HRLI B,440700		;PICKUP A BYTE POINTER
REAPS1:	ILDB A,B
	JUMPE A,CPOPJ
	PUSH P,[REAPS1]		;FORCE RETURN TO REAPS1
REAPOU:	PUSH P,B
	MOVE B,LOGBP		;Get output byte pointer
	CAME B,[POINT 7,LOGBUF+177,34] ;END OF BUFFER?
	JRST LOGOK		;NO
	USETO REAPCH,@LOGPTR	;Yes, write out buffer to make room for new char.
	OUTPUT REAPCH,LOGCMD	;Write 200 words from LOGBUF
	SETZM LOGBUF
	MOVE B,[LOGBUF,,LOGBUF+1]
	BLT B,LOGBUF+200	;Clear whole buffer plus extra word at end
	MOVE B,[POINT 7,LOGBUF]
	AOS LOGPTR		;Next record number
LOGOK:	IDPB A,B
	MOVEM B,LOGBP
	POP P,B
	POPJ P,

REAPCL:	SKIPE REAPOP		;Reap log file open?
	RELEAS REAPCH,		;Yes, close it
	SETZM REAPOP		;Not open now
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    subttl	what to do at end of tape	 ; GFREDX GFREDO PIK4 PIK5 NOMTA8 GFRED1 GFRD1A GFRED2 PIK0A GFRED4 GFRED5 GFRED6 GFPICK PIK0

GFREDX:	CLOSE	FILE,NUPACC
GFREDO:	OUTSTR	[ASCIZ/	not saved. - Physical end of tape.
/]
	MOVE	A,REELPT
	MOVEM	A,MEMSAV+PTRSAV		;SAVE REELPT (BEFORE PIK4!)
	PUSHJ	P,REAPCL		;Close reap log file
PIK4:	MOVEI	A,4
	MOVEM	A,MEMSAV+CHKNUM
	SETZM	PICKON
	PUSHJ	P,SAVMEM		;SAVE STATE
	PUSHJ	P,FIXPOS		;FIX THE MTAPE POSITION.
	TLO	FL,IGNEOT		;TURN ON THE IGNORE EOT INDICATOR
	PUSHJ	P,TAPTAI		;WRITE A TAPE TAIL
	TLZ	FL,IGNEOT		;
PIK5:	MOVEI	A,5
	MOVEM	A,MEMSAV+CHKNUM
	SETZM	PICKON
	PUSHJ	P,SAVMEM
IFN DBGSW,<
	SKIPE	DBGNTP
	JRST	NOMTA8
>;IFN DBGSW
	PUSHJ	P,MT2REW		;REWIND THE TAPE
	GETSTS	MTA2,A
	TRZ	A,IOIMPM+IOTEND		;CLEAR SOME BITS
	SETSTS	MTA2,(A)		;SET STATUS.

;LOOP THROUGH THE FILES WE DUMPED AND RENAME THEM.
NOMTA8:	HLRO	Y,MEMSAV+PTRSAV		;GET THE COUNT
	ADDI	Y,REELBF+177
	HLL	Y,MEMSAV+PTRSAV		;GET THE COUNT AGAIN.
GFRED1:	POP	Y,B			;LOAD EXTENSION
	POP	Y,A			;FILE NAME
	CAMGE	Y,[IOWD 177,REELBF+1]	;THIS IS SMALLEST LEGAL POINTER
	JRST	GFRED2			;JUMP IF SMALLER THAN SMALLEST LEGAL
	HLLZ	B,B
	SETZB	C,W
	SETZ	X,
	MOVE	D,REELBF		;GET PPN FROM HERE.
IFN STANSW,<
	LOOKUP	FILE,A			;DO EXTENDED LOOKUP
	 JRST	GFRD1A			;FILE NOT THERE.
	MOVE	D,REELBF
>;IFN STANSW
IFE STANSW,<
	MOVEM A,LKBLK+.RBNAM
	MOVEM B,LKBLK+.RBEXT
	MOVEM D,LKBLK+.RBPPN
	LOOKUP FILE,LKBLK
	 JRST GFRD1A
	MOVE X,LKBLK+.RBNCA
>;IFE STANSW
	TLO	X,20000			;SET DUMP DATE INVALID BIT
	MOVE	Z,[A,,FILBLK]
	BLT	Z,FILBLK+3
	CLOSE	FILE,NUPACC
IFN DBGSW,<
	JRST	GFRED1
>;IFN DBGSW
IFN STANSW,<
	RENAME	FILE,A
>;IFN STANSW
IFE STANSW,<
	MOVEM X,LKBLK+.RBNCA
	RENAME FILE,LKBLK
>;IFE STANSW
	 JRST [	OUTSTR [ASCIZ/
Unable to rename file to set dump date invalid. /]
		PUSHJ P,TYFIL
		OUTSTR CRLF
		JRST .+1]
GFRD1A:	CLOSE	FILE,NUPACC
	JRST	GFRED1

GFRED2:
	PUSHJ	P,PUTTAP		;UPDATE DART.TAP WITH CURRENT TAPE NUMBER.
	AOS	A,TAPNO			;INCREMENT FOR NEXT TAPE NUMBER.
	MOVEM	A,MEMSAV+TAPNUM
	PUSHJ	P,DOMOUNT		;REQUIRE MOUNT OPERATION NOW.

PIK0A:	MOVE	A,(Q)			;GET THE CURRENT USER NAME
	MOVSI	B,'UFD'
	SETZ	C,
	MOVE	D,GOD
	MOVE	X,[A,,FILBLK]
	BLT	X,FILBLK+3
	LOOKUP	UFD,A
	 JRST [	TRZ FL,SAFETY
		PUSHJ P,LCHECK
		JFCL
		POPJ P,]
GFRED4:	PUSHJ	P,UFDRD			;READ FROM UFD
	JRST	GETUD1			;HOPELESS CONFUSION. DO IT OVER.
	MOVEM	A,FILBLK
IFN STANSW,<
	MOVE	D,[-UFDN+1,,1]		;READ MORE
>;IFN STANSW
GFRED5:	PUSHJ	P,UFDRD
	JFCL
	MOVEM	A,FILBLK(D)
IFN STANSW,<
	AOBJN	D,GFRED5
>;IFN STANSW
	MOVE	A,FILBLK
	HLLZ	B,FILBLK+1
	CAMN	A,MEMSAV+FFILE		;SAME NAME
	CAME	B,MEMSAV+FFEXT		;AND EXTENSION
	JRST	GFRED4			;NO MATCH. KEEP LOOKING
	MOVE	S,[IOWD 200,REELBF]
	PUSH	S,(Q)
	MOVEM	S,REELPT
	MOVE	S,[IOWD 400,ALLBUF]
	PUSH	S,(Q)
	MOVEM	S,ALLPTR
	SETZM	1(S)
	SKIPN	PICKON
	JRST	GFRED6			;JUMP IF NOT DOING A PICKUP
	SETZM	PICKON			;THIS IS THE NAME WE LAST LOOKED AT
	JRST	GETFIL			;SO GET THE NEXT NAME.

GFRED6:	TRNN	FL,PURCOM		;SKIP IF PURGING.
	JRST	GETFL2			;JUMP TO CODE TO CONTINUE DUMPS.
	MOVE	D,(Q)			;GET PPN
	JRST	GFLOOK			;GO DUMP&PURGE - PUTEST ALREADY DONE

GFPICK:	SKIPG	A,MEMSAV+CHKNUM
	JRST	PIK0			;USUAL TYPE PICKUP.
	CAIN	A,4
	JRST	PIK4
	CAIN	A,5
	JRST	PIK5
	OUTSTR	[ASCIZ/Internal confusion - illegal PICKUP number at GFPICK
/]
	JRST	RESTAR

PIK0:	MOVE	A,MEMSAV+LFILE		;GET THE NAME OF THE LAST FILE INSPECTED
	MOVEM	A,MEMSAV+FFILE		;SAVE FOR GFRED4
	HLLZ	A,MEMSAV+LEXT
	MOVEM	A,MEMSAV+FFEXT		;SAVE EXTENSION TOO.
	JRST	PIK0A			;WHIZ
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               subttl	read in the mfd and sort it.	 ; MFDSOR MFDSR1 MFDSR2 MFDS21 MFSOR0 MFSOR1 MFSOR3 MFSSOR MFSSR1 MFSSR2 MFSSR3 MFDSR3 MFDSR4 MFDSR7 MFDSR5 MFDSR6

;Sort the MFD specially: programmers 2,3,SYS come first, then everybody else
;in order by: left justified programmer name and then by left justified project.
;We maintain two pointers into the insertion sort done so far:
;  Q/ first word beyond end of all PPNs in the list.
;  Z/ first word beyond end of special PPNs (which come before all other PPNs).
MFDSOR:	MOVE	A,GOD			;LOOKUP THE MFD
	MOVSI	B,'UFD'
	SETZ	C,
	MOVE	D,GOD
	MOVE	X,[A,,FILBLK]
	BLT	X,FILBLK+3
	TRZ	FL,SAFETY
	LOOKUP	UFD,A
	JRST	[PUSHJ P,LCHECK
		JFCL
		SETZM	MFDPTR
		CLOSE	UFD,
		POPJ	P,]
IFN STANSW,<
	MOVEI	A,UFD
	SHOWIT	A,			;display MFD on wholine
>;IFN STANSW
IFN DBGSW,<
	MOVEI	A,7			;DEBUGIING: ONLY READ THIS MANY MFD ENTRIES
	MOVEM	A,DBGMFC
>;IFN DBGSW
	MOVE	Q,.JBFF			;GET POINTER TO WHERE TO STUFF THE STUFF
	MOVEI	Z,(Q)			;.JBFF HERE TOO
MFDSR1:	PUSHJ	P,UFDRD			;READ DATA
	JRST	MFDSR5			;END OF FILE.
	JUMPE	A,MFDSR3		;FLUSH 3 MORE TERMS.
IFE STANSW,<
	CAMN A,GOD
	JRST MFDSR3			;I DON'T SEE WHY TO SAVE UFDS
>;IFE STANSW
IFN DBGSW,<
	SOSGE	DBGMFC			;ONLY READ PART OF MFD
	JRST	MFDSR5
>;IFN DBGSW
	CAMGE	Q,.JBREL		;ARE WE IN BOUNDS?
	JRST	MFDSR2			;YES.
	MOVE	B,.JBREL		;NO. PICKUP .JBREL
	ADDI	B,2000			;ADD ANOTHER K
	CORE	B,			;CORE UP
	JRST	NOCORE
MFDSR2:	HRRZ	B,A			;SAVE PRG
	HLRZ	C,A			;SAVE PRJ
	PUSHJ	P,UFDRD			;READ
	SETZ	A,
	HLLZ	A,A
	CAME	A,['UFD   ']
	JRST	MFDSR4
	JUMPE	C,MFDSR4
	JUMPE	B,MFDSR4
IFN IRCPPN,<
	TRNE B,777740
	TRNN C,777740
	JRST MFDS21			;RIDICULOUS IRCAM PPNS!
	TRNN C,77
	JRST MFDS21
>;IFN IRCPPN
IFN STANSW!IRCPPN,<
	TRNE	B,770000		;LEFT ADJUST THE PRG
	JRST	.+3
	LSH	B,6
	JUMPN	B,.-3
	TRNE	C,770000
	JRST	.+3
	LSH	C,6
	JUMPN	C,.-3
>;IFN STANSW!IRCPPN
MFDS21:	HRLZ	A,B
	HRR	A,C			;A HAS KLUGED UP COPY OF PPN.
IFN IRCPPN,<
	TDO A,[400000,,400000]		;LOGICAL COMPARES NOT ARITH
>;IFN IRCPPN
IFN STANSW,<
	CAIE	B,'SYS'			;IS THIS SPECIAL?
	CAIN	B,'3  '			;SPECIAL
	JRST	MFSSOR			;YES.
	CAIN	B,'2  '			;SPECIAL?
	JRST	MFSSOR			;YES.
>;IFN STANSW
;Here with non-special user.
;Bubble it up through the non-special part of list.
;Stop if we reach the special part of the list (Z).
;Q points to the end of the whole list.
MFSOR0:	MOVEI	B,(Q)			;INSERTION SORT THE NEW ITEM
MFSOR1:	CAILE	B,(Z)			;ARE WE OFF THE END?
	CAML	A,-1(B)			;
	JRST	MFSOR3			;OFF THE END. OR CORRECT POSITION.
	MOVE	X,-1(B)			;PICKUP A BIG TERM
	MOVEM	X,(B)			;AND SAVE IT IN THE HOLE
	SOJA	B,MFSOR1

MFSOR3:	MOVEM	A,(B)			;SAVE THIS PPN.
	AOJA	Q,MFDSR4

IFN STANSW,<
;Here we have a special user (2, 3, or SYS).  We insert it in place of the
;first non-special user, which goes to the end of the whole list.  Then we
;bubble the special user up through the special list, and after that we bubble
;the non-special user (that we displaced) up through the non-special list.
MFSSOR:	MOVEM	A,(Q)			;SAVE FOR END CASE.
	EXCH	A,(Z)			;SAVE NEW PPN WHERE WE'LL SEE IT.
	MOVEM	A,(Q)			;RESET
	MOVEI	B,(Z)
	MOVE	A,(Z)
MFSSR1:	CAMG	B,.JBFF
	JRST	MFSSR3			;OFF THE EDGE OF THE WORLD
	MOVE	X,A
	XOR	X,-1(B)
	JUMPL	X,[JUMPL A,MFSSR3	;JUMP IF DIFFERENT SIGNS 
		JRST MFSSR2]		;IF A NEGATIVE THEN DONE. ELSE EXCH
	CAML	A,-1(B)
	JRST	MFSSR3
MFSSR2:	MOVE	X,-1(B)
	MOVEM	X,(B)
	SOJA	B,MFSSR1

MFSSR3:	MOVEM	A,(B)
	MOVE	A,(Q)
	AOJA	Z,MFSOR0		;WOW. Go handle displaced non-special user
>;IFN STANSW

MFDSR3:	PUSHJ	P,UFDRD			;FLUSH EXTENSION.
	 JFCL
MFDSR4:
IFN STANSW,<
	MOVE	D,[-UFDN+2,,2]
MFDSR7:	PUSHJ	P,UFDRD			;FLUSH REST OF DIRECTORY ENTRY
	JFCL
	AOBJN	D,MFDSR7
>;IFN STANSW
	JRST	MFDSR1			;LOOP UNTIL FILE EXHAUSTED.

MFDSR5:	MOVE	A,.JBFF			;GET OLD .JBFF
	SUBI	A,(Q)			;GET -WC IN A.
	EXCH	Q,.JBFF			;OLD .JBFF INTO Q TOO.
	HRL	Q,A
	MOVEM	Q,MFDPTR		;SAVE MFD POINTER.
MFDSR6:
IFN STANSW!IRCPPN,<
	HLLZ	B,(Q)			;GET THE FUNNY PRG
	HRRZ	C,(Q)			;AND THE FUNNY PRJ
	TLNE	B,77	
	JRST	.+3
	LSH	B,-6
	JRST	.-3
	TRNE	C,77
	JRST	.+3
	LSH	C,-6
	JRST	.-3
	HLL	C,B
IFN IRCPPN,<
	TDZ C,[400000,,400000]
>;IFN IRCPPN
	MOVSM	C,(Q)
	AOBJN	Q,MFDSR6
>;IFN STANSW!IRCPPN
IFN DBGSW,<
	MOVE	Q,MFDPTR		;PICK UP MFD POINTER
	AOBJN	Q,.+1			;THROW AWAY FIRST ENTRY ([2,2])
	MOVEM	Q,MFDPTR
>;IFN DBGSW
IFN STANSW,<
	MOVEI	A,200000		;turn off wholine filestatus
	SHOWIT	A,
>;IFN STANSW
	POPJ	P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             subttl preservation of dumping information ; ALLMIN ALLMI1 ALLMI2 ALLMEM REELMX REELM0 REEL00 REELM1

;ENTER HERE TO INITIALIZE ALLDIR.MEM, ASSUMING IT ALREADY EXISTS!
ALLMIN:	MOVE A,['ALLDIR']
	MOVSI B,'MEM'	
	MOVEI C,0
ALLMI1:	MOVE D,DUMPER
IFN STANSW,<
	LOOKUP MEM,A
>;IFN STANSW
IFE STANSW,<
	MOVEM A,LKBLK+.RBNAM
	MOVEM B,LKBLK+.RBEXT
	MOVEM D,LKBLK+.RBPPN
	LOOKUP MEM,LKBLK
>;IFE STANSW
	 JRST [	OUTSTR [ASCIZ/I can't find ALLDIR.MEM !!
/]
		HALT ALLMI1]
IFN STANSW,<
	MOVS D,D
>;IFN STANSW
IFE STANSW,<
	MOVE D,LKBLK+.RBSIZ
>;IFE STANSW
	MOVMM D,ALLSIZ		;GET FILE SIZE
ALLMI2:
IFN STANSW,<
	MOVE D,DUMPER
	ENTER MEM,A		;GET IT OPEN FOR READ-ALTER
>;IFN STANSW
IFE STANSW,<
	ENTER MEM,LKBLK
>;IFE STANSW
	 JRST [	OUTSTR [ASCIZ/ENTER to open ALLDIR.MEM for read-alter failed.
/]
		HALT ALLMI2]
	MOVE A,ALLSIZ
	IDIVI A,200		;REMAINDER IN B
	JUMPE B,CPOPJ		;EXACT BUFFER BOUNDARY, DON'T PRIME BUFFER
	USETI MEM,1(A)
	INPUT MEM,[IOWD 200,MEMBLK
			0]	;PRIME BUFFER WITH LAST RECORD
	POPJ P,


ALLMEM:	MOVEI S,ALLBUF		;ADDRESS OF DATA BASE
	HLRO TX,ALLPTR		;GET THE COUNT
	ADDI TX,400		;ADD THE OFFSET
	HRR A,ALLPTR
	CAIG TX,1		;MORE THAN ONE ITEM TO DUMP?
	POPJ P,			;NO. IGNORE THIS
	ADDI TX,1		;COUNT ONE MORE THING TO DUMP
	SETZM 1(A)		;AND ZERO THE LAST CELL
	MOVE D,ALLSIZ		;GET FILE SIZE
	IDIVI D,200		;REMAINDER IN W. 
	MOVEI X,(D)		;SAVE USET POINTER
;NOW. TX CONTAINS THE NUMBER OF WORDS TO BLT. W CONTAINS INDEX TO MEMBLK
	MOVSI A,(S)		;GET THE DATA SOURCE.
	HRRI A,MEMBLK(W)	;DATA DESTINATION
	MOVEI B,MEMBLK(W)	;GET THE DESTINATION AGAIN
	ADDI B,-1(TX)		;NUMBER OF WORDS TO MOVE
	BLT A,(B)		;DO THE BLT.
	USETO MEM,1(X)		;DO A USET TO WRITE THE RECORD.
	ADDI W,(TX)		;COMPUTE WORD COUNT OF RECORD.
	MOVN W,W		;NEGATE WORD COUNT
	HRLZ W,W		;-WC IN LEFT SIDE
	HRRI W,MEMBLK-1		;MA-1 IN RIGHT
	MOVEI X,0		;STOP THE DUMP MODE COMMAND LIST
	OUTPUT MEM,W
IFN STANSW,<
	MTAPE MEM,['GODMOD'
			17]	;UPDATE RETRIEVAL, TO AVOID CRASH LOSSAGE
>;IFN STANSW
	ADDM TX,ALLSIZ		;ADD NEW STUFF INTO ALLSIZ
	HLRO W,W
	MOVM W,W		;GET WORD COUNT BACK
	IDIVI W,200		;REMAINDER IN X
	JUMPE X,CPOPJ		;NO PARTIAL BUFFER : RETURN
	JUMPE W,CPOPJ		;PARTIAL BUFFER ALREADY AT LOW END
	IMULI W,200		;GET DISTANCE TO BLT
	MOVSI W,MEMBLK(W)	;DATA SOURCE
	HRRI W,MEMBLK		;DATA DESTINATION
	MOVEI X,MEMBLK-1(X)	;LAST DESTINATION
	BLT W,(X)		;SUFFLE PARTIAL BUFFER TO LOW END
	POPJ P,			;RETURN, SMILING.

REELMX:	TRZ FL,PCLASS		;ENTER HERE FOR MRESTORE
	MOVE A,TAPNO
	TRZN A,400000
	TRO FL,PCLASS
	MOVEM A,TAPNO
REELM0:	MOVE A,TAPNO		;GET THE TAPE NUMBER
	MOVEM A,MEMSAV+TAPNUM	;THIS SHOULDN'T BE NEEDED.
	PUSHJ P,REEL00		;convert number in A to sixbit in D
	MOVE A,TAPNO
	TRNN FL,PCLASS
	TRO A,400000
	MOVEM A,MTAPNO		;SAVE SPECIAL VERSION OF TAPE NUMBER
	MOVEM D,TAPNAM		;SAVE NAME OF THE TAPE.
	POPJ P,

;Turn tape number in A into sixbit for filename, in D.
REEL00:	MOVE C,[POINT 6,D,35]
	MOVE D,['P00000']
	TRNN FL,PCLASS
	HRLI D,'T00'
REELM1:	IDIVI A,12
	ADDI B,'0'
	DPB B,C
	ADD C,[060000,,0]
	CAME C,[360600,,D]
	JUMPN A,REELM1
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          subttl save dump status for pickups. ; SAVMEM SAVME2 SAVME4 SAVME6 SAVORA SAVME3 SAVME5 SAVME7 RDMEM RDMEM2 RDMEM3 CHKLOK SAVINP SAVOUP SAVILL SAVINL SAVINE SAVINO

SAVMEM:	TLON FL,DMEMRA		;SET/SKIP ON DART.MEM ALREADY OPEN RA
	JRST SAVORA		;GO OPEN IT UP IN READ ALTER
	USETO DSKMEM,1		;POSITION TO FIRST RECORD
	OUTPUT DSKMEM,[IOWD 200+MEMLEN,REELBF
			0]
	POPJ P,


SAVME2:	OUTSTR [ASCIZ/%%% ENTER to make DART.MEM has lost.
/]
	HALT SAVME3

SAVME4:	OUTSTR [ASCIZ/%%% I can't find the DART.MEM I just created !!
/]
	HALT SAVME5

SAVME6:	OUTSTR [ASCIZ/%%% ENTER to open DART.MEM for read-alter failed.
/]
	HALT SAVME7


SAVORA:	MOVE A,['DART  ']
	MOVSI B,'MEM'
	MOVEI C,0
	MOVE D,DUMPER
SAVME3:	ENTER DSKMEM,A		;CREATE DART.MEM
	 JRST SAVME2
	OUTPUT DSKMEM,[IOWD 200+MEMLEN,REELBF ;OUTPUT FIRST TIME
			0]
	CLOSE DSKMEM,		;CLOSE, TO CREATE DIRECTORY ENTRY
	MOVE D,DUMPER
SAVME5:	LOOKUP DSKMEM,A		;GO FIND IT AGAIN
	 JRST SAVME4
	MOVE D,DUMPER
SAVME7:	ENTER DSKMEM,A		;AND OPEN IT FOR READ-ALTER
	 JRST SAVME6
	POPJ P,

RDMEM:	MOVE A,['DART  ']
	MOVSI B,'MEM'
	MOVEI C,0
	MOVE D,DUMPER
	LOOKUP DSKMEM,A		;SEEK FILE.
	 POPJ P,
RDMEM2:	MOVE D,DUMPER
	ENTER DSKMEM,A
	 JRST RDMEM3
	TLO FL,DMEMRA		;SET DART.MEM OPEN IN READ ALTER
	INPUT DSKMEM,[IOWD 200+MEMLEN,REELBF
			0]
	STATZ DSKMEM,740000
	JRST [	OUTSTR [ASCIZ/Input error DSK:DART.MEM. We can't PICKUP.
/]
		RELEAS DSKMEM,
		JRST CPOPJ1]
	HRRZ A,MEMSAV+DCLASS
	MOVEM A,CLASS
	HLRZ A,MEMSAV+DCLASS
	ANDI A,FULL!PCLASS
	TRZ FL,FULL!PCLASS
	IORI FL,(A)		;TURN ON THE FLAGS
	MOVE A,MEMSAV+MMTDEV
	MOVEM A,MTDEV		;SAVE DEVICE NAME.
	MOVE A,MEMSAV+TAPNUM
	MOVEM A,TAPNO
	JRST CPOPJ2

RDMEM3:	OUTSTR [ASCIZ/%%% ENTER to remake DART.MEM has lost.
/]
	HALT RDMEM2

CHKLOK:	MOVE A,['NODUMP']
	MOVSI B,'PLS'
	MOVEI C,0
	MOVE D,DUMPER
	LOOKUP DSKMEM,A		;SEEK FILE.
	 TRNE B,-1		;skip if no such file
	POPJ P,			;file exists
	JRST CPOPJ1		;OK

;Save emergency backup copy of DART.MEM (during tape copy),
;as INPUT.MEM or OUTPUT.MEM (depending on which type of tape we've finished).
;One old version of each such *.MEM file (P00001 and OUTPUT) is also kept, as *.OMM.
SAVINP:	MOVE A,MEMSAV+MCITAP	;last input tape read
	PUSHJ P,REEL00		;generate sixbit form in D, e.g., P00001
	CAIA
SAVOUP:	MOVE D,['OUTPUT']
	SKIPN MASCOP
	POPJ P,			;not master tape copy
	MOVEI A,17
	MOVSI B,'DSK'
	MOVEI C,0
	OPEN DSKBAK,A		;BACKUP.MEM memory file
	 PUSHJ P,NODEV
	MOVE A,D		;get filename
	CAME A,['OUTPUT']
	JRST SAVINL		;doing input, each with own name, no renames
	MOVSI B,'OMM'		;delete old old backup mem file
	MOVEI C,0
	MOVE D,DUMPER
	LOOKUP DSKBAK,A		;check for old old file
	 JRST [	OUTSTR [ASCIZ/
%% Lookup of old old backup memory file failed.  Continuing anyway. %%

/]
		JRST SAVILL]	;if no old old file, can't delete (unexpected)
	PUSH P,A		;save file name
	MOVEI A,0		;zero filename for deletion
	MOVE D,DUMPER		;must have right PPN
	RENAME DSKBAK,A		;delete old old file
	 OUTSTR [ASCIZ/
%% Delete of old old backup memory file failed.  Continuing anyway. %%
/]				;The RENAME will no doubt fail too now.
	CLOSE DSKBAK,
	POP P,A			;restore file name
SAVILL:	MOVSI B,'MEM'
	MOVE D,DUMPER
	LOOKUP DSKBAK,A		;check for old file, so we can rename it
	 JRST [	OUTSTR [ASCIZ/
%% Lookup of old backup memory file failed.  Continuing anyway. %%

/]
		JRST SAVINL]	;if no old file, no rename (unexpected, though)
	HRLI B,'OMM'		;rename to old mem file (preserve dates)
	MOVE D,DUMPER
	RENAME DSKBAK,A		;save old version by renaming it
	 OUTSTR [ASCIZ/
%% Rename of old backup memory file failed.  Continuing anyway. %%

/]
SAVINL:	CLOSE DSKBAK,		;avoid RA mode, want new file
	MOVSI B,'MEM'		;normal extension
	MOVEI C,0
	MOVE D,DUMPER
	ENTER DSKBAK,A		;create new file
	 JRST SAVINE		;failed!
	OUT DSKBAK,[IOWD 200+MEMLEN,REELBF ;write backup file
			0]
	 CAIA			;success
	JRST SAVINO		;disk error!
	RELEAS DSKBAK,		;all done with backup file
	POPJ P,

SAVINE:	OUTSTR [ASCIZ/
%%% ENTER of backup memory file failed.  Find a wizard.
/]
	HALT SAVINL

SAVINO:	OUTSTR [ASCIZ/
%%% Output to backup memory file failed (disk error).  Find a wizard.
/]
	HALT SAVINL
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       subttl split ALLDIR.MEM		; SPLIT SPLIT1 SPLIT2 SPLIT3 SPLIT4 SPLIT5 SPLIT6 SPLIT7 SPLITX SPLITZ SPLITA SPLIT8

;SPLIT ALLDIR.MEM 
; INTO ALLDIR.DAT (CONTAINING WHERE LAST DUMPED FOR ALL FILES IN MFD)
;  AND DTAPES.DAT (CONTAINING WHERE DUMPED AND WHEN WRITTEN FOR ALL FILES
;		   ON ALL TAPES IN THIS DUMP)

;CHANNEL	FILE		I/O	BUFFER	GET(PUT) ROUTINE

;UFD		ALLDIR.MEM	I(B)	UFDBUF	UFDRD	(SKIPS UNLESS EOF)
;FILE		ALLDIR.DAT	O(B)	FOBUF	DFWRIT
;DSKMSC		DTAPES.DAT	O(D)	REELBF	DMPUT, DMINI

SPLIT:	CLOSE UFD,		;CLOSE ALL CHANNELS THAT WE NEED
	TRNN FL,PURCOM		;SKIP ALLDIR.DAT OPERATIONS IF PURGE COMMAND
	CLOSE FILE,
	RELEAS DSKMSC,
	OUTSTR [ASCIZ/Splitting.../]
	MOVEI A,17
	MOVE B,STRNAM
	MOVEI C,0
	OPEN DSKMSC,A
	PUSHJ P,NODEV
SPLIT1:	MOVE A,['ALLDIR']
	MOVSI B,'MEM'
	MOVEI C,0
	MOVE D,DUMPER
	LOOKUP UFD,A		;SEEK INPUT FILE.
	JRST [OUTSTR [ASCIZ/ALLDIR.MEM lookup failed in SPLIT !!
/]
		HALT SPLIT1]
	TRNE FL,PURCOM		;IS THIS PURGE COMMAND?
	JRST SPLIT3		;YES, SKIP ALLDIR.DAT OPERATIONS
	SETSTS FILE,10		;FLUSH SPECIAL MODES OF FILE CHANNEL
	MOVEI A,ALTBUF		;GET ROOM FOR SOME BUFFERS
	SETZM ALTBUF
	EXCH A,.JBFF
;This outbuf reuses magtape buffer space at ALTBUF.
	OUTBUF FILE,NBUFSX	;MAKE BUFFERS FOR FILE OUTPUT
	MOVEM A,.JBFF		;RESET .JBFF
SPLIT2:	MOVE A,['ALLDIR']
	MOVSI B,'DAT'
	MOVEI C,0
	MOVE D,DUMPER
	ENTER FILE,A		;SELECT OUTPUT FILE.
	JRST [OUTSTR [ASCIZ/Unable to enter ALLDIR.DAT in SPLIT.
/]
		HALT SPLIT2]
SPLIT3:	MOVE A,['DTAPES']
	MOVSI B,'DAT'
	MOVEI C,0
	MOVE D,DUMPER
	ENTER DSKMSC,A
	JRST [OUTSTR [ASCIZ/Unable to enter DTAPES.DAT in SPLIT.
/]
		HALT SPLIT3]
	SETZM DSKMM0		;ZERO RECORD COUNT
	SETOM DSKMM3		;SET BINARY MODE
	PUSHJ P,DMINI
SPLIT4:	PUSHJ P,UFDRD		;READ PPN FROM ALLDIR.MEM
	 JRST SPLITZ		;EOF
	MOVEM A,SPPN		;SAVE PPN
	SETOM DTAPPN		;FLAG NEW PPN READ(FOR DTAPES.DAT)
	TRNN FL,PURCOM		;SKIP ALLDIR.DAT OPERATIONS IF PURGE COMMAND
	PUSHJ P,DFWRIT		;WRITE PPN TO ALLDIR.DAT
SPLIT5:	PUSHJ P,UFDRD		;READ FILENAME (OR ZERO) FROM ALLDIR.MEM
	 PUSHJ P,SPLITX		;EOF - SHOULDN'T HAPPEN
	JUMPE A,SPLIT7		;GO PROCESS ZERO ENTRY
	MOVEM A,SNAME		;SAVE FILENAME
	TRNN FL,PURCOM		;SKIP ALLDIR.DAT OPERATIONS IF PURGE COMMAND
	PUSHJ P,DFWRIT		;WRITE FILENAME TO ALLDIR.DAT
	PUSHJ P,UFDRD		;READ EXT,,TAPNO FROM ALLDIR.MEM
	 PUSHJ P,SPLITX		;EOF - SHOULDN'T HAPPEN
	TRNN A,200000		;WAS FILE DUMPED THIS TIME?
	JRST [TRNN FL,PURCOM	;(SKIP ALLDIR.DAT OPERATIONS IF PURGE)
		PUSHJ P,DFWRIT	;NO, GO WRITE EXT,,TAPNO TO ALLDIR.DAT
		JRST SPLIT5]	;AND GO GET A NEW FILENAME
	MOVEM A,SEXT		;YES, SAVE EXT,,TAPNO
	TRZ A,200000		;REMOVE FLAG BIT
	TRNN FL,PURCOM		;SKIP ALLDIR.DAT OPERATIONS IF PURGE COMMAND
	PUSHJ P,DFWRIT		;WRITE EXT,,TAPNO TO ALLDIR.DAT
	SKIPN DTAPPN		;HAVE WE WRITTEN TO DTAPES.DAT THIS PPN?
	JRST SPLIT6		;YES, DON'T WRITE OUT PPN AGAIN
	MOVE A,SPPN		;PICK UP SAVED PPN
	PUSHJ P,DMPUT		;WRITE IT TO DTAPES.DAT
	SETZM DTAPPN		;FLAG PPN ALREADY WRITTEN
SPLIT6:	MOVE A,SNAME		;PICK UP SAVED FILENAME
	PUSHJ P,DMPUT		;WRITE IT TO DTAPES.DAT
	MOVE A,SEXT		;PICK UP SAVED EXT,,TAPNO
	PUSHJ P,DMPUT		;WRITE IT TO DTAPES.DAT
	PUSHJ P,UFDRD		;READ DATE WRITTEN FROM ALLDIR.MEM
	 PUSHJ P,SPLITX		;EOF - SHOULDN'T HAPPEN
	PUSHJ P,DMPUT		;WRITE IT TO DTAPES.DAT
	JRST SPLIT5		;GO GET A NEW FILENAME

SPLIT7:	TRNN FL,PURCOM		;SKIP ALLDIR.DAT OPERATIONS IF PURGE COMMAND
	PUSHJ P,DFWRIT		;WRITE ZERO TO ALLDIR.DAT
	SKIPN DTAPPN		;HAVE WE WRITTEN TO DTAPES.DAT THIS PPN?
	PUSHJ P,DMPUT		;YES, WRITE ZERO TO DTAPES.DAT ALSO
	JRST SPLIT4		;GO GET A NEW PPN

SPLITX:	OUTSTR [ASCIZ/Unexpected EOF on ALLDIR.MEM in SPLIT.
/]
	HALT .


SPLITZ:	CLOSE UFD,		;CLOSE DART.MEM INPUT
	TRNE FL,PURCOM		;IS THIS PURGE COMMAND?
	JRST SPLITA		;YES, SKIP ALLDIR.DAT OPERATIONS
	CLOSE FILE,		;CLOSE ALLDIR.DAT OUTPUT
	SETSTS FILE,10+DMPBIT+GARBIT ;SET SPECIAL STATUS
SPLITA:	PUSHJ P,DMFINI		;write out last buffer, if necessary
	CLOSE DSKMSC,
	RELEAS DSKMSC,
	OUTSTR [ASCIZ/
/]				;close off line saying "Splitting..."
	MOVEI A,17
	MOVSI B,'DSK'
	MOVEI C,0
	OPEN DSKMSC,A
	PUSHJ P,NODEV
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               subttl	merge DTAPES.DAT and DART.DAT ; D DEOF DNEED RT TNEED RD DNEED TNEED MANCMD MANCM0 MANCM1 MMERGE MANMER MANME2 MANTAP EXTRACT EXTRC1 EXTRC2 EXTRC3 EXLPXX MERG00 XMERGE YMERGE ZMERGE SMERGE MERGRT MTSRT1 MTSRT2 MTSRT8 MTSRT3 MTSR30 MTSR3A MTSR3B MTSR3C MTSR3X MTSRT5 MTSRT4 MTSRT7

;MERGE TAPE DATA (FROM DTAPES.DAT) INTO DART.DAT
;CREATE ASCII TAPE DATA FILE

;CHANNEL	FILE		I/O	BUFFER	GET(PUT) ROUTINE

;UFD		DART.DAT 	I(B)	UFDBUF	UFDRD	(SKIPS UNLESS EOF)
;MEM		DTAPES.DAT	I(D)	MEMBLK	TNREAD	(SKIPS UNLESS EOF)
;FILE		DART.DAT 	O(B)	FOBUF	DFWRTX
;DSKMSC		P/TNNNNN.LST	O(D)	REELBF	DMPUT, DMINI

COMMENT $	MERGE DIAGRAM
	D=DART.DAT FILE		T=TAPE DATA (FROM ALLDIR.MEM)

	DEOF_TEOF_FALSE;
	DNEED_TNEED_TRUE;
RT:	IF TEOFTNEED THEN READ TNAME AND TDATA; SORT;
	TNEED_FALSE;
	IF EOF THEN TEOF_TRUE;
RD:	IF DEOFDNEED THEN READ DNAME;
	DNEED_FALSE;
	IF EOF THEN DEOF_TRUE;
	IF DEOFTEOF THEN DONE;
	IF DEOF THEN WRITE TDATA; TNEED_TRUE; GO TO RT;
	IF TEOF THEN WRITE DDATA; DNEED_TRUE; GO TO RD;
	IF TNAME > DNAME THEN WRITE DDATA; DNEED_TRUE; GO TO RD;
	IF TNAME < DNAME THEN WRITE TDATA; TNEED_TRUE; GO TO RT;
	MERGE DDATA AND TDATA AND WRITE BOTH;
	TNEED_DNEED_TRUE; 	GO TO RT;
$

ifn 1,<				;This code only for emergencies, for reconstruction of DART.DAT.
;Start here from DDT to do just the merge phase (manually, sort of),
;after setting up DTAPES.DAT somehow (e.g., with DRAT and TLIST, or
;from a P/T000nn.LST file with the program UNLIST); be sure NOT to have
;included ALLDIR.DAT[DMP,SYS] at the end of DTAPES.DAT (DRAT will include
;the ALLDIR.DAT from the end of a dump in TLIST.BIN, but UNLIST avoids
;including ALLDIR.DAT[DMP,SYS] in the DTAPES.DAT file it writes).

;This is useful when DART.DAT has been clobbered on the disk but is on a
;tape and you want to update that version with info from that dump and any
;later ones.  Start Dart normally, get to DDT with Dart's DDT command and
;then call this routine.
REPEAT 0,<	;now finishes cleanly
; It will die in SAVMEM from MERGZ1+11 with i/o to
;unassigned channel, after having closed all the output files, and just
;before trying to delete DTAPES.DAT, which is basically just the right
;place for it to stop.
>;REPEAT 0
;Here for MANMERGE command to run MANMER semiautomatically.
;Cmd should be followed by the tape number; only works for a single-tape dump.
;E.g., "P12345" or "T34".
MANCMD:	SKIPA A,SAVDEL		;GET DELIMITER WHICH FOLLOWED COMMAND NAME
MANCM0:	INCHWL A		;SKIP SPACES AND TABS
	CAIE A,40
	CAIN A,11
	JRST MANCM0
	TLO FL,L.TURK		;Pretend TURKEY COMMAND for GETANS
	PUSHJ P,GETA11		;GET TAPE NUMBER FROM COMMAND LINE
	 JRST NONMBR		;OOPS, NO TAPE NUMBER
	 JRST MANCM1		;OK RETURN
	JRST NONMBR

MANCM1:	TLZN FL,L.TURK		;OK RETURN
	TROA FL,PCLASS		;flag P class tape
	TRZ FL,PCLASS		;flag T class tape
	MOVEM B,TAPNO		;set up tape number
	HRL B,B			;put tape number in both halves
	MOVEM B,MANTAP		;store tape range for MANMER
	JRST MANMER		;go do the manual merge

MMERGE:	SETOM MASCOP		;here if doing merge for master tape copy!
MANMER:	RESET			;don't accidentally close a partial DART.DAT file!
	MOVSI A,'DAT'
	MOVEM A,DATDAT		;set up extension and no date for ALLDIR.DAT at end
	SETZM REDOPN		;no magtape open for reading
	SETZM WRTOPN		;no magtape open for writing
	SETZM MT2BUF		;no second set of magtape buffers, jobff reset
	SKIPN MANTAP
	JRST [	OUTSTR [ASCIZ/Initialize MANTAP
Left half: first tape in series;  Right half: last tape in series.
Subsequent words can be used if more than one series is present.
/]
		HALT .]
	MOVEI A,10
	MOVSI B,'DSK'
	MOVEM B,STRNAM
	MOVSI C,FOBUF
	OPEN FILE,A		;DART.DAT OUTPUT
	 PUSHJ P,NODEV
	OUTBUF FILE,NBUFS	;SOME BUFFERS

	MOVEI C,UFDBUF
	OPEN UFD,A		;DART.DAT INPUT
	 PUSHJ P,NODEV
	INBUF UFD,NBUFS		;SOME BUFFERS

	MOVEI A,17
	MOVEI C,0
	OPEN MEM,A		;DTAPES.DAT INPUT, dump mode
	 PUSHJ P,NODEV

;Now we fake the .MEM file stuff, as needed.
	TDZA B,B		;number of ranges of tape numbers so far
MANME2:	MOVEM A,MEMSAV+TTBUF-1(B) ;store for MERGE
	SKIPE A,MANTAP(B)	;actual range of tapes in dump manually merging
	AOJA B,MANME2		;count another range
	MOVEM B,MEMSAV+TTCNT	;store number of tape ranges
	DATE B,
	MOVEM B,TODAYD		;need today's date for date check if master copy
	SKIPE MASCOP
	PUSHJ P,VALDA2		;get date (limit) from user
	SKIPE MASCOP
	TRO FL,PCLASS		;master copy is with P tapes
	SETOM NOLIST		;suppress tape listing file
	PUSHJ P,MERG01		;don't diddle MASCOP, don't SAVMEM, POPJ when done
	OUTSTR [ASCIZ/Manual merge done./]
	EXIT 1,			;easy way out
	HALT .

;tape number ranges appearing in dump being manually merged.  end with zero word.
;For MANMER, do NOT include the 400000 bit in T tape numbers here!
;(For EXTRACT, you WOULD use 400000 bit for T tape numbers, but EXTRACT is bad.)
MANTAP: 0			;=60,,=62	;range(s) of tapes in this dump
	0			;(may be two if wrapped around from Tn to T1)
	0
	0			;space for patching in tape ranges

ifn 0,<

;Here's a blob of code that reads ALLDIR.OLD and creates a DTAPES.DAT
;file.  Then we go to MANMER.
;Setup MANTAP

;DON'T USE THIS IF THE SYSTEM IS UP OR HAS BEEN UP SINCE THE DUMP.
;The wrong dates are extracted from files on the disk that have been
;edited since the dump.
EXTRACT:RESET			;don't accidentally close a partial DART.DAT file!
	SETZM REDOPN		;no magtape open for reading
	SETZM WRTOPN		;no magtape open for writing
	SETZM MT2BUF		;no second set of magtape buffers, jobff reset
	SKIPN MANTAP
	JRST [	OUTSTR [ASCIZ/Initialize MANTAP
Left half: first tape in series;  Right half: last tape in series.
Subsequent words can be used if more than one series is present.
/]
		HALT .]
	MOVEI A,10
	MOVSI B,'DSK'
	MOVEM B,STRNAM
	MOVSI C,FOBUF
	OPEN FILE,A		;DTAPES.DAT OUTPUT
	 PUSHJ P,NODEV
	OUTBUF FILE,NBUFS	;SOME BUFFERS

	MOVEI C,UFDBUF
	OPEN UFD,A		;ALLDIR.OLD INPUT
	 PUSHJ P,NODEV
	INBUF UFD,NBUFS		;SOME BUFFERS

	MOVEI A,17		;miscellaneous LOOKUPs, as needed.
	MOVEI C,0
	OPEN MEM,A	
	 PUSHJ P,NODEV

	MOVE A,['DTAPES']
	MOVSI B,'DAT'
	MOVEI C,0
	MOVE D,DUMPER
	ENTER FILE,A
	JRST [	OUTSTR [ASCIZ/can't enter DTAPES.DAT
/]
		HALT .]

	MOVE A,['ALLDIR']
	MOVSI B,'OLD'
	MOVEI C,0
	MOVE D,DUMPER
	LOOKUP UFD,A
	JRST [	OUTSTR [ASCIZ/Can't find ALLDIR.OLD
/]
		HALT .]

	MOVEI Y,0		;no PPN to close
EXTRC1:	PUSHJ P,UFDRD		;read PPN from file.
	 JRST EXLPXX		;must be end of file
	MOVE Z,A		;save current PPN
	CAMN Z,Y		;different than current PPN?
	JRST EXTRC2		;ignore repeated PPN
	MOVEI A,0
	SKIPE Y			;any PPN to close?
	PUSHJ P,DFWRTX		;yes. write a zero.
	MOVEI Y,0		;now, no PPN to close
EXTRC2:	PUSHJ P,UFDRD		;get file name
	 JRST EXLPXX		;unexpected eof
	JUMPE A,EXTRC1		;zero is no file.  PPN is next
	MOVE W,A		;copy file name
	PUSHJ P,UFDRD
	 JRST EXLPXX		;unexpected eof
	MOVE X,A		;file extension & tape number.
	HRRZ A,A		;keep tape number where this file is.
	MOVEI B,0		;pointer to MANTAP
EXTRC3:	SKIPN MANTAP(B)		
	JRST EXTRC2		;no more ranges.  not of interest.
	HLRZ C,MANTAP(B)	;get low bound of range
	HRRZ D,MANTAP(B)	;hi bound of range
	CAMG C,A		;skip if low bound is higher than current
	CAMGE D,A		;skip if hi bound is higher or EQ to curr
	AOJA B,EXTRC3		;not in this range.
;now we must get the date of the file.
	MOVE A,W
	HLLZ B,X
	MOVEI C,0
	MOVE D,Z
	LOOKUP MEM,A
	JRST EXTRC2		;can't find the file.  No date.
	CLOSE MEM,
	MOVE A,Z		;get the ppn
	SKIPN Y			;did we open this PPN?
	PUSHJ P,DFWRTX		;no, must do so now
	MOVE Y,Z		;this PPN is open now.
	MOVE A,W
	PUSHJ P,DFWRTX		;write onto FILE
	MOVE A,X
	PUSHJ P,DFWRTX
	LDB A,[POINT 12,C,35]
	LDB B,[POINT 3,B,20]
	DPB B,[POINT 3,A,23]
	PUSHJ P,DFWRTX
	JRST EXTRC2

EXLPXX:	CLOSE FILE,
	CLOSE UFD,
	JRST MANMER
>;ifn 0 ;EXTRACT

>;ifn 1 ;for use only during reconstruction of DART.DAT.

;This routine does all the work of the merge of DTAPES.DAT and DART.DAT.
;Called from MERGE0 and from MANMER/MMERGE.
MERG00:	SETZM NOLIST		;want tape listing file
MERG01:	TLZ FL,TEOF!DEOF!DNEED!TNEED ;INITIALIZE FLAGS
	CLOSE UFD,		;CLOSE ALL CHANNELS THAT WE NEED
	CLOSE FILE,
	CLOSE MEM,
	RELEAS DSKMSC,
	OUTSTR [ASCIZ/Merging.../]
	MOVEI A,17
	MOVE B,STRNAM
	MOVEI C,0
	OPEN DSKMSC,A
	 PUSHJ P,NODEV
	MOVE A,['DART  ']	;READ THE MASTER FILE
	MOVSI B,'DAT'
	MOVEI C,0
	MOVE D,DUMPER
	LOOKUP UFD,A		;SEEK INPUT FILE, DART.DAT
	 JRST [	TRNE B,-1	;ensure error is No Such File
		JRST NOLOOK	;unexpected LOOKUP error
		TLO FL,DEOF	;NO INPUT FILE. SET EOF.
		JRST .+1]
IFN STANSW,<
	MOVEI A,UFD		;channel number for wholine filestatus
	SHOWIT A,		;display filename on wholine
>;IFN STANSW
	SETSTS FILE,10		;FLUSH SPECIAL MODES OF FILE CHANNEL
	MOVEI A,ALTBUF		;GET ROOM FOR SOME BUFFERS
	SETZM ALTBUF
	EXCH A,.JBFF
;This outbuf reuses magtape buffer space at ALTBUF.
	OUTBUF FILE,NBUFSX	;MAKE BUFFERS FOR FILE OUTPUT
	MOVEM A,.JBFF		;RESET .JBFF
XMERGE:	MOVE A,['DART  ']	;WRITE OVER THE MASTER FILE.
	MOVSI B,'DAT'
	MOVEI C,0
	MOVE D,DUMPER
	ENTER FILE,A		;SELECT OUTPUT FILE.
	JRST [	OUTSTR [ASCIZ/%%% Unable to enter DART.DAT to write merge.
/]
		HALT XMERGE]
YMERGE:	MOVE A,['DTAPES']	;GET THE INPUT FILE.
	MOVSI B,'DAT'
	MOVEI C,0
	MOVE D,DUMPER
IFN STANSW,<
	LOOKUP MEM,A		;SEEK MERGE INPUT FILE.
>;IFN STANSW
IFE STANSW,<
	MOVEM A,LKBLK+.RBNAM
	MOVEM B,LKBLK+.RBEXT
	MOVEM D,LKBLK+.RBPPN
	LOOKUP MEM,LKBLK
>;IFE STANSW
	 JRST [	OUTSTR [ASCIZ/%%% MERGE confusion: I can't find DTAPES.DAT.
/]
		HALT YMERGE]
IFN STANSW,<
	MOVSM D,MEMWC		;SAVE - WC OF DTAPES.DAT.
>;IFN STANSW
IFE STANSW,<
	MOVN D,LKBLK+.RBSIZ
	MOVEM D,MEMWC
>;IFE STANSW
	SETZM MEMWC2		;FORCE INPUT TO HAPPEN.
ZMERGE:	SKIPN NOLIST		;skip if suppressing listing file
	SKIPE MASCOP		;skip unless master copy
	JRST SMERGE		;no listing file for master tape copy
	SKIPN MEMSAV+TTCNT	;WERE THERE ANY OUTPUT TAPES?
	JRST [	OUTSTR [ASCIZ/%%% MERGE confusion: no tapes were used.
/]
		HALT ZMERGE]
	SETZM TRANGE		;SET TRANGE TO FIRST RANGE OF TAPES
	HLRZ A,MEMSAV+TTBUF
	MOVEM A,TAPNO		;SET UP NUMBER OF FIRST TAPE
	PUSHJ P,REELM0		;SET UP TAPE NAME, ETC.
	MOVE A,TAPNAM
	MOVEM A,SPLNAM		;SAVE TEXT FILE NAME FOR SPOOLING
	MOVSI B,'LST'
	MOVEI C,0
	MOVE D,DUMPER
	ENTER DSKMSC,A
	JRST [	OUTSTR [ASCIZ/Unable to enter reel text file.
/]
		HALT ZMERGE]
	SETZM DSKMM0		;ZERO RECORD COUNT
	SETZM DSKMM3		;SET ASCII MODE
	PUSHJ P,DMINI		;initialize reel output file
	PUSHJ P,TPGINI		;INITIALIZE THE OUTPUT PAGE
	SETZM TPGNUM		;INITIALIZE THE OUTPUT PAGE NUMBER
SMERGE:	PUSHJ P,UIDXIN		;INITIALIZE INDEX OUTPUT.
	TLNN FL,DEOF		;SKIP IF NO INPUT FILE.
	PUSHJ P,SKPIDX		;SKIP INDEX ON INPUT
;Read a PPN from DTAPES.DAT, and then do an insertion/bubble sort
;of all the filenames for that PPN, so that they can be merged into DART.DAT.
MERGRT:	TLNE FL,TEOF!TNEED	;EOF OR NO NEED?
	JRST MERGRY		;YES. DON'T READ DATA
	PUSHJ P,TNREAD		;READ DATA FROM FILE -- PPN
	 JRST MERGRX		;END OF FILE.
	MOVEM A,TNAME		;SAVE UFD NAME FROM TAPE FILE
	MOVE B,.JBFF		;CREATE UFD DATA BUFFER HERE.
MTSRT1:	MOVE C,.JBREL
	SUBI C,3-1		;ROOM FOR 3 WORDS
	CAMG B,C		;MAKE SURE WE DON'T EXPAND TOO FAR
	JRST MTSRT2		;OK
	ADDI C,2000+3-1		;GET MORE CORE
	CORE C,
	 JRST NOCORE
MTSRT2:	PUSHJ P,TNRD1		;READ MORE DATA - A FILE NAME
	JUMPN A,MTSRT3		;FILE NAME IS NOT ZERO
	PUSHJ P,TNREAD		;IF THERE IS A ZERO, GET ANOTHER UFD
	 JRST MTSRT8		;NO UFD'S THERE.
	JUMPE A,.-2		;BH 11/6/78 CONSECUTIVE 0'S OK.
;;; The above instruction was added to allow a clobbered DTAPES.DAT file to be
;;; repaired by zeroing out the bad data.
	CAMN A,TNAME		;GOT a PPN. IS IT THE SAME AS BEFORE?
	JRST MTSRT1		;same PPN as before, sort filenames in together
	SOS MEMWC		;Different PPN.  PUT THIS UFD NAME BACK.
	SOS MEMWC1		;CHANGE 2 COUNTS AND A BYTE POINTER.
	SOS MEMWC2
;We've sorted the DTAPES.DAT files for a single PPN
;Next merge them with DART.DAT (on next page).
MTSRT8:	MOVEM B,MJBFF		;POINTER TO PLACE TO STUFF DART.DAT
	MOVE C,.JBFF
	SUBI C,(B)		;COMPUTE THE SIZE OF INCORE AREA
	HRLZ C,C
	HRR C,.JBFF		;-WC,,MA
	MOVEM C,TPTR		;SAVE THE POINTER TO THE DATA
	JRST MERGRY		;NO. WE ARE DONE WITH INPUT.

;We have a file name from DTAPES.DAT.  Pick up dump info and then bubble
;sort the entry into our sorted list of DTAPES.DAT files for this PPN.
;Also, write out text entry for this dumped file in tape reel listing file.
MTSRT3:	MOVEM A,(B)		;STORE THE FILE NAME.
	PUSHJ P,TNRD1		;READ EXTENSION
;The 200000 bit means "dumped this time" for dumps, but means PRMERR for tape copy.
	SKIPE MASCOP
	JRST MTSR30		;master tape copy, don't require/clear 200000 bit
	TRZN A,200000		;WAS IT DUMPED THIS TIME?
	PUSHJ P,MTSR3X		;NO, CONFUSION:IT SHOULDN'T BE THERE
MTSR30:	HLLZM A,1(B)		;STORE EXTENSION
	HRRZ A,A		;GET TAPENO (+400000 FOR TCLASS)
	MOVEM A,2(B)		;STORE TAPENO
	TRNE FL,PCLASS		;SKIP IF DUMP TCLASS
	TRC A,400000		;COMPLEMENT TAPE TCLASS BIT
	TRZN A,400000		;CLEAR TAPE TCLASS, SKIP IF WAS SET
	PUSHJ P,MTSR3X		;CLASSES DON'T MATCH:CONFUSION
	SKIPN MASCOP		;no listing files for master tape copy
	CAMN A,TAPNO
	JRST MTSR3B		;FILE IS ON SAME TAPE : THAT'S EASY
IFN STANSW,<
	EXCH A,TAPNO		;SWAP NEW & OLD TAPE NUMBERS
	MOVE D,TRANGE		;PICK UP WHICH RANGE OLD NUM WAS IN
	ADDI A,1		;OLD TAPE NUMBER + 1
	HRRZ X,MEMSAV+TTBUF(D)	;RANGE MAXIMUM TAPE NUMBER
	CAMG A,X
	JRST MTSR3A		;JUMP IF OLD+1 IS STILL IN RANGE
	AOS D,TRANGE		;MOVE TO NEXT RANGE
	CAML D,MEMSAV+TTCNT
	PUSHJ P,MTSR3X		;NO MORE RANGES : CONFUSION
	HLRZ A,MEMSAV+TTBUF(D)	;PICK UP FIRST NUM IN NEXT RANGE
MTSR3A:	CAME A,TAPNO		;MAKE SURE IT'S THE EXPECTED ONE
	PUSHJ P,MTSR3X		;DUMPED THIS TIME, BUT WRONG TAPNO
>;IFN STANSW
IFE STANSW,<
	MOVEM A,TAPNO
;; THE BUG TRAPPERY ABOVE DOESN'T WORK FOR MULTIPLE STRUCTURES
;; BECAUSE THE INITIAL VALUE OF TAPNO FOR EACH STRUCTURE IS TAKEN FROM
;; THE INITIAL VALUE FOR THE ENTIRE DUMP, SO A STRUCTURE STARTING
;; ANYWHERE OTHER THAN THE FIRST OR SECOND TAPE WILL WRONGLY GET BUG
;; TRAPPED ON ITS FIRST FILE.  SINCE I DON'T SEEM TO HAVE THE BUG THIS
;; IS TRAPPING, I JUST FLUSHED THE WHOLE MESS INSTEAD OF TRYING TO MAKE
;; IT TRAP THE RIGHT BUG.
>;IFE STANSW
	PUSHJ P,TPGDON		;START DATA FOR NEW TAPE : NEW PAGE
	SETZM TPGNUM		;INITIALIZE THE OUTPUT PAGE NUMBER
	PUSH P,B		;SAVE REG (USED BY REELM0)
	PUSH P,C		;SAVE REG (USED BY REELM0)
	PUSHJ P,REELM0		;SET UP TAPE NAME, ETC.
	POP P,C
	POP P,B
MTSR3B:				;HERE IF FILE DUMPED THIS TIME
	PUSHJ P,TNRD1		;READ THIRD WORD
	SKIPE MASCOP		;skip unless master tape copy
	PUSHJ P,CKDATE		;check the date, maybe zero it, preserving rel dmp
	HRRM A,1(B)		;SAVE DATE and rel dmp low bits
	SKIPN NOLIST		;skip if suppressing listing file
	SKIPE MASCOP
	JRST MTSR3C		;no listing file for master tape copy
	MOVE A,TPGPDP		;GET PDL FOR STORING THE PAGE DATA
	PUSH A,(B)		;STORE NAME
	PUSH A,1(B)		;AND EXTENSION - DATE
	PUSH A,TNAME		;AND UFD NAME
	MOVEM A,TPGPDP		;STORE PDL
	AOBJN A,.+2		;SEE IF THAT WAS THE LAST THING..
	PUSHJ P,TPGPUT		;TIME TO WRITE THE ENTIRE PAGE.
MTSR3C:	ADDI B,3		;INCREMENT B TO POINT PAST THIS AREA
	MOVEI C,-3(B)		;LOAD C WITH ADDRESS OF LAST NAME.
	MOVE A,(C)		;LOAD A WITH LAST NAME.
	MOVE W,1(C)		;LOAD W WITH EXTENSION AND DATE
	MOVE Z,2(C)		;LOAD Z WITH TAPENO
	JRST MTSRT4		;JUMP INTO THE SORT ROUTINE.

MTSR3X:	OUTSTR [ASCIZ/%%% MERGE confusion: DTAPES.DAT dump tapes not in expected order.
/]
	HALT .

MTSRT5:	MOVE D,-3(C)		;BUBBLE.  GET NAME FROM CORE AND
	MOVEM D,(C)		;MOVE IT UP 2 PLACES
	MOVE D,-2(C)		;SAME FOR EXTENSION.
	MOVEM D,1(C)		;
	MOVE D,-1(C)		;SAME FOR TAPENO.
	MOVEM D,2(C)		;
	SUBI C,3		;DECREMENT OUR POINTER.
MTSRT4:	CAMLE C,.JBFF		;ARE WE RUNNING OFF THE END?
	CAMLE A,-3(C)		;OR HAVE WE FOUND A HOME?
	JRST MTSRT7		;ONE OF THE ABOVE.
	CAME A,-3(C)		;POSSIBLY SAME NAME.
	JRST MTSRT5		;NO. WE HAVE TO BUBBLE.
	HLLZ X,-2(C)		;SAME NAME. GET EXT
	HLLZ Y,W		;GET EXT ONLY FROM W.
	CAMGE Y,X		;ARE WE IN ORDER?
	JRST MTSRT5		;NO. WE HAVE TO BUBBLE.
MTSRT7:	MOVEM A,(C)		;STORE FILE NAME
	MOVEM W,1(C)		;AND EXT
	MOVEM Z,2(C)		;AND TAPENO
	JRST MTSRT1		;WE ARE DONE WITH THIS TERM.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 subttl merge ; MERGRX MERGRY MERGRD MRGRD1 MRGRD2 MRGRD3 MERG1 MERG1A MERG1B MERG1D MERG2 MERG4 MERG4A MERG4C MERG4E MERG4B MERG4D MERG4Q MERG4Y MERG4X MERGRZ MERGZ0 MERGZ1 MERGZ2 MERGE MERGE0 MERG99 RENDAT

MERGRX:	TLO FL,TEOF		;SET EOF SEEN IN TAPE FILE.
MERGRY:	TLO FL,TNEED		;NO NEED FOR MORE TAPE DATA.

MERGRD:	TLNE FL,DEOF!DNEED	;EOF ALREADY OR NO NEED FOR DATA?
	JRST MRGRD1		;YES TO ONE OF ABOVE. SKIP READ.
	PUSHJ P,RDIPPN		;READ FROM DART.DAT
	 TLO FL,DEOF		;WAS END OF FILE.
	TLO FL,DNEED		;DON'T NEED DATA
	MOVEM A,DNAME		;SAVE THE NAME.
	JUMPN A,MRGRD1		;JUMP IF REAL NAME.
	TLO FL,DEOF		;FORCE EOF WHEN A ZERO NAME SEEN
MRGRD1:	TLC FL,DEOF!TEOF	;COMPLEMENT BOTH EOF BITS.
	TLCN FL,DEOF!TEOF	;EOF ON BOTH?
	JRST MERGRZ		;YES. WE ARE DONE.
	TLNN FL,DEOF		;EOF ON DART.DAT?
	JRST MERG1		;NO.
;WRITE TAPE DATA TO DART.DAT
MRGRD2:	MOVE A,TNAME		;GET THE UFD NAME ON TAPE FILE.
	TLZ FL,TNEED		;WE NEED MORE TAPE DATA
	MOVE D,TPTR		;GET POINTER TO DATA IN CORE
	JUMPG D,MERGRT		;JUMP IF THIS IS EMPTY
	PUSHJ P,UIDXBG		;BEGINNING OF UFD ENTRY
	PUSHJ P,DFWRTX		;WRITE UFD NAME.
MRGRD3:	MOVE A,(D)		;GET DATA
	PUSHJ P,DFWRTX		;WRITE DATA
	HLLZ A,1(D)		;GET DATA
	HRRI A,1		;EXT,,COUNT. COUNT = 1.
	PUSHJ P,DFWRTX		;WRITE DATA
	HRRZ A,1(D)		;GET THE FILE LAST WRITTEN DATE
	HRL A,2(D)		;GET MERGE VERSION OF TAPE NUMBER.
	PUSHJ P,DFWRTX		;WRITE DATA
	ADD D,[3,,3]
	JUMPL D,MRGRD3
	SETZ A,			;ZERO ENDS THE FILE LIST
	PUSHJ P,DFWRTX		;WRITE IT.
	JRST MERGRT		;READ MORE DATA FROM TAPE FILE.

MERG1:	TLNN FL,TEOF		;EOF ON TAPE FILE?
	JRST MERG2		;NO WE HAVE TO THINK ABOUT MERGE.
;READ DART.DAT AND WRITE IT
MERG1A:	PUSHJ P,MMREAD		;READ DATA
	SKIPN MMNAM		;IS THERE ANY NAME THERE?
	JRST MERG1D		;NONE AT ALL, get next PPN
	HRRZ A,MMEXT		;GET THE COUNT
	JUMPE A,MERG1A		;LOOP IF ENTRY IS EMPTY, get next file, same PPN
	MOVE A,DNAME		;GET THE NAME FROM DART.DAT
	PUSHJ P,UIDXBG		;BEGINNING OF UFD ENTRY
	PUSHJ P,DFWRTX		;WRITE IN NEW FILE.
MERG1B:	PUSHJ P,MMWRIT		;AND WRITE THE DATA.
	PUSHJ P,MMREAD		;READ DATA FROM DART.DAT
	SKIPE A,MMNAM		;IS THERE ANY FILE NAME THERE?
	JRST MERG1B		;YES WRITE IT
	PUSHJ P,DFWRTX		;WRITE 0 TO END LIST OF FILES.
MERG1D:	TLZ FL,DNEED		;WE'LL NEED MORE DATA
	JRST MERGRD		;GO GET IT.

;HERE THERE IS DATA PRESENT FROM BOTH FILES
MERG2:	MOVE A,DNAME		;GET THE TWO NAMES.
	CAMN A,TNAME		;SKIP IF DIFFERENT UFD NAMES.
	JRST MERG4		;NAME ARE THE SAME. WE MERGE.
	PUSHJ P,UFDCNV		;CONVERT NAME
	MOVEM A,DNX		;SAVE FUNNY NAME
	MOVE A,TNAME
	PUSHJ P,UFDCNV
	MOVEM A,TNX		;SAVE FUNNY NAME.
	PUSHJ P,PPNCMP
	 JRST MERG1A		;D < T  DUMP D FIRST
	JRST MRGRD2		;D > T  DUMP T FIRST

;HERE WE HAVE TO MERGE ONE PPN.
MERG4:	TLZ FL,TNEED!DNEED	;WE WILL NEED BOTH INPUTS LATER.
	MOVE A,DNAME		;GET THE NAME
	PUSHJ P,UIDXBG		;INITIALIZE NEXT UFD
	PUSHJ P,DFWRTX		;WRITE THE NAME
MERG4A:	PUSHJ P,MMREAD		;READ FROM DART.DAT
	SKIPN MMNAM		;IS THERE ANY DATA THERE?
	JRST MERG4X		;END OF DART.DAT INPUT
	SKIPL W,TPTR		;GET THE POINTER TO TAPE FILE.
	JRST MERG4B		;NO T-DATA LEFT

;HERE THERE'S RELEVANT DATA LEFT IN BOTH FILES.
MERG4C:	MOVE A,(W)		;GET T-DATA
	CAMLE A,MMNAM		;SKIP IF TAPE DATA < DART.DAT
	JRST MERG4B		;DART.DAT DATA GOES OUT FIRST.
	CAMN A,MMNAM		;IS THE NAME THE SAME?
	JRST MERG4D		;SAME NAME. HAVE TO THINK MORE.
MERG4E:	PUSHJ P,MERG4Q		;TAPE DATA GOES FIRST. (NEW NAME)
	JUMPL W,MERG4C		;JUMP IF THERE'S MORE T-DATA.
MERG4B:	PUSHJ P,MMWRIT		;FLUSH CURRENT DAT ENTRY.
	JRST MERG4A		;LOOP.

;HERE BOTH NAMES ARE THE SAME.  CHECK EXTENSIONS NEXT.
MERG4D:	HLLZ C,1(W)		;GET EXTENSION
	HLLZ B,MMEXT		;GET EXTENSION
	CAMLE C,B		;SKIP IF T-DATA <= DAT-DATA
	JRST MERG4B		;DAT-DATA GOES OUT FIRST.
	CAME C,B		;SAME DATA?
	JRST MERG4E		;NO. T-DATA GOES FIRST.
	HRRZ C,1(W)
	HRL C,2(W)
	MOVEM C,MMDAT		;PARAMETER TO MMMWRT
	PUSHJ P,MMMWRT		;MERGE T-DATA WITH DAT-DATA & WRITE
	ADD W,[3,,3]
	MOVEM W,TPTR
	JRST MERG4A

;HERE TO WRITE ONE NEW T-DATUM TO OUTPUT FILE.
MERG4Q:	MOVE A,(W)		;NAME
	PUSHJ P,DFWRTX
	HLLZ A,1(W)
	HRRI A,1		;EXT,,1
	PUSHJ P,DFWRTX
	HRRZ A,1(W)		;0,,DATE
	HRL A,2(W)		;TAPE NUMBER,,DATE
	ADD W,[3,,3]
	MOVEM W,TPTR		;ADVANCE AND STORE NEW TPTR
	JRST DFWRTX		;WRITE TAPE NUMBER, RETURN TO CALLER

;ENTER AT MERG4X TO WRITE ALL THE T-DATA TO THE OUTPUT
MERG4Y:	PUSHJ P,MERG4Q		;WRITE ONE T-DATUM TO OUTPUT
MERG4X:	SKIPGE W,TPTR		;ANY T-DATA LEFT?
	JRST MERG4Y		;YES. LOOP UNTIL DONE.
	MOVEI A,0
	PUSHJ P,DFWRTX		;WRITE ZERO TO FINISH THIS GUY.
	JRST MERGRT		;READ MORE FROM BOTH INPUTS.

MERGRZ:	SKIPN NOLIST		;skip if suppressing listing file, save .DAT file
	SKIPE MASCOP
	PUSHJ P,RENDAT		;rename old DART.DAT to P<n-1>.DAT
	CLOSE UFD,		;CLOSE DART.DAT INPUT
IFN STANSW,<
	MOVEI A,200000		;flush wholine filestatus
	SHOWIT A,		;had been showing DART.DAT
>;IFN STANSW
	PUSHJ P,UIDXFR		;FORCE INDEX BLOCKS OUT.
	CLOSE FILE,		;CLOSE DART.DAT OUTPUT
	SETSTS FILE,10+DMPBIT+GARBIT ;SET SPECIAL STATUS
	SKIPN NOLIST		;skip if suppressing listing file
	SKIPE MASCOP		;no listing file if master tape copy
	JRST MERGZ2
	TRNE FL,PURCOM		;SKIP UNLESS PURGE
	JRST MERGZ1		;NO PHONEY ALLDIR.DAT IF PURGE

	MOVE A,MEMSAV+TTCNT
	HRRZ A,MEMSAV+TTBUF-1(A) ;GET NUMBER OF LAST TAPE
	CAMN A,TAPNO		;ARE WE ALREADY ON IT?
	JRST MERGZ0		;YES - EASY
	MOVEM A,TAPNO		;NO, SET IT IN
	PUSHJ P,TPGDON		;CLOSE OFF TEXT PAGE
	PUSHJ P,REELM0		;SET UP TAPE NAME, ETC.
MERGZ0:	MOVE A,TPGPDP		;GET PDL FOR STORING THE PAGE DATA
	PUSH A,['ALLDIR']	;FAKE IN ALLDIR.DAT ENTRY
	PUSH A,DATDAT		;EXT,,DATE (SET UP BY DMPSTR)
	PUSH A,DUMPER
	MOVEM A,TPGPDP

MERGZ1:	SKIPN MASCOP		;no listing file if master tape copy
	PUSHJ P,TPGCLS		;CLOSE REEL TEXT PAGE
	RELEAS DSKMSC,
;;; Listings are hardly ever used, often not filed, so they're disabled now.
;;;	MOVEI A,17
;;;	MOVSI B,'DSK'
;;;	MOVEI C,0
;;;	OPEN DSKMSC,A
;;;	 PUSHJ P,NODEV
;;;	PUSHJ P,SPOOL		;SPOOL TEXT OUTPUT FILE.
MERGZ2:	SETOM MEMSAV+MERGFL	;SET MERGE DONE FLAG
	POPJ P,

;Here for merge phase of normal dump.
MERGE:	SETZM MASCOP		;normal merge, not copying tapes
;Enter here from MCOPY command with MASCOP set.
MERGE0:	PUSHJ P,MERG00		;do all the work of the merge
	PUSHJ P,SAVMEM		;SAVE STATE.
	CLOSE MEM,		;CLOSE TAPE FILE INPUT
	SETZB A,B		;not master copy, delete DTAPES.DAT
	SKIPE MASCOP		;skip unless master copy
	PUSHJ P,MERG99		;master copy, generate filename to rename to
	MOVEI C,0
	MOVE D,DUMPER
	RENAME MEM,A		;DELETE DTAPES.DAT
	 OUTSTR [ASCIZ/## Rename or delete failed for DTAPES.DAT.
/]
	CLOSE MEM,
	POPJ P,

;During master copy, for safety and backup possibilities, at end of merge
;we rename P00002.DTP_DTAPES.DAT  and  P00001.DAT_DART.DAT.
;Thus P00002.DTP contains the DTAPES.DAT info from P2,
;and P00001.DAT contains the DART.DAT info of all tapes through P1.
MERG99:	MOVE A,MEMSAV+MCITAP	;input tape number
	PUSHJ P,REEL00		;generate sixbit form in D, e.g., P00002
	MOVE A,D		;master copy, rename P00002.DTP_DTAPES.DAT
	MOVSI B,'DTP'
	POPJ P,

;Here just before CLOSE of DART.DAT that's being superseded in merge.
;Rename P00001.DAT_DART.DAT.
RENDAT:	MOVE A,MEMSAV+MCITAP	;last input tape number
	SOJLE A,CPOPJ		;nothing to rename if this was first tape
	PUSHJ P,REEL00		;generate sixbit form in D, e.g., P00001
	MOVE A,D		;master copy, rename P00001.DAT_DART.DAT
	MOVSI B,'DAT'
	MOVEI C,0		;preserve file's date and time
	MOVE D,DUMPER
	RENAME UFD,A		;P00001.DAT_DART.DAT
	 CAIA
	POPJ P,
	OUTSTR [ASCIZ/
%% Rename of old DART.DAT file to Pn.DAT lost.
/]
	PUSHJ P,WIZGO		;pause for a wizard
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            subttl merge ; PPNCMP PPNCP1 PPNCP2 PPNCP3 UIDXBW UIDXBG USET10 USET11 UIDXND UIDXFR UIDXIN UIDXWT SKPIDX SKPID1 RDIPP1 RDIPPN

;Compare TNX and DNX.   Skip if DNX is greater than or equal to TNX.
;Programmers 2, 3, and SYS are special, and are considered less than
;all others, and ordered as 2, 3, SYS.
;Note that PPNs in TNX and DNX are supposed to have programmer names
;in the LEFT half and projects in the RIGHT, with each half LEFT justified!
PPNCMP:
IFN STANSW,<
	HLRZ A,TNX	
	CAIE A,'2  '	
	CAIN A,'3  '
	JRST PPNCP2
	CAIN A,'SYS'
	JRST PPNCP2
	HLRZ A,DNX		;HERE IF T IS REGULAR
	CAIE A,'2  '
	CAIN A,'3  '
	POPJ P,			;D SPECIAL LT T REGULAR
	CAIN A,'SYS'
	POPJ P,			;D SPECIAL, T REGULAR
>;IFN STANSW
PPNCP1:	MOVE A,TNX		;HERE IF BOTH REGULAR, BOTH SPECIAL
	CAMG A,DNX
	AOS (P)			;TAPE FILE NAME < DART.DAT NAME
	POPJ P,			;TAPE FILE NAME > DART.DAT NAME.

IFN STANSW,<
PPNCP2:	HLRZ A,DNX		;HERE IF T SPECIAL
	CAIE A,'2  '
	CAIN A,'3  '
	JRST PPNCP3		;T SPECIAL, D SPECIAL
	CAIE A,'SYS'
	JRST CPOPJ1		;T SPECIAL, D REGULAR
	HLRZ A,TNX		;BOTH SPECIAL.
	CAIN A,'SYS'		;BOTH SYS?
	JRST PPNCP1		;YES.
	JRST CPOPJ1		;T NE SYS AND T SPECIAL SO D GT T

PPNCP3:	HLRZ A,TNX		;BOTH SPECIAL AND D NE SYS
	CAIN A,'SYS'
	POPJ P,			;T=SYS SO T GT D
	JRST PPNCP1		;BOTH ARE NOT SYS.
>;IFN STANSW

;HERE WHEN THERE'S NO ROOM IN THE INDEX BLOCK WE'RE BUILDING.
UIDXBW:	EXCH B,IDXPDP		;STRAIGHTEN OUT THE AC'S
	PUSH P,A
	PUSH P,B
	PUSHJ P,UIDXND		;DO THE WORK
	POP P,B
	POP P,A			;FIX STACK AND TRY AGAIN.

;HERE TO INITIATE A NEW UFD INTO THE INDEX FILE
UIDXBG:	EXCH B,IDXPDP
	CAMN B,[-2,,IDXPDL+175]	;RUN OUT OF SPACE?
	JRST UIDXBW		;YES.  THIS IS HARD.
	PUSH B,A		;STORE THE UFD NAME
	PUSH B,DATWC		;AND THE CURRENT WORD NUMBER
	EXCH B,IDXPDP
	POPJ P,

IFE STANSW,<
USET10:	PUSH P,A		;SAIL MONITOR FORCES OUT
	HRRZ A,FOBUF+1		;ALL BUFFERS BEFORE
	SUB A,FOBUF
	TRNN A,777776		;DOING USETO, BUT DEC
	JRST USET11
	OUTPUT FILE,		;DOESN'T, SO WE DO IT
	AOS FOBUF+2
USET11:	POP P,A			;FOR THEM HERE.
	POPJ P,
>;IFE STANSW

;HERE TO WRITE OLD INDEX, POINT IT TO A NEW ONE.  INITIALIZE A NEW INDEX
UIDXND:	MOVE A,DATWC		;GET WORD COUNT
	ADDI A,177
	TRZA A,177		;CALC WORD NUMBER OF NEXT INDEX BLOCK
UIDXFR:	MOVEI A,0		;END OF WORLD - FORCE LAST INDEX.
	EXCH A,IDXPDL+176	;GET OLD INDEX BLOCK WORD NUMBER
	LSH A,-7		;CONVERT TO RECORD NUMBER
IFE STANSW,<
	PUSHJ P,USET10		;DEC SYS HAS TO PREPARE
>;IFE STANSW
	USETO FILE,1(A)		;SET THE BLOCK.
	PUSHJ P,UIDXWT		;WRITE THE 128 WORDS OF INDEX.
	SKIPG A,IDXPDL+176	;GET THE WORD NUMBER OF NEXT INDEX
	POPJ P,			;ZERO MEANS LAST WAS FORCED AT EOF
	LSH A,-7
IFE STANSW,<
	PUSHJ P,USET10
>;IFE STANSW
	USETO FILE,1(A)		;SET TO WRITE BLANK INDEX BLOCK.
	JRST .+2
UIDXIN:	SETZM IDXPDL+176	;HERE TO INITIALIZE EVERYTHING
	MOVE A,[-200,,IDXPDL-1]
	MOVEM A,IDXPDP
	SETZM IDXPDL
	MOVE A,[IDXPDL,,IDXPDL+1]
	BLT A,IDXPDL+175	;CLEAR FRESH INDEX BLOCK
	MOVEI A,200
	ADD A,IDXPDL+176
	MOVEM A,DATWC		;COUNT THE INDEX IN THE WC
UIDXWT: MOVSI B,-200
	MOVE A,IDXPDL(B)
	PUSHJ P,DFWRIT
	AOBJN B,.-2
	POPJ P,

SKPIDX:	PUSHJ P,UFDRD
	 POPJ P,		;END OF FILE?
SKPID1:	MOVSI B,-173
	PUSHJ P,UFDRD
	 JFCL
	AOBJN B,.-2
	PUSHJ P,UFDRD
	 JFCL
	MOVEM A,LSTIPP		;SAVE NAME OF LAST INDEXED PPN
	SETOM LSTRPP		;NAME OF LAST PPN READ
	MOVSI B,-3
	PUSHJ P,UFDRD
	 JFCL
	AOBJN B,.-2
	POPJ P,

;NOW, SKIP ZEROS UNTIL WE SEE THE NEXT INDEX BLOCK, IF ANY
RDIPP1:	JUMPE A,CPOPJ		;JUMP IF LAST INDEXED PPN IS ZERO.
	PUSHJ P,UFDRD
	 POPJ P,
	JUMPE A,.-2		;SKIP NULLS.
	PUSHJ P,SKPID1		;SKIP INDEX BLOCK
RDIPPN:	MOVE A,LSTIPP		;GET NAME OF LAST PPN IN INDEX
	CAMN A,LSTRPP		;SAME AS LAST PPN READ?
	JRST RDIPP1		;YES. NOW SKIP TO INDEX
	PUSHJ P,UFDRD
	 POPJ P,		;END OF FILE.
	MOVEM A,LSTRPP
repeat 0,< ;code for flushing special duplicated entries from DART.DAT
printx Flush this kludge in RDIPPN to set flag for 570,DON.
    CAMN A,['570DON']
    HRLOS DONFLG#   ;goes negative on second occurrence of UFD
>;repeat 0
	JRST CPOPJ1
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           subttl reel text file output routines ; DMFRC0 DMFRC DMFRC2 DMINI DMINIP DMFINI DMINIC DMPUTE DMPUT1 DMPUTX DMPUT TPGDON TPGCLS DSMOC1 DSMOC2 DSMOC3 DSMPPN DSMPPO DSMPPN DSMSX2 DSMSX1 TPGPUT TPGPU1 TPGPU2 TPGPU3 TPGINY TPGINI TPGINX DSDATE DDDEC DMSTR DMSTR1 SPOOL SPOOL1 SPOOL2 SPOOL3 INTSPL INISP1

DMFRC:	OUTPUT DSKMSC,[IOWD 200,REELBF ;FORCE CURRENT BUFFER OUT.
			0]
	STATZ DSKMSC,740000
	 PUSHJ P,DMPUTE		;output error
IFN STANSW,<
	SKIPN ARCCMD		;skip if archive cmd
	MTAPE DSKMSC,['GODMOD'  17] ;force retrieval updated to include new length
>;IFN STANSW
	MOVE A,ARCWC		;check output word count, in case tape copy
	CAMLE A,MEMSAV+DTAMAX	;is this biggest the file has been?
	MOVEM A,MEMSAV+DTAMAX	;yes, remember max size
DMINI:	PUSHJ P,DMINIC		;clear the buffer
DMINIP:	SKIPE DSKMM3		;SKIP IF ASCII MODE
	SKIPA A,[POINT 36,REELBF] ;SET BINARY MODE
	MOVE A,[POINT 7,REELBF]	;SET ASCII MODE
	MOVEM A,DSKMM1
	MOVE A,[SOSGE DSKMM2]
	MOVEM A,XDMPUT		;SETUP INSTR. TO XCT.
	MOVEI A,5*200
	SKIPE DSKMM3		;SKIP IF ASCII
	MOVEI A,200		;BINARY MODE
	MOVEM A,DSKMM2
	POPJ P,

DMFINI:	MOVE A,DSKMM2
	SUBI A,200		;GET -WC OF LAST DTAPES.DAT REC
	JUMPGE A,CPOPJ		;NO WORK TO DO
	HRLZ A,A		;-WC IN LEFT HALF
	HRRI A,REELBF-1		;MA-1 IN RIGHT HALF
	MOVEI B,0		;STOP THE DUMP MODE COMMAND LIST
	OUTPUT DSKMSC,A		;OUTPUT LAST REC
	STATO DSKMSC,740000
	 POPJ P,
	OUTSTR [ASCIZ/%%% DTAPES.DAT disk output error.
/]
	HALT .

DMINIC:	MOVE A,[REELBF,,REELBF+1]
	SETZM REELBF
	BLT A,REELBF+177
	POPJ P,

DMPUTE:	OUTSTR [ASCIZ/%%% Disk file output error (DSKMSC).
/]
	HALT .
	POPJ P,

DMPUT1:	PUSH P,A
	PUSHJ P,DMFRC		;write out current buffer
	POP P,A
	AOS DSKMM0		;count another record written
	JRST DMPUT

DMPUTX:	AOS ARCWC		;WORD COUNT OF DART.ARC OUTPUT
DMPUT:	XCT XDMPUT		;SOSGE DSKMM2, EXCEPT IN MRESTORE: JRST LSTOUT
	JRST DMPUT1
	IDPB A,DSKMM1
	POPJ P,


TPGDON:	HRRZ A,TPGPDP
	CAIL A,TPBUF		;SKIP IF CURRENT PAGE IS EMPTY.
	PUSHJ P,TPGPUT		;OUTPUT THE CURRENT PAGE.
	POPJ P,

TPGCLS:	PUSHJ P,TPGDON
	MOVEI A,0
	DPB A,DSKMM1		;CLOBBER THE FINAL FF, CLOSE FILE.
	SETZB A,DSKMM2
	PUSHJ P,DMPUT
	CLOSE DSKMSC,
	POPJ P,

IFE STANSW,<
DSMOC1:	SUBI C,1
	IDIVI A,10
	JUMPE A,DSMOC2
	HRLM B,(P)
	PUSHJ P,DSMOC1
	HLRZ B,(P)
DSMOC2:	SOJL C,DSMOC3
	MOVEI A,40
	PUSHJ P,DMPUT
	JRST DSMOC2

DSMOC3:	MOVEI A,"0"(B)
	JRST DMPUT

IFE IRCPPN,<
DSMPPN:	PUSH P,B
>;IFE IRCPPN
DSMPPO:	HLRZ A,B
IFN IRCPPN,<
	MOVEI C,3
>;IFN IRCPPN
IFE IRCPPN,<
	MOVEI C,6
>;IFE IRCPPN
	PUSHJ P,DSMOC1
	MOVEI A,","
	PUSHJ P,DMPUT
	POP P,B
	MOVEI A,(B)
	MOVEI C,6
	PUSHJ P,DSMOC1
	MOVEI B,[ASCIZ /   /]
	JRST DMSTR
>;IFE STANSW

IFN IRCPPN,<
DSMPPN:	PUSH P,B
	TLNE B,777740
	TRNN B,777740
	JRST DSMPPO
	TLNN B,77
	JRST DSMPPO
	HLLZS B
	MOVEI C,3
	PUSHJ P,DSMSX2
	MOVEI A,","
	PUSHJ P,DMPUT
	POP P,B
	HRLZS B
	MOVEI C,9
DSMSX2:	TLNE B,770000
	TLO B,400000		;DROP INTO DSMSX1
>;IFN IRCPPN
DSMSX1:	MOVEI A,0
	LSHC A,6
	ADDI A," "
	PUSHJ P,DMPUT
	SOJG C,DSMSX1
	POPJ P,

TPGPUT:	PUSH P,B
	DATE A,
	PUSHJ P,DSDATE		;WRITE CURRENT DATE
IFE STANSW,<
	MOVEI B,[ASCIZ /  /]
	PUSHJ P,DMSTR
	MOVE B,STRNAM
	MOVEI C,6
	PUSHJ P,DSMSX1
>;IFE STANSW
	MOVEI B,[ASCIZ/  DART Tape Listing.   Tape Number /]
	SKIPE TPGFLG
	MOVEI B,[ASCIZ/     MRESTORE List			Tape Number /]
	PUSHJ P,DMSTR
	MOVEI C,12
	MOVE B,TAPNAM		;TAPE NAME E.G., T00031
	PUSHJ P,DSMSX1		;WRITE FILE NAME AND 4 SPACES
	MOVEI B,[ASCIZ/Page /]
	PUSHJ P,DMSTR
	AOS A,TPGNUM		;INCREMENT PAGE NUMBER
	PUSHJ P,DDDEC		;WRITE DECIMAL
	MOVEI B,[BYTE(7)15,12,12]
	PUSHJ P,DMSTR		;CR LF LF TO END HEADING.
	MOVSI D,-<TPBUFL/2>
TPGPU1:	SKIPN B,TPBUF(D)
	JRST TPGPU3		;JUMP IF ALL DONE.
	MOVEI C,10
	PUSHJ P,DSMSX1		;FILE NAME
	HLLZ B,TPBUF+1(D)
	MOVEI C,6
	PUSHJ P,DSMSX1		;EXTENSION
IFN STANSW,<
	HLLZ B,TPBUF+2(D)
	MOVEI C,3
	PUSHJ P,DSMSX1		;PRJ
	MOVEI A,","
	PUSHJ P,DMPUT		;,
	HRLZ B,TPBUF+2(D)
	MOVEI C,6
	PUSHJ P,DSMSX1		;PRG
>;IFN STANSW
IFE STANSW,<
	MOVE B,TPBUF+2(D)
	PUSHJ P,DSMPPN
>;IFE STANSW
	HRRZ A,TPBUF+1(D)
	SKIPN TPGFLG		;NO DATE IF MRESTORE
	PUSHJ P,DSDATE		;DATE
	MOVEI B,[ASCIZ/    /]
	PUSHJ P,DMSTR		;SPACES
	SKIPN B,TPBUF+<TPBUFL/2>(D)
	JRST TPGPU2		;SECOND COLUMN ENDS EARLY
	MOVEI C,10
	PUSHJ P,DSMSX1		;FILE NAME
	HLLZ B,TPBUF+1+<TPBUFL/2>(D)
	MOVEI C,6
	PUSHJ P,DSMSX1		;EXTENSION
IFN STANSW,<
	HLLZ B,TPBUF+2+<TPBUFL/2>(D)
	MOVEI C,3
	PUSHJ P,DSMSX1		;PRJ
	MOVEI A,","
	PUSHJ P,DMPUT		;,
	HRLZ B,TPBUF+2+<TPBUFL/2>(D)
	MOVEI C,6
	PUSHJ P,DSMSX1		;PRG
>;IFN STANSW
IFE STANSW,<
	MOVE B,TPBUF+2+<TPBUFL/2>(D)
	PUSHJ P,DSMPPN
>;IFE STANSW
	HRRZ A,TPBUF+1+<TPBUFL/2>(D)
	SKIPN TPGFLG		;NO DATE IF MRESTORE
	PUSHJ P,DSDATE		;DATE
TPGPU2:	MOVEI A,15
	PUSHJ P,DMPUT		;CR
	ADD D,[3,,3]
	JUMPGE D,TPGPU3
	MOVEI A,12
	PUSHJ P,DMPUT
	JRST TPGPU1

TPGPU3:	MOVEI A,14
	PUSHJ P,DMPUT		;FF TO END PAGE
	POP P,B			;RESTORE B AND
TPGINY:	SETZM TPBUF		;INITIALIZE NEW PAGE.
	MOVE A,[TPBUF,,TPBUF+1]
	BLT A,TPBUF+TPBUFL-1
	MOVE A,[-<TPBUFL+1>,,TPBUF-1] ;PDL POINTER 1 EXTRA COUNT.
	MOVEM A,TPGPDP		;SAVE IT
	POPJ P,

TPGINI:	SETZM TPGFLG
	JRST TPGINY

TPGINX:	SETOM TPGFLG		;FLAG THIS IS MRESTORE LISTING
	JRST TPGINY

DSDATE:	IDIVI A,37
	PUSH P,A
	MOVEI A," "
	CAIGE B,11
	PUSHJ P,DMPUT
	MOVEI A,1(B)
	PUSHJ P,DDDEC
	MOVEI A,"-"
	PUSHJ P,DMPUT
	POP P,A
	IDIVI A,14
	PUSH P,A
	ADDI B,MONTAB
	PUSHJ P,DMSTR
	POP P,A	
	ADDI A,100		;ADD TO MAKE 1964, AND FALL INTO PRINTER
DDDEC:	IDIVI A,12
	HRLM B,(P)
	JUMPE A,.+2
	PUSHJ P,DDDEC
	HLRZ A,(P)
	ADDI A,"0"
	JRST DMPUT


DMSTR:	HRLI B,440700
DMSTR1:	ILDB A,B
	JUMPE A,CPOPJ
	PUSHJ P,DMPUT
	JRST DMSTR1

SPOOL:
IFE STANSW,<POPJ P,>
IFN STANSW,<
IFN DBGSW,<POPJ P,>
	MOVE A,LOGPPN
	MOVEM A,SPLREQ
	MOVEM A,SPLPPN
	MOVE A,STRNAM
	MOVEM A,SPLDEV
	TIMER A,
	IDIVI A,74*74
	DATE B,
	HRL A,B
	MOVEM A,SPLTIM
	GETLIN A		;get line number
	MOVEM A,SPLJOB
	PJOB A,
	HRLM A,SPLJOB		;JOB,,LINE
	MOVE A,DSKMM0		;GET THE NUMBER OF RECORDS.
	MOVEM A,SPLSIZ
	DATE A,
	TIMER B,
	LSH A,30
	OR A,B			;INVENT A NAME.
	MOVEI W,10
SPOOL1:	MOVSI B,SPLEXT		;spooler cmd file extension
	MOVEI C,0
	MOVE D,PPNSPL
	LOOKUP DSKMSC,A
	JRST SPOOL2
	AOJA A,SPOOL1
SPOOL2:	MOVE D,PPNSPL
	MOVSI B,SPLEXT		;spooler cmd file extension
	MOVEI C,0
	SOJL W,CPOPJ
	ENTER DSKMSC,A
	AOJA A,SPOOL1
	OUTPUT DSKMSC,SPLIOW
	CLOSE DSKMSC,
	MOVE A,NAMSPL
	NAMEIN A,
	JRST INTSPL
SPOOL3:	SETZM ALLBUF		;A HAS JOBNUMBER.
	MOVE B,[ALLBUF,,ALLBUF+1]
	BLT B,ALLBUF+37
	MOVEI B,ALLBUF
	SEND A
	JFCL
	POPJ P,

INTSPL:	TRNE A,2
	POPJ P,			;MULTIPLE SPOOLERS EXIST.
	MOVEI A,NAMSPL		;WAKE A SPOOLER
	WAKEME A,
	POPJ P,			;CAN'T WAKE ONE.
	MOVEI B,30
INISP1:	MOVEI A,1
	SLEEP A,
	MOVE A,NAMSPL
	NAMEIN A,
	SOJGE B,INISP1
	JUMPGE B,SPOOL3
	POPJ P,			;SPOOLER DOESN'T HAPPEN.
>;IFN STANSW
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      subttl merge -- read and write data ; TNREAD TNRDR1 TNRD3 TNRD1 TNRD2 UFDCNV UFDCN1 MMREAD MMRED1 MMRED2 MMRFLS MMRED3 MMRED4 MMWRIT MMWRT0 MMWRT1 MMMWRT

TNREAD:	AOSLE MEMWC
	POPJ P,
	AOSL MEMWC2
	JRST TNRDR1
	ILDB A,MEMWC1
	JRST CPOPJ1

TNRDR1:	INPUT MEM,[IOWD 200,MEMBLK
			0]
	STATZ MEM,740000
	JRST TNRD2
TNRD3:	MOVE A,[POINT 36,MEMBLK]
	MOVEM A,MEMWC1
	MOVNI A,200
	MOVEM A,MEMWC2
	ILDB A,MEMWC1
	JRST CPOPJ1

TNRD1:	PUSHJ P,TNREAD
	 CAIA
	POPJ P,
	OUTSTR [ASCIZ/%%% Unexpected end of file on tape data file.
/]
	MOVEI A,0
	HALT CPOPJ

TNRD2:	OUTSTR [ASCIZ/%%% Disk data error reading tape data file during MERGE.
/]
	SETZM MEMBLK
	MOVE A,[MEMBLK,,MEMBLK+1]
	BLT A,MEMBLK+177
	HALT TNRD3


UFDCNV:
IFN IRCPPN,<
	TLNE A,777740
	TRNN A,777740
	JRST UFDCN1
	TLNN A,77
	JRST UFDCN1
>;IFN IRCPPN
IFN STANSW!IRCPPN,<
	PUSH P,B
	HRRZ B,A
	TRNE B,770000
	JRST .+3
	LSH B,6
	JUMPN B,.-3
	HLRZ A,A
	TRNE A,770000
	JRST .+3
	LSH A,6
	JUMPN A,.-3
	HRL A,B
	POP P,B
>;IFN STANSW!IRCPPN
IFN IRCPPN,<
UFDCN1:	TDO A,[400000,,400000]
>;IFN IRCPPN
	POPJ P,

;READ FILE DATA FROM DART.DAT.
MMREAD:	MOVE B,MJBFF		;GET ADDRESS OF FIRST FREE
	PUSHJ P,UFDRD		;READ FROM DART.DAT
	 JFCL
	MOVEM A,MMNAM		;SAVE FILE NAME
	JUMPE A,CPOPJ
	PUSHJ P,UFDRD		;READ EXTENSION
	 JFCL
	MOVEM A,MMEXT		;SAVE EXTENSION.
	HRRZ C,A		;GET THE COUNT.
MMRED1:	PUSHJ P,UFDRD		;READ DATA.
	 JFCL
	CAMG B,.JBREL
	JRST MMRED2
	MOVE D,.JBREL
	ADDI D,2000
	CORE D,
	 JRST NOCORE
MMRED2:	MOVEM A,(B)		;STUFF THE DATA.
	HLRZ A,A		;GET THE TAPE NUMBER ONLY
printx Does MMREAD need to compare tape number plus relative dump nbr for P dumps?
;That is, formerly, if we restarted a dump or reused a P tape number, Dart would
;flush old data about reused tapes from DART.DAT.  Now we'll be re-using tapes
;all the time, although with new relative dumps.  Maybe TTBUF needs to include
;relative dumps as well as tape numbers, so this can be done right.
	TRNE FL,PCLASS		;SKIP IF DUMP TCLASS
	TRC A,400000		;COMPLEMENT TAPE TCLASS BIT
	SKIPN MASCOP		;don't flush any data during tape copy!
	TRZN A,400000		;CLEAR TAPE TCLASS, SKIP IF WAS SET
	JRST MMRED3		;CLASSES DON'T MATCH:NOT THIS DUMP
	PUSH P,B		;SAVE REG (USED BY TAPCMP)
	PUSH P,C		;SAVE REG (USED BY TAPCMP)
ifn 0,<
;; Special code to flush T tape info for T tapes that no longer exist
;; after NTTAPE has been reduced.
	TRNN FL,PCLASS		;skip unless T dump (and therefore T tape nbr in A)
	CAIG A,NTTAPE		;if tape number out of range, 
	CAIA			;P tape or reasonable number T tape
	JRST MMRFLS		;T tape beyond last retained T tape, flush data
>;ifn 0
repeat 0,<	;flushing special duplicate entries
printx Flush this kludge in MMREAD to ignore 570,DON and C,DON.
	SKIPGE DONFLG
	JRST MMRFLS		;flush entry
>;repeat 0
	PUSHJ P,TAPCMP		;WAS DART.DAT TAPNO USED THIS DUMP?
	 SETO A,		;NO SKIP RET:NO
MMRFLS:	POP P,C			;SKIP RET:YES
	POP P,B
	JUMPGE A,.+2		;WAS DART.DAT TAPNO USED THIS DUMP?
MMRED3:	AOJA B,MMRED4		;NO. SO WE INCREMENT B.
	SOS MMEXT		;YES. DECREMENT COUNT IN MMEXT,
				;TO DELETE THIS OVERRIDDEN TAPE ENT.
MMRED4:	SOJG C,MMRED1
	POPJ P,


;WRITE DATA FROM CORE TO DART.DAT
MMWRIT:	HRRZ A,MMEXT		;GET THE COUNT
	JUMPE A,CPOPJ
	MOVE A,MMNAM		;GET THE NAME.
	PUSHJ P,DFWRTX		;WRITE IT
	MOVE A,MMEXT		;GET THE EXT, COUNT
	PUSHJ P,DFWRTX
	HRRZ C,A
MMWRT0:	MOVE B,MJBFF
MMWRT1:	MOVE A,(B)
	PUSHJ P,DFWRTX
	ADDI B,1
	SOJG C,MMWRT1
	POPJ P,

;WRITE DATA FROM CORE AND AUGMENT
MMMWRT:	MOVE A,MMNAM		;GET NAME
	PUSHJ P,DFWRTX
	AOS A,MMEXT		;INCREASE COUNT
	PUSHJ P,DFWRTX
	MOVEI C,-1(A)		;COUNT OF INCORE DATA
	MOVE A,MMDAT		;THE EXTRA WORD
	PUSHJ P,DFWRTX
	JUMPN C,MMWRT0
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      subttl verify the format of DART.DAT or DART.ARC ; VERNAM VERIFY IDXBUF VERDAT VERARC MCPVER VERIDX VERID1 VERID2 VRID2A Data VERID3 VERID4 VERID5 VERPPN VERFIL VERFL1 VERFL2 VERATD VEROOD VERFL3 VERTBG VERPBG VERTB2 VERIEN VEREOF VERNPN VERNP1 Location VERBEF VEREFE VEREF1 VERPNO TWOSAM EXTOOO VEROK

VERNAM:	'DART  '		;primary filename for verify, easily patchable

;Here from VERIFY command.  Verify format of .DAT and .ARC files.
VERIFY:	PUSHJ P,VERDAT		;verify .DAT
	PUSHJ P,VERARC		;verify .ARC
	POPJ P,

;Start here from DDT to read DART.DAT or DART.ARC to verify their goodness.
;Also come here from PTCNT, to count files on each tape.
;And enter at MCPVER from MCOPY to verify DART.DAT we just made.
IDXBUF=LOGBUF			;no harm in re-using the reap log buffer?
VERDAT:	SKIPA B,['DAT   ']
VERARC:	MOVSI B,'ARC'
	PUSH P,B		;Save extension
	PUSH P,.JBFF
	RESET			;don't accidentally close a partial DART.DAT file!
	POP P,.JBFF		;don't let RESET diddle this
	SETZM REDOPN		;no magtape open for reading
	SETZM WRTOPN		;no magtape open for writing
	SETZM MT2BUF		;no second set of magtape buffers, jobff reset
	DATE A,
	MOVEM A,TODAYD		;remember today's date, to check dates
	MOVEI A,10
	MOVSI B,'DSK'
	MOVEM B,STRNAM
	MOVEI C,UFDBUF
	OPEN UFD,A		;DART.DAT INPUT
	 PUSHJ P,NODEV
	INBUF UFD,NBUFS		;SOME BUFFERS
	POP P,B			;extension DAT or ARC
	CAIA
MCPVER:	MOVSI B,'DAT'		;Enter here from MCOPY to check resulting DART.DAT
	MOVEI A,UFD
	SHOWIT A,		;show file on wholine
	OUTSTR [ASCIZ/Verifying: /]
	MOVE A,VERNAM		;READ THE MASTER FILE
	MOVEI C,0
	MOVE D,DUMPER
	PUSH P,A
	PUSH P,B
	PUSH P,C
	PUSH P,D
	PUSHJ P,OUTFIL		;type the filename
	OUTSTR CRLF
	POP P,D
	POP P,C
	POP P,B
	POP P,A
	LOOKUP UFD,A		;SEEK INPUT FILE.
	 JRST [	OUTSTR [ASCIZ/File not found
/]
		HALT CPOPJ]
	MOVS D,D
	MOVN W,D		;Word count of file
	SETZB X,DNX		;current word position. prev ppn
	MOVEI Z,0		;previous PPN ptr
VERIDX:	MOVE B,[-200,,IDXBUF]	;Current block is an index.
VERID1:	PUSHJ P,UFDRD				
	 JRST [	OUTSTR [ASCIZ/Unexpected End of file at VERIDX.
(I was expecting to read an index block here.)
/]
		HALT CPOPJ]
	ADDI X,1		;count words read in file
	MOVEM A,(B)
	AOBJN B,VERID1
	MOVE Y,[-176,,IDXBUF]	;Scan the entries
VERID2:	SKIPN A,(Y)		;get a ppn
	JRST VRID2A		;check remainder must be zero
	PUSHJ P,UFDCNV		;swap PPN halves and left justify
	MOVEM A,TNX		;save current PPN
	SKIPE DNX
	PUSHJ P,PPNCMP		;Compare DNX, TNX
	 JRST VERID3		;DNX is smaller (as is right)
	OUTSTR [ASCIZ/PPNs are not in order in the index.
Previous = /]
	MOVS A,DNX
	PUSHJ P,PPNOUT
	OUTSTR [ASCIZ/; current = /]
	MOVS A,TNX
	PUSHJ P,PPNOUT
	OUTSTR [ASCIZ/
Pause to examine:
/]
	HALT VERID3

VRID2A:	SKIPE A,(Y)
	JRST [OUTSTR [ASCIZ/After finding one zero PPN in the index block
I expect only zeroes in the balance of the block.  Found a non-zero word.
Data: /]
		PUSHJ P,OCTOUT
		OUTSTR [ASCIZ/  /]
		MOVE A,(Y)
		MOVEI B,-IDXBUF(Y) ;relative word number in IDXBUF
		TLNN B,1	;skip if odd
		PUSHJ P,PPNOUT	;even. try as a ppn.
		OUTSTR [ASCIZ/; file location: /]
		MOVE A,X
		SUBI A,200
		ADDI A,-IDXBUF(Y)
		PUSHJ P,OCTOUT
		OUTSTR CRLF
		HALT .+1]
	AOBJN Y,VRID2A
	SKIPE IDXBUF+176	;should be zero
	JRST [OUTSTR [ASCIZ/After finding zero PPNs in the index block
I expected the pointer to the next index block to be zero.  It wasn't.
Current file position = /]
		JRST VERID5]

	JRST VERID4		;(Y is already counted out)
	
VERID3:	CAML Z,1(Y)		;is PPN ptr greater than previous PPN ptr?
	PUSHJ P,VERPNO		;no
	MOVE Z,1(Y)		;save current PPN ptr to previous
	MOVE A,TNX		;copy current PPN to previous
	MOVEM A,DNX
	CAML W,1(Y)
	JRST VERID4
	OUTSTR [ASCIZ/Pointer in index block is out of bounds.  PPN = /]
	MOVE A,(Y)
	PUSHJ P,PPNOUT
	OUTSTR [ASCIZ/; points to /]
	MOVE A,1(Y)
	PUSHJ P,OCTOUT
	OUTSTR [ASCIZ/; file word count = /]
	MOVE A,W
	PUSHJ P,OCTOUT
	OUTSTR CRLF
	HALT .+1
VERID4:	ADD Y,[2,,2]
	JUMPL Y,VERID2
	CAMG W,IDXBUF+176
	JRST [OUTSTR [ASCIZ/Word 176 of an index buffer points beyond file limit!
Current file position = /]
VERID5:		MOVE A,X
		SUBI A,2
		PUSHJ P,OCTOUT
		OUTSTR [ASCIZ/; data word = /]
		MOVE A,IDXBUF+176
		PUSHJ P,OCTOUT
		OUTSTR CRLF
		HALT CPOPJ]
	SKIPE IDXBUF+177	;expect a zero here
	OUTSTR [ASCIZ/Word 177 of an index buffer isn't zero
/]
	MOVE Y,[-176,,IDXBUF]	;point to good stuff.
VERPPN:	SETZM VEFILE		;no previous file for this PPN
	SKIPG 1(Y)		;are we expecting more?
	JRST VEREFE		;no. we expect eof!
	CAME X,1(Y)		;test for position is right!
	JRST [OUTSTR [ASCIZ/At VERPPN - supposed to be start of PPN - 
but the current file position - /]
		MOVE A,X
		PUSHJ P,OCTOUT
		OUTSTR [ASCIZ/ - doesn't match the next index location:
/]		
		MOVE A,(Y)
		PUSHJ P,PPNOUT
		OUTSTR [ASCIZ/  /]
		MOVE A,1(Y)
		PUSHJ P,OCTOUT
		OUTSTR CRLF
		HALT CPOPJ]	;starts a ppn, not match index
	PUSHJ P,UFDRD		;read a word
	 JRST VERBEF		;bad end of file
	ADDI X,1		;count a word read
	MOVSM A,TNX		;save PPN (swapped)
	CAME A,(Y)		;test for ppn matches
	JRST [OUTSTR [ASCIZ/Index & Data says a ppn starts here.  The data
word is /]
		PUSH P,A
		PUSHJ P,OCTOUT
		OUTSTR [ASCIZ/  /]
		MOVE A,(P)
		PUSHJ P,PPNOUT
		OUTSTR [ASCIZ/; Index told us to expect /]
		MOVE A,(Y)
		PUSHJ P,PPNOUT
		OUTSTR CRLF
		POP P,A
		HALT CPOPJ]	;ppn mismatches index
VERFIL:	PUSHJ P,UFDRD		;read a file name
	 JRST VERBEF		;bad end of file
	ADDI X,1		;count word read
	JUMPE A,VERNPN		;zero name means next PPN follows.
	EXCH A,VEFILE		;save filename
	SKIPE A			;if old file is zero, this is first file in PPN
	CAMG A,VEFILE		;skip if filenames out of order
	CAIA
	PUSHJ P,[OUTSTR [ASCIZ/Filenames within PPN out of order; see A and VEFILE.
/]
		 HALT CPOPJ]
	XOR A,VEFILE		;see if same as previous
	MOVEM A,VEFDIF		;store flag for different names
	PUSHJ P,UFDRD		;read extension & count
	 JRST VERBEF		;bad end of file
	HLLZ B,A		;extension
	EXCH B,VEEXT		;save ext
	SKIPN VEFDIF		;different primary names?
	CAMGE B,VEEXT		;no, are exts in right order?
	CAIA			;OK
	PUSHJ P,TWOSAM		;filenames are same or exts are out of order
	ADDI X,1
	HRRZ B,A		;count of the words to follow
	MOVNM P,LASTDT		;set last date to large positive number in LH
VERFL1:	PUSHJ P,UFDRD		;read tape & date word
	 JRST VERBEF
	PUSH P,A		;save tape,,date
	ANDI A,DATMSK		;just the date
	CAMLE A,TODAYD		;should be today or earlier
	PUSHJ P,VERATD		;bad -- date is in future
;; This test is commented out since many files have dates out of order.
;; That can happen from restoring an old version and having it dumped again.
;;	CAMLE A,LASTDT		;dump dates in order?
;;	PUSHJ P,VEROOD		;no
	MOVEM A,LASTDT		;remember new latest date
	POP P,A
	HLR A,A			;get P tape number, etc., in RH
	JUMPL A,VERFL3		;jump if T tape -- won't count files on it
	ANDI A,TAPMSK		;just tape number
	SKIPE A			;zero is unexpected tape number
	CAIL A,PTCNTL-1		;make sure tape number within range
	PUSHJ P,VERPBG		;P tape number too big
	SKIPG PTCNTP		;skip if counting
	JRST VERFL2
	CAILE A,PTCNTL-1	;make sure tape number within range
	MOVEI A,PTCNTL-1	;cnt for tape nbr PTCNTL-1 is for out of range
	AOS @PTCNTP		;count a file on this P tape (A is index reg)
VERFL2:	ADDI X,1		;discard
	SOJG B,VERFL1		; tape & date words
	JRST VERFIL		;get next file

VERATD:	OUTSTR [ASCIZ/Date written /]
	PUSH P,B
	PUSHJ P,TYDATE		;report date
	OUTSTR [ASCIZ/ for some file dumped from: /]
	MOVE A,(Y)
	PUSHJ P,PPNOUT		;type PPN
	POP P,B
	OUTSTR [ASCIZ/ is in the future!
/]
	HALT CPOPJ

VEROOD:	OUTSTR [ASCIZ/Date written /]
	PUSH P,A
	PUSH P,B
	PUSH P,C
	PUSH P,D
	PUSHJ P,TYDATE		;report date
	OUTSTR [ASCIZ/ for: /]
	MOVE A,VEFILE
	MOVE B,VEEXT
	MOVE D,(Y)
	PUSHJ P,TYFIL		;type filename
	POP P,D
	POP P,C
	POP P,B
	POP P,A
	OUTSTR [ASCIZ/ is out of order.
/]
	HALT CPOPJ

;Here if T tape
VERFL3:	ANDI A,TAPMSK		;just tape number
	SKIPE A			;zero is unexpected tape number
	CAILE A,NTTAPE		;in range?
	PUSHJ P,VERTBG		;no, report it
	JRST VERFL2

VERTBG:	OUTSTR [ASCIZ/Tape number T/]
	JRST VERTB2

VERPBG:	OUTSTR [ASCIZ/Tape number P/]
VERTB2:	PUSH P,A
	PUSH P,B
	PUSHJ P,DECOUT
	OUTSTR [ASCIZ/ is out of range, for some file dumped from: /]
	MOVE A,(Y)
	PUSHJ P,PPNOUT
	POP P,B
	POP P,A			;restore bad tape number
	OUTSTR CRLF
	HALT CPOPJ

VERIEN:	PUSHJ P,UFDRD		;read a word
	 JRST VEREOF		;end of file, as expected, check word counts
	SKIPN A			;better be all zero data hereafter
	AOJA X,VERIEN		;count a word read, ignore zeroes at end of file
	OUTSTR [ASCIZ/Reached end of index at end of index block,
but read non-zero datum from file after last PPN's data.
Current pointer:	/]
	PUSH P,A		;datum
	MOVE A,X
	PUSHJ P,OCTOUT		;pointer
	OUTSTR [ASCIZ/     Datum found:  /]
	POP P,A
	PUSHJ P,OCTOUT		;datum
	OUTSTR [ASCIZ/
EOF expected at:	/]
	MOVE A,W		;EOF
	PUSHJ P,OCTOUT
	OUTSTR CRLF
	HALT CPOPJ
	
VEREOF:	CAME X,W		;should be EOF
	JRST [	OUTSTR [ASCIZ/Reached end of index at end of index block,
but current pointer:	/]
		MOVE A,X	;pointer
		PUSHJ P,OCTOUT
		OUTSTR [ASCIZ/
hasn't reached EOF:	/]
		MOVE A,W	;EOF point
		PUSHJ P,OCTOUT
		OUTSTR CRLF
		HALT CPOPJ]
	SKIPE IDXBUF+177	;check last word in index block, always zero
	JRST [	OUTSTR [ASCIZ/Word 177 in final index block isn't zero: /]
		MOVE A,IDXBUF+177
		PUSHJ P,OCTOUT
		OUTSTR CRLF
		HALT CPOPJ]
	JRST VEROK		;all done

VERNPN:	ADD Y,[2,,2]		;advance to point to next
	JUMPL Y,VERPPN		;ppn & word number pair
;ran thru all the data in the current index.  we should skip zero words
;until we get to the next index block
	SKIPN IDXBUF+176	;skip unless this is end of the index
	JRST VERIEN		;end of index, make final check
	CAMLE X,IDXBUF+176	;Is this sensible?
	JRST [	OUTSTR [ASCIZ/We just finished a PPN and an index block.
But our file location - /]
		MOVE A,X
		PUSHJ P,OCTOUT
		OUTSTR [ASCIZ/ - is past where the index tells us the
next index is found: /]
		MOVE A,IDXBUF+176
		PUSHJ P,OCTOUT
		OUTSTR CRLF
		HALT CPOPJ]	;we read past the next index?
VERNP1:	CAML X,IDXBUF+176
	JRST VERIDX
	PUSHJ P,UFDRD
	 JRST VERBEF
	SKIPE A
	JRST [OUTSTR [ASCIZ/VERNP1 - we're skipping words between end of
a PPN and start of the next index block.  We just found a non-zero word.
Location: /]
		PUSH P,A
		MOVE A,X
		PUSHJ P,OCTOUT
		OUTSTR [ASCIZ/;   data word: /]
		MOVE A,(P)
		PUSHJ P,OCTOUT
		MOVE A,(P)
		OUTSTR [ASCIZ/  /]
		PUSHJ P,PPNOUT
		OUTSTR CRLF
		POP P,A
		HALT CPOPJ]	;words skipped should be zero
	AOJA X,VERNP1
	POPJ P,

VERBEF:	OUTSTR [ASCIZ/Unexpected End of File.
/]
	HALT CPOPJ

VEREFE:	CAMN X,W
	JRST VEROK
	CAML X,W
	JRST [OUTSTR [ASCIZ/VERPPN-VEREFE - hopeless confusion
Seemingly we've just read past the end of file.
File location = /]
		MOVE A,X
		PUSHJ P,OCTOUT
		OUTSTR [ASCIZ/; file length = /]
		MOVE A,W
		PUSHJ P,OCTOUT
		OUTSTR CRLF
		HALT CPOPJ]
	ADDI X,200		;Are we within one record of done?
	CAMG X,W
	JRST [OUTSTR [ASCIZ/VERPPN-VEREFE
Found a zero word in the index block.  This should correspond to end of file.
But we're close enough to EOF yet.
File location = /]
		SUBI X,200
		MOVE A,X
		PUSHJ P,OCTOUT
		OUTSTR [ASCIZ/; file length = /]
		MOVE A,W
		PUSHJ P,OCTOUT
		OUTSTR CRLF
		HALT CPOPJ]
	SUBI X,200		;back to the right place
VEREF1:	CAML X,W
	JRST VEROK		;done finally
	PUSHJ P,UFDRD
	 JRST VERBEF		;we're counting and don't want eof
	ADDI X,1
	JUMPE A,VEREF1		;discard nulls at end.
	OUTSTR [ASCIZ/VERPPN-VEREFE
Found a zero word in the index block.  This should correspond to end of file.
We're close to the end of this file, but there's non-zero data here.
Data = /]
	PUSHJ P,OCTOUT
	OUTSTR [ASCIZ/; File location = /]
	MOVE A,X
	PUSHJ P,OCTOUT
	OUTSTR [ASCIZ/; file length = /]
	MOVE A,W
	PUSHJ P,OCTOUT
	OUTSTR CRLF
	HALT CPOPJ

VERPNO:	OUTSTR [ASCIZ/PPN pointers are not in ascending order.
Previous PPN = /]
	MOVS A,DNX
	PUSHJ P,PPNOUT
	OUTSTR [ASCIZ/, previous pointer = /]
	MOVE A,Z
	PUSHJ P,OCTOUT
	OUTSTR [ASCIZ/
Current PPN = /]
	MOVS A,TNX
	PUSHJ P,PPNOUT
	OUTSTR [ASCIZ/, current pointer = /]
	MOVE A,1(Y)
	PUSHJ P,OCTOUT
	OUTSTR CRLF
	HALT CPOPJ

TWOSAM:	CAME B,VEEXT	;skip if filenames match
	JRST EXTOOO	;extensions are out of order
	OUTSTR [ASCIZ/Two consecutive filenames are same: /]
	PUSH P,A
	PUSH P,B
	PUSH P,C
	PUSH P,D
	MOVE A,VEFILE	;file name
	HLLZ B,VEEXT	;extension
	MOVS D,TNX	;PPN
	PUSHJ P,OUTFIL	;type filename
	OUTSTR CRLF
	POP P,D
	POP P,C
	POP P,B
	POP P,A
	popj p,		;for now, don't halt, fix these later.
;	HALT CPOPJ

EXTOOO:	OUTSTR [ASCIZ/Filename extensions are out of order; see B and VEEXT (and TNX).
/]
	HALT CPOPJ

VEROK:	OUTSTR [ASCIZ/Verify finished.
/]
	SKIPN MASCOP	;keep master copy typeout concise here
	OUTSTR [ASCIZ/Unless you've been told otherwise, you have a beautiful file.
/]
	MOVEI A,600000
	SHOWIT A,		;flush file status from wholine (don't erase)
	POPJ P,
                                                                                                                                                                                                                                                                                                                                        subttl fix magtape position. ; FIXPOS FIXP00 FIXP02 FIXP03 FIXSKP FIXNLP FIXP01 FIXPS0 Found FIXPS1 FIXPS2 FIXPS3 FIXPS4

COMMENT $
THIS ROUTINE IS USED TO MOVE THE MAGTAPE FROM SOME UNKNOWN
POSITION TO A KNOWN ONE.  THE POSITION DESIRED IS: 
	AT THE FRONT OF THE LAST MTFILE DUMPED
SUCESSFULLY.  THE NAME (OR OTHER DESCRIPTION) AT THE FRONT
OF THAT FILE IS KNOWN IN MEMSAV. OUR SCHEME IS TO INIT THE MTA WITH ONLY
ONE BUFFER. BACKSPACE 4 FILES (THAT OUGHT TO BE ENOUGH) AND
READ THE FIRST RECORD FROM EACH FILE UNTIL WE SEE WHAT WE WANT.
WHEN WE SEE WHAT WE WANT, WE BACKF AND SKIPF TO POSITION OURSELVES
AT THE FRONT OF THAT FILE.  NOTE THAT THE CALLER MAY WANT TO 
SKIPF PAST THIS FILE!

$

;Enter here to reposition the output tape.
FIXPOS:	PUSHJ P,MT2REL		;RELEASE THE output DRIVE
	MOVEI A,4		;normal number of MT files to backup in search
	MOVE B,MEMSAV+MT2FIL	;number of MT files on tape, through desired one
	PUSHJ P,FIXP00		;get tape positioned to file desired
	PUSHJ P,MTINIW		;re-open output channel WITH 3 BUFFERS
	POPJ P,

;Enter here to reposition the tape device MTDEV (already released).
;"A" holds number of MT files to search through for desired disk file.
;"B" has the number of files on the tape, up through the sought MT file.
;First, if tape is at load point, we skip forward (B - A) MT files; otherwise
;we backup over (A) MT files.  In either case, we then read up to (A) MT
;files looking for desired one.
;(Tape copy enters here to reposition the input tape.)
FIXP00:	MOVEM A,FIXCNT		;save nbr of MT files to back up and then search
	MOVEM B,FIXSEA		;save nbr of MT files from BOT to logical EOT
IFN DBGSW,<
	SKIPE DBGNTP
	POPJ P,			;IF NOT USING TAPE, GET OUT QUICK
>;IFN DBGSW

	MOVEI B,[ASCIZ/Repositioning the tape, we seek: /]
	PUSHJ P,STROUT
	MOVE A,MEMSAV+FFILE
	HLLZ B,MEMSAV+FFEXT
	MOVE D,MEMSAV+FUSER
repeat 0,<
	CAME D,['*HEAD*']	;IS SPECIAL DATA REMEMBERED?
	JRST FIXP02		;no
	MOVE A,D		;type out same way we will from RDHHAK
	MOVEI B,0		;no ext
	SETO D,			;impossible PPN
FIXP02:
>;repeat 0
	PUSHJ P,TYFIL
	HLRZ A,MEMSAV+RELABS	;get relative dump number
	JUMPE A,FIXP03		;don't type if zero (T dump)
	PUSHJ P,TEMDMP		;report rel dump nbr from MEMSAV+RELABS
FIXP03:	PUSHJ P,MINIT1		;INIT magtape for reading WITH ONE BUFFER
	PUSHJ P,MTABOT		;skip if input tape at load point (beg of tape)
	 JRST FIXNLP		;not at load point
	;The tape is at load point, so we don't back up at all, but we skip
	;forward until we're within FIXCNT MT files of the logical EOT.
	;Then we search FIXCNT files for the MT file of interest.
	MOVE A,FIXSEA		;number of files from BOT to logical EOT
	SUB A,FIXCNT		;minus the number of files to examine
	JUMPLE A,FIXPS0		;jump if FIXCNT was greater (or same), use it
FIXSKP:	PUSHJ P,MTASKF		;skip forward one MT file
	OUTCHR [">"]
	SOJG A,FIXSKP		;till we're within FIXCNT of log EOT
	JRST FIXPS0

FIXNLP:	PUSH P,FIXCNT		;want to use same count later
FIXP01:	PUSHJ P,MTABKF		;backup one MT file
	OUTCHR ["<"]
	SOSLE FIXCNT		;backed up enough?
	JRST FIXP01		;no, backup more
	PUSHJ P,MTABOT		;skip if already at beginning of tape
	 PUSHJ P,MTASKF		;not at BOT, advance past EOF we just backed past
	POP P,FIXCNT		;COUNT of MT files to read during search

FIXPS0:	TLO FL,RDHACK		;TURN ON HACK FLAG for handling headers/trailers
	PUSHJ P,RDFIL		;GET THE FILE NAME FROM THE TAPE.
	 JRST .-1		;saw a tape header/trailer -- can't happen with hack

	MOVEI B,[ASCIZ/
Found: /]
	PUSHJ P,STROUT
	MOVE A,FILINF+DDNAM
	HLLZ B,FILINF+DDEXT
	MOVE D,FILINF+DDPPN
	PUSHJ P,TYFIL		;type filename found
	PUSHJ P,TELDMP		;report rel dump nbr, if any
;	MOVEI B,CRLF
;	PUSHJ P,STROUT

;;	TLZN FL,RDHACK		;TURN OFF AND TEST FOR HACK.
;;	JRST FIXPS2		;WE HAVE BEEN HACKED!
	TLZ FL,RDHACK		;clear hacking, treat header just like file
	MOVE A,FILINF+DDNAM
	HLLZ B,FILINF+DDEXT
	MOVE D,FILINF+DDPPN
	CAMN A,MEMSAV+FFILE
	CAME D,MEMSAV+FUSER
	JRST FIXPS3		;THIS IS NOT WHAT WE WANTED.
	CAME B,MEMSAV+FFEXT
	JRST FIXPS3
	MOVE C,INVERS		;get tape format number
	CAIGE C,IOVER3		;skip unless copying an early tape
	JRST FIXPS1		;doesn't have rel dump number, don't check it
	HLRZ A,SRCDEV+LL3DMP-1	;get rel dump number from file on tape
	HLRZ B,MEMSAV+RELABS	;get relative dump number for current dump
	CAME A,B
	JRST FIXPS3		;not a match
FIXPS1:	OUTSTR [ASCIZ/.  That's it; tape repositioned correctly.
/]
;;	PUSHJ P,MTABKF		;BACK TO THE FRONT
;	PUSHJ P,MTABOT		;skip if at load point
;;	 PUSHJ P,MTASKF		;FORWARD TO THE FRONT OF FILE.
	PUSHJ P,MTABKR		;back over the record we just read
	PUSHJ P,MTAREL		;RELEASE MTA AND
	POPJ P,			;TAPE IS POSITIONED.

repeat 0,<
FIXPS2:	MOVE A,MEMSAV+FUSER	;HERE IF WE HAVE SPECIAL HACK (read a tape hdr/trlr)
	CAMN A,['*HEAD*']	;IS SPECIAL DATA REMEMBERED? (tape header?)
	JRST FIXPS1		;YES. WE HAVE RIGHT POSITION NOW.
>;repeat 0
	;HERE WE HAVE LOST.
FIXPS3:	SOSG FIXCNT		;HAVE WE DONE THIS ENOUGH?
	JRST FIXPS4		;YES.
;	PUSHJ P,MTABKF		;BACK TO IN FRONT OF THIS
;	PUSHJ P,MTASKF		;FORWARD TO FRONT OF THIS
	PUSHJ P,MTABKR		;back over the record we just read
	PUSHJ P,MTASKF		;FORWARD TO NEXT
	PUSHJ P,MTACLZ		;FORGET BUFFERS.
	GETSTS MTA,A
	TRZ A,IOEOF
	SETSTS MTA,(A)
	JRST FIXPS0		;TRY AGAIN.

FIXPS4:	OUTSTR [ASCIZ/

Unable to reposition the magtape correctly.
/]
;	PUSHJ P,MTABKF
;	PUSHJ P,MTASKF
;	PUSHJ P,MTAREL
;	JRST MTINIW		;INIT MTA for writing AND RETURN UP.
	JRST RESTAR		;Give up after this horrible error,
				; else might clobber a rewound tape!!
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               subttl get a tape number from dart.tap ; GETTAP GETTP1 PUTTAP PUTTP1 PUTTP2

GETTAP:	MOVE A,['DART  ']
	MOVSI B,'TAP'
	SETZB C,TAPBLK
	SETZM TAPBLK+1
	MOVE D,DUMPER
	LOOKUP DSKMSC,A
	 JRST GETTP1
	INPUT DSKMSC,[IOWD 2,TAPBLK
			0]
	CLOSE DSKMSC,
GETTP1:	MOVEI A,TAPBLK
	TRNN FL,PCLASS
	ADDI A,1
	AOS A,(A)		;advance to next tape number
	MOVEM A,TAPNO		;SAVE TAPE NUMBER
	MOVEM A,MEMSAV+TAPNUM	;SAVE..
	POPJ P,

PUTTAP:	MOVE A,['DART  ']
	MOVSI B,'TAP'
	SETZB C,TAPBLK
	SETZM TAPBLK+1
	MOVE D,DUMPER
	LOOKUP DSKMSC,A
	 JRST PUTTP1
	INPUT DSKMSC,[IOWD 2,TAPBLK
			0]
	CLOSE DSKMSC,
PUTTP1:	MOVEI A,TAPBLK
	TRNN FL,PCLASS
	ADDI A,1
	MOVE B,TAPNO		;GET TAPE NUMBER
	MOVEM B,(A)
	MOVE A,['DART  ']
	MOVSI B,'TAP'
	MOVEI C,0
	MOVE D,DUMPER
	ENTER DSKMSC,A
	 JRST PUTTP2
	OUTPUT DSKMSC,[IOWD 2,TAPBLK
			0]
	CLOSE DSKMSC,
	POPJ P,

PUTTP2:	OUTSTR [ASCIZ/ENTER to update DART.TAP has failed.
/]
	MOVEI A,10
	SLEEP A,
	JRST PUTTP1		;TRY AGAIN.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    subttl tell operator what tape to mount. ; DOMINP DOMOUNT DOMOU0 DOMOUH ONONEW TELOPR TELOP0 TELOP2 TELMLS TELML2 telop4 TELOP1 TELOP5 TELOP6 TELOP8 TELOP9 NOMTA9 TELP10 TELWCK TELWC1 TELWC2 GETANS GETAN1 GETA11 GETAN5 GETAN2 GETAN3 GETAN4 OPRZER OPRERR

;Tell operator to mount an input tape, init device
DOMINP:	HRROS (P)		;set flag for mounting input tape
	JRST DOMOU0

;Tell operator to mount an output tape, init device, write tape header if at BOT.
DOMOUNT:HRRZS (P)		;set flag for mounting output tape
DOMOU0:	SKIPN PICKON		;PICKUP IN PROGRESS?
	JRST TELOPR		;NO DO THE NORMAL THINGG
	CLRBFI			;FLUSH TYPE AHEAD
IFN DBGSW,<
	SKIPE DBGNTP		;SKIP IF REALLY USING TAPE
	OUTSTR [ASCIZ/(PRETEND) /]
>;IFN DBGSW
	OUTSTR [ASCIZ/Verify that tape number /]
	PUSHJ P,REELM0
	MOVE A,TAPNAM
	PUSHJ P,SIXOUT
	OUTSTR [ASCIZ/ is mounted and type GO<return>: /]
	PUSHJ P,GETANS
	 JRST OPRERR		;error return
	 JRST OPRERR		;tape number typed return
	SKIPGE (P)		;input or output tape?
	JRST MTINIR		;input tape mounted, open for reading only
	PUSHJ P,MTINIW		;Init magtape for writing
IFN DBGSW,<
	SKIPE DBGNTP		;SKIP IF REALLY USING TAPE
	POPJ P,			;ELSE GET OUT EARLY
>;IFN DBGSW
	PUSHJ P,MT2NOP		;noop to get status
	TLO FL,MCLOSE
	SKIPN MASCOP		;master copy allows output tape to be rewound
	STATO MTA2,IOBOT	;FRONT OF TAPE?
	POPJ P,			;NO. DONE.
	;Here if tape is at load point -- but maybe it shouldn't be!!
	HRRZ A,MEMSAV+CHKNUM	;GET CHECKPOINT CODE.
	SKIPL TABPIK(A)		;skip if OK to be starting new tape w/this code
	JRST ONONEW		;tape needs to be approximately positioned
;	PUSHJ P,TELWCK		;Make sure not write locked if rewound
DOMOUH:	PUSHJ P,TAPHED		;write a tape header
	MOVE A,['*HEAD*']
;;	MOVEM A,MEMSAV+FUSER
	MOVEM A,MEMSAV+FFILE	;set up "filename" we'll see if FIXPOS reads hdr
	MOVE A,LASTTD
	HLLZM A,MEMSAV+FFEXT	;get time and date we put into ext word of header
	HRLZ A,CLASS
	HRR A,TAPNO
	MOVEM A,MEMSAV+FUSER	;use class,,tapno as put into "PPN" word of header
;;	JRST TAPHED		;WRITE HEADER
	POPJ P,

ONONEW:	OUTSTR [ASCIZ/Tape at load point but needs to be pre-positioned to approximate position for
mid-tape pickup.  (Maybe use TLIST to position tape to where dump left off.)/]
	JRST RESTAR

;Here when mounting a new tape (no pickup in progress).
TELOPR:	MOVE A,TAPNO		;GET TAPE NUMBER
	TRNN FL,PCLASS		;T-DUMP?
	CAIE A,NTTAPE+1		;YES. ASKING TO MOUNT TMAX+1?
	JRST TELOP0
DEFINE TELOPM (NNN) <
	OUTSTR [ASCIZ/(Finished with NNN tape series. Starting over.)
/]
>;TELOPM
	RADIX 5+5
	TELOPM(\NTTAPE)
	RADIX 4+4
	MOVEI A,1
	MOVEM A,TAPNO		;SET T1 INSTEAD OF T32
TELOP0:	PUSHJ P,REELM0		;FORM THE TAPE FILE AND REEL NAME
	CLRBFI			;FLUSH TYPE AHEAD.
IFN STANSW!IRCPPN,<
	SETO A,
	BEEP A,			;Wake up the operator, if any
>;IFN STANSW!IRCPPN
IFN DBGSW,<
	SKIPE DBGNTP		;SKIP IF REALLY USING TAPE
	OUTSTR [ASCIZ/(PRETEND) /]
>;IFN DBGSW
	OUTSTR [ASCIZ/Mount tape number /]
	MOVE A,TAPNAM
	PUSHJ P,SIXOUT		;TYPE IN SIXBIT
	MOVEI A,[ASCIZ\ and type GO<return>: \] ;assume output tape
	SKIPGE (P)		;skip if output -- new tape can't be lost!
	MOVEI A,[ASCIZ\ and type GO<return> (or LOST<return> for lost tape): \]
	SKIPN MASCOP		;skip if master tape copy
	MOVEI A,[ASCIZ\ and type GO<return>, or type P/T<num> <return>: \]
	OUTSTR (A)
IFN FTDBMC,<
printx DOMOUNT assumes GO for new input tapes, during debugging.
    skipge (p)              ;skip if output tape
    jrst telop4             ;input, pretend GO already typed
>;IFN FTDBMC
	INCHWL A		;read first char of response
	SKIPGE (P)		;skip if output -- new tape can't be lost!
	SKIPN MASCOP
	JRST TELOP2		;not master copy
	CAIE A,"L"
	CAIN A,"l"
	JRST TELMLS		;scan LOST from operator
TELOP2:	PUSHJ P,GETA11
	 JRST OPRERR		;error return
	 JRST TELOP1		;tape number typed return
	JRST TELOP5		;GO typed return

;Here for master copy if operator is saying the tape is LOST
;Read and verify rest of response.  See if tape is in our list of lost tapes.
TELMLS:	INCHWL A
	ANDI A,137
	CAIE A,"O"
	JRST OPRERR
	INCHWL A
	ANDI A,137
	CAIE A,"S"
	JRST OPRERR
	INCHWL A
	ANDI A,137
	CAIE A,"T"
	JRST OPRERR
	INCHWL A
	CAIE A,15
	JRST OPRERR
	INCHWL A
	CAIE A,12
	JRST OPRERR
	MOVE A,TAPNO
;Here we have compiled in a list of all lost SAIL P tapes.
	CAIN A,=347
	JRST TELML2		;OK, we expected this tape to be lost
	CAIE A,=1217
	CAIN A,=1273
	JRST TELML2		;OK, we expected this tape to be lost
	CAIE A,=1532
	CAIN A,=1536
	JRST TELML2		;OK, we expected this tape to be lost
	OUTSTR [ASCIZ/
**** That tape wasn't lost at the time of the inventory!
**** If you really can't find it, then you'll have to find a wizard instead.
**** We cannot proceed without that tape!

/]
	JRST TELOPR		;we ask for same tape again

TELML2:	AOS TAPNO		;skip the expectedly lost tape
	AOS MEMSAV+MCITAP
	AOS PREQTP
	OUTSTR [ASCIZ/
OK, we'll skip that tape FOREVER.  (If it isn't really lost,
CALL out of DART now and give the MCOPY command over again.)

/]
	PUSHJ P,BRANEW		;get brand of next tape
	JRST TELOPR		;and ask for next tape

IFN FTDBMC,<
telop4:
    outstr crlf
    jrst telop5
>;IFN FTDBMC

;Here if operator typed in a tape number
TELOP1:	SKIPE MASCOP
	JRST OPRERR		;can't give explicit tape number in master copy
	JUMPE B,OPRZER		;special test for zero tape #
	MOVEM B,TAPNO
	MOVEM B,MEMSAV+TAPNUM
TELOP5:	PUSHJ P,REELM0
	OUTSTR [ASCIZ/Using tape number /]
	MOVE A,TAPNAM
	PUSHJ P,SIXOUT
	SKIPL (P)		;skip if new input tape, don't list dump nbrs
	SKIPN MASCOP		;skip if master copy
	JRST TELOP6		;not master tape copy
	OUTCHR ["/"]		;indicate rel dmp nbr
	HLRZ A,MEMSAV+RELABS	;get rel dmp nbr (already reset if new tape)
	PUSHJ P,DECOUT		;type it
	OUTSTR [ASCIZ/    Dump set /]
	HRRZ A,MEMSAV+RELABS	;get dump set nbr
	PUSHJ P,DECOUT		;type it
TELOP6:	OUTSTR CRLF
	CLRBFI			;DEPT REDUNDANCY DEPT
	SKIPGE (P)		;input or output tape?
	JRST MTINIR		;input tape mounted, just go init the device
	SKIPG B,MEMSAV+TTCNT	;ARE THERE ANY TAPE TERMS ALREADY?
	JRST TELOP8		;NONE. BUILD ONE.
	HRRZ A,MEMSAV+TTBUF-1(B) ;GET THE LAST TERM.
	CAMN A,TAPNO		;Is it the same as new tape num?
	JRST [	OUTSTR [ASCIZ\Are you SURE that's correct? (type GO or P/T<num>): \]
		PUSHJ P,GETANS
		 JRST OPRERR	;error return
		 JRST TELOP1	;tape number typed return
		JRST TELOP9]	;GO typed return - no new tape term - weird
	ADDI A,1
	CAME A,TAPNO		;IS THIS THE EXPECTED NUMBER?
	JRST TELOP8		;NO. WE BUILD A NEW TERM NOW.
	HRRM A,MEMSAV+TTBUF-1(B) ;STORE INCREMENTED NUMBER
	JRST TELOP9

TELOP8:	AOS B,MEMSAV+TTCNT	;INCREMENT THE COUNT.
	CAILE B,LTTBUF		;room for another term?
	JRST TELP10		;OOPS, no
	HRLZ A,TAPNO
	HRR A,TAPNO
	MOVEM A,MEMSAV+TTBUF-1(B)
TELOP9:	PUSHJ P,MTINIW		;INITIALIZE THE MAGTAPE for writing
IFN DBGSW,<
	SKIPE DBGNTP		;SKIP IF REALLY USING TAPE
	JRST NOMTA9		;ELSE SKIP TAPE OPERATIONS
>;IFN DBGSW
	PUSHJ P,MT2REW		;MAKE SURE IT IS REWOUND
	PUSHJ P,MT2FOO		;reset output footage test counts
	PUSHJ P,MT2NOP		;WAIT FOR REWIND TO FINISH
	GETSTS MTA2,A
	TRZ A,IOIMPM+IOTEND	;CLEAR SOME BITS
	SETSTS MTA2,(A)		;SET STATUS.
;	PUSHJ P,TELWCK		;Make sure not write locked if rewound
NOMTA9:	TLO FL,MCLOSE		;WE ARE AT BEGINNING OF AN MT FILE
;;	MOVE A,['*HEAD*']	;PICKUP ODDNESS
;;	MOVEM A,MEMSAV+FUSER	;SAVE IN SPECIAL PLACE.
;;	JRST TAPHED		;MAKE A TAPE HEADER.
	JRST DOMOUH		;write header and set up MEMSAV for it

TELP10:	OUTSTR [ASCIZ/%%% Tape term block overflow.  No place to store tape number.
/]
	HALT TELOPR

REPEAT 0,< ;This was a great idea, but you have to try and write on the
	   ;silly tape before the system will let you know it's write locked!

TELWCK:				; Check tape for write lock if rewound: make sure operator
				;  puts in a write ring, and then rewind for good measure.
				; If not rewound (not at front of tape), just return.
	PUSHJ P,MT3NOP		;NO-OP so status will be available
	GETSTS MTA2,A
	TRNN A,IOBOT		;Front of tape?
	 POPJ P,		;No, just return
TELWC1:	TRNE A,IOTEND		;Not IOTEND
	 POPJ P,
	TRNN A,IOIMPM		;and IOIMPM implies write locked
	 POPJ P,
	CLRBFI
TELWC2:	OUTSTR [ASCIZ/This tape is write-locked!  If you are SURE you want to continue
and write on the tape, put the write ring in and type GO<return>: /]
	PUSHJ P,GETANS
	 JRST TELWC2		;error return
	 JRST TELWC2		;tape number typed return
	PUSHJ P,MT2REW		;Make sure it is rewound
	PUSHJ P,MT2NOP		;Wait for rewind, make status avail.
	GETSTS MTA2,A
	JRST TELWC1
>; REPEAT 0

GETANS:
GETAN1:	INCHWL A		;GET A CHARACTER.
GETA11:	CAIN A,15		;TURKEY ENTERS HERE WITH CHAR IN A
	JRST GETAN1
	CAIN A,12
	JRST CPOPJ		;ERROR RET - JUST CR TYPED
	CAIE A,"G"+40
	CAIN A,"G"
	JRST [	INCHWL A
		CAIE A,"O"+40
		CAIN A,"O"
		CAIA
		JRST CPOPJ
		INCHWL A
		CAIE A,15
		JRST CPOPJ
		INCHWL A
		CAIE A,12
		JRST CPOPJ
		JRST CPOPJ2]	;"GO" RETURN
	MOVEI B,0		;ZERO THE NUMBER OF THE OPR'S TAPE.
	CAIE A,"P"+40
	CAIN A,"P"
	JRST [	TLNE FL,L.TURK	;TURKEY COMMAND?
		JRST GETAN5	;YES, OK (TURN OFF L.TURK FOR P CLASS)
		TRNE FL,PCLASS
		JRST GETAN2
		JRST CPOPJ]
	CAIE A,"T"
	CAIN A,"T"+40
	JRST [	TLNE FL,L.TURK	;TURKEY COMMAND?
		JRST GETAN2	;YES, OK (LEAVE L.TURK SET FOR T CLASS)
		TRNN FL,PCLASS
		JRST GETAN2
		JRST CPOPJ]
	JRST CPOPJ		;ANYTHING ELSE IS AN ERROR

GETAN5:	TLZ FL,L.TURK		;FLAG P CLASS (RECYCLE TURK FLAG)
GETAN2:	INCHWL A		;EXPECT A DIGIT
GETAN3:	CAIL A,"0"
	CAILE A,"9"
	JRST GETAN4
	IMULI B,12
	ADDI B,-"0"(A)
	JRST GETAN2
GETAN4:	CAIN A,15
	JRST GETAN2
	CAIE A,12
	JRST CPOPJ
	JRST CPOPJ1		;TAPE NUMBER TYPED RETURN

OPRZER:	OUTSTR [ASCIZ/Tape number zero illegal !!!
/]
	CAIA
OPRERR:	OUTSTR [ASCIZ/Illegal response.
/]
	CLRBFI
	JRST DOMOU0		;let operator try again
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         subttl	tell operator what tape to mount for mrestore	 ; DOMT0B DOMT0 DOMT0A DOM0G2 DOMALT DOMT0G DOM0G1 DOMT1 DOMT2 DOMT3 DOMT4

;CALL WITH TAPNO SET UP TO THE NEXT TAPE NEEDED FOR THE MRESTORE
;	PUSHJ P,DOMT0
;	<HERE IF OPERATOR WANT TO SKIP THAT TAPE.  MRTPNO SET POSSIBLY>
;	<OPERATOR COMPLIED WITH REQUEST>


DOMT0B:
	OUTSTR	[ASCIZ/Illegal tape number: need "P", "T", "X", or crlf
/]
DOMT0:	CLRBFI			;FLUSH TYPE AHEAD
	SETZM	GOTALT			;NO ALTMODE TYPED YET
	SETZM	MRTPNO			;NO OPR INSTRUCTION ABOUT WHAT TAPE TO USE
	OUTSTR	[ASCIZ/Mount tape number /]
	MOVE	A,TAPNO
	MOVEM	A,STAPNO		;SAVE ORIGINAL FORM FOR DOMT4
	PUSHJ	P,REELMX
	MOVE	A,TAPNAM
	PUSHJ	P,SIXOUT
	OUTSTR	[ASCIZ/ and type return,
or type X to skip this tape,
or type the tape number that you want to restore next: /]
	MOVEI	B,0			;COUNT IF X IS SEEN
DOMT0A:	INCHWL A
	CAIE	A,"X"
	CAIN	A,"X"+40
	AOJA	B,DOMT0A
	CAIE A,"G"
	CAIN A,"G"+40
	JRST DOMT0G			;"GO" SAME AS CR
	CAIE	A,"P"
	CAIN	A,"P"+40
	JRST	DOMT1
	CAIE	A,"T"
	CAIN	A,"T"+40
	JRST	DOMT2
	CAIN	A,15
	JRST	DOMT0A
	CAIN	A,ALTMOD		;ALTMODE MEANS USE ALTERNATE MODE!
	JRST	DOMALT			;OK, PRETEND LF, BUT SET FLAG
	CAIE	A,12
	JRST	DOMT0B
	JUMPN	B,CPOPJ
DOM0G2:	AOS	(P)			;FORCE SKIP RETURN
	JRST	MTINIR			;INIT MTA for reading AND RETURN

DOMALT:	SETOM	GOTALT			;ALTERNATE MODE (FOR MRESTORE)
	OUTSTR	CRLF			;SINCE HE TYPED ALTMODE
	MOVEI	A,12			;FAKE LF IN CASE SOMEONE CARES
	JUMPE	B,DOM0G2		;SUCCESS RETURN IF NO "X" TYPED
	POPJ	P,			;"X"

DOMT0G:	INCHWL A			;GOT A G, LOOK FOR O
	CAIE A,"O"
	CAIN A,"O"+40
DOM0G1:	INCHSL A
	 JRST DOMT0B			;ILLEGAL WITHOUT O
	CAIN A,15
	JRST DOM0G1			;SKIP CR
	CAIE A,12
	JRST DOMT0B			;SOMETHING BESIDES CRLF AFTER THE GO
	JRST DOM0G2			;GO SAME AS BARE CRLF

DOMT1:	TRO FL,PCLASS
	JRST DOMT3

DOMT2:	TRZ FL,PCLASS
DOMT3:	INCHWL A			;EXPECT A DIGIT
	CAIL	A,"0"
	CAILE	A,"9"
	JRST	DOMT4
	IMULI	B,12
	ADDI	B,-"0"(A)
	JRST	DOMT3

DOMT4:	CAIN	A,15
	JRST	DOMT3			;SKIP CR
	CAIE	A,12
	JRST	DOMT0B			;ANYTHING ELSE IS ILLEGAL
	TRZN	FL,PCLASS
	TRO	B,400000		;SET BIT 18 IF T CLASS TAPE
	CAMN	B,STAPNO		;IS ARGUMENT SAME AS WHAT WE WANTED?
	JRST	DOMT0			;YES.  WELL, TELL HIM TO TYPE RETURN!
	MOVEM	B,MRTPNO		;SET FLAG FOR CALLER
	POPJ	P,			;TELL THEM UP THERE WE HAVE OTHER IDEAS.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   subttl	archive command	 ; D A ARCHIVE DNEED ARC.RT ANEED ARC.RD DNEED ARC.TS ANEED ARCHIV ARCH0 ARCCOM ARC0.0 ARC.RT ARC.RD ARC.RL ARC.TS ARC.TF ARCTF1 ARCTF2 LSORT SORTUM SORTON SORTLN NSORT INISRT SRTIN SRTNXT SRTOUT SRTOUL ARC.DF ARCDF0 ARCDF1 ARCDF2 ARC.M ARC.M0 ARC.M1 ARC.M2 ARCM2A A.MAF A.MAF0 A.MAF1 A.MDF A.MDF2 A.MDF1 ARCTS1 ARCDRD ARCD00 ARCDR1 ARCDR2 ARCDR0 ARCDR3 AR.DR3 ARCDR4 ARCDR5 ARCDR6 ARCDR7 AIDXBW AIDXBG AIDXND AIDXFR AIDXIN AIDXWT SKPADX SKPAD1 RDAPP1 RDAPPN ARCB0 ARCBX ARCB1 ARCB2 ARCB3

;ARCHIVE MERGES DART.DAT AND DART.ARC, PRODUCING A BIGGER DART.ARC
;AND A SMALLER DART.DAT WHICH CONTAINS ONLY THE T-DUMP DATA.
;THE OBJECT IS TO REDUCE THE SIZE OF DART.DAT WHICH IS FREQUENTLY
;REFERENCED DURING THE DUMP PROCESS.

;CHANNEL	FILE		I/O	BUFFER	GET(PUT) ROUTINE

;UFD		DART.DAT 	I(B)	UFDBUF	UFDRD	(SKIPS UNLESS EOF)
;MEM		DART.ARC	I(D)	MEMBLK	TNREAD	(SKIPS UNLESS EOF)
;FILE		DART.DAT 	O(B)	FOBUF	DFWRTX
;DSKMSC		DART.ARC 	O(D)	REELBF	DMPUT, DMINI

COMMENT $
	ARCHIVE DIAGRAM	(ALMOST THE SAME AS MERGE, ELSEWHERE IN THIS PROGRAM.)
	D=DART.DAT FILE INPUT
	A=DART.ARC FILE INPUT

ARCHIVE:DEOF_AEOF_FALSE;
	DNEED_ANEED_TRUE;
ARC.RT:	IF AEOFANEED THEN READ ANAME;
	IF EOF ON A THEN AEOF_TRUE;
	ANEED_FALSE;
ARC.RD:	IF DEOFDNEED THEN READ DNAME;
	IF EOF ON D THEN DEOF_TRUE;
	DNEED_FALSE;
ARC.TS:	IF DEOFAEOF THEN DONE;
	IF DEOF THEN SPLIT ADATA; ANEED_TRUE; GO TO RA;
	IF AEOF THEN SPLIT DDATA; DNEED_TRUE; GO TO RD;
	IF ANAME > DNAME THEN SPLIT DDATA; DNEED_TRUE; GO TO RD;
	IF ANAME < DNAME THEN WRITE ADATA; ANEED_TRUE; GO TO RA;
	MERGE DDATA AND ADATA AND SPLIT BOTH;
	ANEED_DNEED_TRUE;
 	GO TO RT;
$

ARCHIV:	SETZM	RSTDEV			;INITIALIZE DEVICE NAME
IFN IRCPPN,<
	HRROI A,2
	GETTAB A,
>;IFN IRCPPN
	GETPPN	A,			;IS THIS THE REAL DUMPER?
IFE STANSW,<
	 JFCL
>;IFE STANSW
	CAME	A,DUMPER
IFN FTCOPY,<
	CAMN A,['  1 ME']
	CAIA
	CAMN A,['  1JJW']
	CAIA
>;IFN FTCOPY
	JRST	NOPRV			;LOSER.
	SETOM	ARCCMD			;suppress retrieval updates in DMFRC
ARCH0:	MOVE	A,RSTDEV		;GET THE LAST NAME USED
IFE STANSW,<
	SYSSTR	A,			;GET NEXT STRUCTURE NAME
>;IFE STANSW
	MOVSI	A,'DSK'			;USE DSK IF NO STRUCTURES
	CAMN	A,RSTDEV		;DIFFERENT FROM LAST NAME?
	POPJ	P,			;NO. RETURN
	JUMPE A,CPOPJ			;REG IS CONFUSED ABOUT SYSSTR
	MOVEM	A,RSTDEV		;SAVE STRUCTURE NAME
	PUSH	P,.JBFF
	PUSHJ	P,ARCCOM		;DO ARCHIVE FOR ONE STRUCTURE
	POP	P,.JBFF
	JRST	ARCH0

ARCCOM:
;OPEN 4 DISK CHANNELS
	MOVEI	A,10
	MOVE	B,RSTDEV
	MOVSI	C,FOBUF
	OPEN	FILE,A		;DART.DAT OUTPUT
	PUSHJ	P,NODEV
	OUTBUF	FILE,NBUFS	;SOME BUFFERS

	MOVEI	C,UFDBUF
	OPEN	UFD,A		;DART.DAT INPUT
	PUSHJ	P,NODEV
	INBUF	UFD,NBUFS	;SOME BUFFERS

	MOVEI	A,17
	MOVEI	C,0
	OPEN	MEM,A		;DART.ARC INPUT, dump mode
	PUSHJ	P,NODEV

	OPEN	DSKMSC,A	;DART.ARC OUTPUT, dump mode
	PUSHJ	P,NODEV
	SETOM	DSKMM3		;SET BINARY MODE FOR DMINI
	PUSHJ	P,DMINI		;INITIALIZE FOR OUTPUT

;SET FLAGS (NEED FLAGS ARE 1 FOR no NEED!)
	TLZ	FL,AEOF!DEOF!ANEED!DNEED
	MOVE	A,['DART  ']
	MOVSI	B,'DAT'
	MOVEI	C,0
	MOVE	D,DUMPER
	LOOKUP	UFD,A		;SEEK DART.DAT FILE
	JRST	ARCB0

	MOVSI	B,'DAT'
	MOVEI	C,0
	MOVE	D,DUMPER
	ENTER	FILE,A		;ENTER NEW COPY
	JRST	ARCB2

	MOVSI	B,'ARC'
	MOVEI	C,0
	MOVE	D,DUMPER
IFN STANSW,<
	LOOKUP	MEM,A		;SEEK DART.ARC
>;IFN STANSW
IFE STANSW,<
	MOVEM A,LKBLK+.RBNAM
	MOVEM B,LKBLK+.RBEXT
	MOVEM D,LKBLK+.RBPPN
	LOOKUP MEM,LKBLK
>;IFE STANSW
	TLOA	FL,AEOF		;SET EOF ON INPUT AND SKIP. (ASSUME NON-EX FILE)
	JRST	ARC0.0		;FILE EXISTS
	TRNE	B,-1		;MAKE SURE LOOKUP CODE = 0, NON-EX FILE
	JRST	ARCB1		;WE LOSE SOMEHOW.
IFN STANSW,<
	MOVEI	D,0
>;IFN STANSW
IFE STANSW,<
	TDZA D,D
>;IFE STANSW
ARC0.0:
IFE STANSW,<
	MOVN D,LKBLK+.RBSIZ
	MOVEM D,MEMWC		;TDZA SKIPS TO HERE
>;IFE STANSW
IFN STANSW,<
	MOVSM	D,MEMWC		;SAVE -WC OF ARC FILE.
>;IFN STANSW
	SETZM	MEMWC2		;CONTROL CELLS FOR TNREAD
	MOVSI	B,'ARC'
	MOVEI	C,0
	MOVE	D,DUMPER
	ENTER	DSKMSC,A
	JRST	ARCB3		;ENTER FAILED.

	PUSHJ	P,SKPIDX	;SKIP FIRST INDEX BLOCK ON DAT FILE.
	PUSHJ	P,UIDXIN	;INITIALIZE FOR  INDEX OUTPUT ON DAT FILE
	PUSHJ	P,SKPADX	;SKIP FIRST INDEX BLOCK ON ARC FILE
	PUSHJ	P,AIDXIN	;INITIALIZE FOR INDE OUTPUT ON DAT FILE.

ARC.RT:	TLNE	FL,AEOF!ANEED	;NEED ARC INPUT AND NOT EOF?
	JRST	ARC.RD		;NO. EITHER WE HAVE TNAME OR EOF
	PUSHJ	P,RDAPPN	;READ TNAME. - SKIPPING INDEX
	TLO	FL,AEOF		;EOF OK HERE.
	TLO	FL,ANEED	;NO NEED FOR ANOTHER TNAME
	MOVEM	A,TNAME		;SAVE PPN
	JUMPN	A,ARC.RD	;JUMP IF REAL PPN
	TLO	FL,AEOF		;0 MEANS EOF, EVEN IF THERE'S MORE DATA!

ARC.RD:	TLNE	FL,DEOF!DNEED
	JRST	ARC.TS		;WE HAVE DNAME ALREADY. (OR EOF)
	PUSHJ	P,RDIPPN	;READ DNAME - IGNORING INDEX BLOCK.
	TLO	FL,DEOF		;EOF.
	TLO	FL,DNEED	;DNAME IS LOADED.
	MOVEM	A,DNAME	
	MOVEM	A,DNAMEO	;DNAME FOR DOUTPUT (DAT FILE)
;This code was added to allow reading a .ARC file as a .DAT file.
;.ARC files end with extra zeroes.  This skips those words, but checks for
;any nonzero words after and EOF-implying zero. -- ME 5/15/90
	JUMPN A,ARC.TS		;JUMP IF REAL PPN
	TLO FL,DEOF		;0 MEANS EOF, EVEN IF THERE'S MORE DATA!
ARC.RL:	PUSHJ P,UFDRD		;next datum please
	 JRST ARC.TS		;real EOF, thank goodness
	JUMPE A,ARC.RL		;make sure we only see 0's till EOF
	OUTSTR [ASCIZ /%%% Unexpected non-zero data follows a 0 that implied EOF in DART.DAT!
%%% This means DART.DAT was corrupted!  Can't continue.  Find a wizard.
/]
	JRST 4,.

ARC.TS:	TLC	FL,DEOF!AEOF
	TLCN	FL,DEOF!AEOF
	JRST	ARCTS1		;EOF ON BOTH INPUT FILES. WE'RE DONE.
	TLNE	FL,DEOF		;EOF ON DART.DAT?
	JRST	ARC.TF		;YES. GO FLUSH ARC (T) DATA TO OUTPUT.
	TLNE	FL,AEOF		;EOF ON ARC FILE?
	JRST	ARC.DF		;YES. GO FLUSH DAT DATA TO OUTPUT.
	MOVE	A,DNAME
	CAMN	A,TNAME
	JRST	ARC.M		;HERE WE HAVE TO MERGE. (DIFFICULT)
	PUSHJ	P,UFDCNV	;CONVERT USER NAME IN FUNNY WAY.
	MOVEM	A,DNX		;SAVE FUNNY VERSION.
	MOVE	A,TNAME
	PUSHJ	P,UFDCNV
	MOVEM	A,TNX
	PUSHJ	P,PPNCMP	;COMPARE T AND D
	JRST	ARC.DF		;D<T (FLUSH D)
				;T>D (FLUSH T) (FALL THROUGH)

;HERE TO FLUSH ARC FILE. EITHER DEOF OR TNAME<DNAME.  FLUSH CURRENT UFD.
ARC.TF:	MOVE	A,TNAME		;FLUSH ARC DATA TO NEW ARC FILE.
	PUSHJ	P,AIDXBG	;ADD PPN TO ARC INDEX
	PUSHJ	P,DMPUTX	;WRITE PPN
	TLZ	FL,ANEED	;WILL NEED MORE DATA AFTER WE'RE DONE HERE.
ARCTF1:	PUSHJ	P,TNRD1		;READ A FILE NAME (EOF IS ILLEGAL)
	PUSHJ	P,DMPUTX	;WRITE FILE NAME
	JUMPE	A,ARC.RT	;END OF THIS UFD ENTRY. GET NEXT UFD NAME.
	PUSHJ	P,TNRD1		;READ DATA (EXTENSION)
	PUSHJ	P,DMPUTX	;WRITE IT.
	MOVEI	B,(A)		;GET THE COUNT OF THE NUMBER OF ENTRIES.
IFN SRTENT,<
	PUSHJ P,INISRT		;initial sorting array
	PUSH P,C
	PUSH P,D
	PUSH P,W
	PUSH P,X
>;IFN SRTENT
ARCTF2:	PUSHJ	P,TNRD1		;READ DATA ENTRY
IFE SRTENT,<
	PUSHJ	P,DMPUTX	;WRITE DATA
>;IFE SRTENT
IFN SRTENT,<
	PUSHJ P,SRTIN		;add new datum to sorting array
>;IFN SRTENT
	SOJG	B,ARCTF2	;LOOP THROUGH DATA PORTION.
IFN SRTENT,<
	PUSHJ P,SRTOUT		;output the data in sorted order
	 JRST DMPUTX		;pushj to here for each datum to output it
	POP P,X
	POP P,W
	POP P,D
	POP P,C
>;IFN SRTENT
	JRST	ARCTF1		;SEEK NEXT FILE NAME.

IFN SRTENT,<	;sort dump dates of .ARC files as we do the archive cmd

printx You're compiling with SRTENT on, to Sort dump data by date dumped in ARCHIVE.

LSORT__=1000			;max number of dumps we expect a file to be in
SORTUM:	BLOCK LSORT		;dump data for given file
SORTON:	BLOCK LSORT		;data by which we are sorting (date)
SORTLN:	BLOCK LSORT		;link to next sorted entry
NSORT:	0			;number of entries sorted in so far

INISRT:	SETZM NSORT		;no entries in sorted array yet
	SETOM SORTON		;metric of terminator entry: beyond possible values
	SETZM SORTLN		;header initially points to itself
	CAIG B,LSORT		;got enough room to sort this much data?
	POPJ P,			;yes
	PUSH P,A		;NO!
	PUSH P,B
	OUTSTR [ASCIZ/
Not enough room to sort this many file entries: /]
	MOVE A,B
	PUSHJ P,DECOUT
	OUTSTR [ASCIZ/Increase LSORT to at least that much and recompile.
/]
	POP P,B
	POP P,A
	HALT .

;Insert contents of A into sorted list.  
SRTIN:	LDB C,[POINT 15,A,35]	;low 15 bits contain the date
	MOVEI W,0		;point to header of list
SRTNXT:	MOVE D,W		;remember previous ptr
	MOVE W,SORTLN(W)	;get next entry in list
	CAMG C,SORTON(W)	;do we belong here?
	JRST SRTNXT		;no
	AOS X,NSORT		;yes, get index of new entry
	MOVEM X,SORTLN(D)	;make previous entry point to new
	MOVEM W,SORTLN(X)	;make new point to next
	MOVEM C,SORTON(X)	;save metric of new entry
	MOVEM A,SORTUM(X)	;save datum of new entry
	POPJ P,

;Output sorted list.
SRTOUT:	MOVEI D,0		;point to header
SRTOUL:	SKIPN D,SORTLN(D)	;next entry
	JRST CPOPJ1		;end of list
	MOVE A,SORTUM(D)	;get datum
	PUSHJ P,@(P)		;output the datum
	JRST SRTOUL		;loop for next
	
>;IFN SRTENT

;HERE TO FLUSH DAT FILE. EITHER AEOF, OR DDATA<TDATA.  FLUSH CURRENT UFD.
ARC.DF:	PUSHJ	P,ARCDRD	;YES. HERE WE COPY FROM DAT FILE.
	SKIPN	MMNAM		;DONE WITH THIS UFD?
	JRST	ARCDF2		;YES. TIME TO SEE ANOTHER UFD
	HRRZ	W,MMEXT		;IS THERE ANY DATA TO WRITE?
	JUMPE	W,ARC.DF	;NO.
	MOVEI	A,0
	EXCH	A,DNAME		;GET THE UFD NAME
	JUMPE	A,ARCDF0	;JUMP IF UFD NAME HAS BEEN WRITTEN ALREADY. (ARC)
	PUSHJ	P,AIDXBG	;ADD PPN TO ARC INDEX
	PUSHJ	P,DMPUTX	;WRITE UFD NAME.
ARCDF0:	MOVE	A,MMNAM		;WRITE FILE NAME, EXT AND COUNT.
	PUSHJ	P,DMPUTX
	MOVE	A,MMEXT
	PUSHJ	P,DMPUTX
	MOVE	B,.JBFF
ARCDF1:	MOVE	A,(B)		;LOOP WRITING DATA.
	PUSHJ	P,DMPUTX
	ADDI	B,1
	SOJG	W,ARCDF1
	JRST	ARC.DF		;GET NEXT FILE IN UFD.

ARCDF2:	TLZ	FL,DNEED	;WE SHALL NEED MORE DATA NEXT.
	SKIPN	A,DNAME		;DID WE WRITE THE UFD NAME?
	PUSHJ	P,DMPUTX	;YES. SO WE WRITE ZERO NOW TO STOP UFD ENTRY.
	JRST	ARC.RD		;NOW, READ MORE DATA.


;HERE TNAME=DNAME.  WE HAVE TO (ICK) MERGE.
ARC.M:	TLZ	FL,DNEED!ANEED	;WE SHALL NEED MORE OF BOTH LATER.
	MOVE	A,DNAME		;FOR SURE WE SHALL HAVE TO WRITE THE UFD NAME.
	PUSHJ	P,AIDXBG	;ADD PPN TO ARC INDEX
	PUSHJ	P,DMPUTX	;IN THE ARC FILE (SINCE ARC FILE NEVER SHRINKS)
	SETZM	MMNAM		;FORCE DAT READ.
	SETZM	TTNAM		;FORCE ARC READ.

;HERE TO RELOAD TTNAM AND TTEXT.
ARC.M0:	SKIPE	TTNAM
	JRST	ARC.M1
	PUSHJ	P,TNRD1		;GET THE FILE NAME FROM TAPE.
	MOVEM	A,TTNAM		;SAVE ARC FILE NAME
	JUMPE	A,ARC.M1	;JUMP IF THERE'S NO ARC DATA.
	PUSHJ	P,TNRD1
	MOVEM	A,TTEXT		;SAVE ARC FILE EXTENSION
ARC.M1:	SKIPN	MMNAM		;SKIP IF WE GOT DATA
	PUSHJ	P,ARCDRD	;READ FROM THE DAT FILE.
	SKIPN	MMNAM		;IS THERE A FILE NAME HERE?
	JRST	A.MAF		;NO. FLUSH THE ARC FILE.
	SKIPN	A,TTNAM		;ANY DATA FROM ARC FILE?
	JRST	A.MDF		;NO. FLUSH THE DAT FILE ENTRY.
	CAMLE	A,MMNAM		;SKIP IF TTNAM  MMNAM
	JRST	A.MDF		;TTNAM>MMNAM.  FLUSH DAT DATA
	CAME	A,MMNAM		;SKIP IF TTNAM=MMNAM
	JRST	A.MAF		;TTNAM<MMNAM.  FLUSH ARC DATA
	HLLZ	B,MMEXT
	HLLZ	A,TTEXT
	CAMLE	A,B		;SKIP IF TTEXT  MMEXT
	JRST	A.MDF		;TTEXT>MMEXT.  FLUSH DAT DATA
	CAME	A,B
	JRST	A.MAF		;TTEXT<MMEXT.  FLUSH ARC DATA
;HERE WE HAVE THE SAME FILE NAMES.  FLUSH DAT FIRST (NEWER) THEN ARC.
	HRRZ	W,MMEXT		;GET DAT COUNT.
	JUMPE	W,A.MAF		;IF NULL, FLUSH ARC DATA. (WRITE TTNAM FIRST)
	MOVE	A,TTNAM		;GET FILE NAME
	PUSHJ	P,DMPUTX	;WRITE IT.
	MOVE	A,TTEXT		;GET EXTENSION
	ADDI	A,(W)		;ADD TO ARC COUNT THE DAT COUNT
	PUSHJ	P,DMPUTX	;WRITE EXTENSION AND COUNT.
	MOVE	B,.JBFF
ARC.M2:	MOVE	A,(B)		;LOOP WRITING DATA.
	PUSHJ	P,DMPUTX
	ADDI	B,1
	SOJG	W,ARC.M2
	HRRZ	W,TTEXT		;GET THE COUNT
ARCM2A:	PUSHJ	P,TNRD1		;READ ARC
	PUSHJ	P,DMPUTX	;WRITE ARC
	SOJG	W,ARCM2A
	SETZM	TTNAM		;FORCE ARC RELOAD
	SETZM	MMNAM		;FORCE DAT RELOAD
	JRST	ARC.M0		;RELOAD TTNAM FROM ARC FILE.
			
;HERE, ARC DATA IS FLUSHED OUT.  EITHER EOD ON DAT FILE, OR MMNAM>TTNAM
A.MAF:	MOVE	A,TTNAM		;GET THE ARC DATA.
	PUSHJ	P,DMPUTX	;WRITE THE DATA.
	JUMPE	A,ARC.RT	;IF TTNAM=0 THEN WE'RE DONE WITH UFD.
	MOVE	A,TTEXT		;GET THE EXTENSION
	PUSHJ	P,DMPUTX
A.MAF0:	HRRZ	W,TTEXT		;GET THE COUNT
A.MAF1:	PUSHJ	P,TNRD1		;READ ARC
	PUSHJ	P,DMPUTX	;WRITE ARC
	SOJG	W,A.MAF1
	SETZM	TTNAM		;FORCE ARC RELOAD
	SKIPE	MMNAM		;EOD ON DAT UFD?
	JRST	ARC.M0		;RELOAD TTNAM FROM ARC FILE.
;HERE IF WE'VE FINISHED UFD IN DAT FILE.
	PUSHJ	P,TNRD1		;RELOAD ARC DATA
	MOVEM	A,TTNAM
	JUMPE	A,A.MAF		;JUMP IF EOD ON ARC UFD
	PUSHJ	P,TNRD1
	MOVEM	A,TTEXT
	JRST	A.MAF

;HERE, DAT DATA IS FLUSHED OUT. EITHER EOD ON ARC FILE, OR MMNAM<TTNAM
A.MDF:	HRRZ	W,MMEXT		;IS THERE ANY DATA TO WRITE?
	JUMPE	W,A.MDF1	;NO. RETURN.
	MOVE	A,MMNAM		;WRITE FILE NAME, EXT AND COUNT.
	PUSHJ	P,DMPUTX
	MOVE	A,MMEXT
	PUSHJ	P,DMPUTX
	MOVE	B,.JBFF
A.MDF2:	MOVE	A,(B)		;LOOP WRITING DATA.
	PUSHJ	P,DMPUTX
	ADDI	B,1
	SOJG	W,A.MDF2
A.MDF1:	SETZM	MMNAM		;FORCE RELOAD FROM DAT
	JRST	ARC.M1		;GO REFILL FROM DAT FILE.

ARCTS1:	CLOSE	UFD, 		;DAT IN
	RELEAS	UFD,
	CLOSE	MEM,		;CLOSE ARC IN
	RELEAS	MEM,
	PUSHJ	P,AIDXFR	;FORCE LAST ARC INDEX BLOCK (LAST DATA BLOCK TOO)
	CLOSE	DSKMSC,		;CLOSE ARC OUT.
	PUSHJ	P,UIDXFR	;FORCE LAST DAT INDEX BLOCK
	CLOSE	FILE,		;DAT OUT
	RELEAS	FILE,
	RELEAS	DSKMSC,
	POPJ	P,

;READ DAT DATA (FOR ONE FILE) INTO CORE.
;FLUSH THE TEMPORARY DATA TO NEW DAT OUTPUT.
;COMPACT THE PERMANENT DATA.
ARCDRD:	MOVE	B,.JBFF		;GET ADDRESS OF FIRST FREE
IFN 1,<
	MOVE A,MMNAM
	MOVEM A,OMMNAM		;SAVE PREVIOUS FILENAME
	MOVE A,MMEXT
	HLLZM A,OMMEXT		;AND EXT
	MOVE A,DNAME
	MOVEM A,ODNAME		;AND PPN
>;IFN 1
	PUSHJ	P,UFDRD		;READ FROM DART.DAT
	JFCL
	MOVEM	A,MMNAM		;SAVE FILE NAME
	JUMPE	A,ARCDR7	;JUMP IF NO FILE NAME (END OF FILE ENTRY)
	PUSHJ	P,UFDRD		;READ EXTENSION
	JFCL
	MOVEM	A,MMEXT		;SAVE EXTENSION.
IFN 1,<
	SKIPN FLSDPS		;right half means checking, left flushing
	JRST ARCD00
	HRRZS FLSDPS		;assume no match, not same file again
	MOVE C,MMNAM
	CAME C,OMMNAM
	JRST ARCD00		;different
	HLLZ C,MMEXT
	CAME C,OMMEXT
	JRST ARCD00
	MOVE C,DNAME		;PPN?
	CAME C,ODNAME
	JRST ARCD00		;different
	HRROS FLSDPS		;set flag to flush this file's entries
	PUSH P,A
	PUSH P,B
	PUSH P,D
	OUTSTR CRLF
	OUTSTR [ASCIZ/Flushing duplicate filename: /]
	MOVE A,OMMNAM
	MOVE B,OMMEXT
	MOVE D,DNAME
	PUSHJ P,TYFIL		;type filename from A,B,D
	OUTSTR [ASCIZ /  /]	;no crlf here, type one $ for each flush below
	POP P,D
	POP P,B
	POP P,A
ARCD00:
>;IFN 1
	HRRZ	C,A		;GET THE COUNT.
	MOVEI	W,0		;COUNT THE TEMPORARIES.
ARCDR1:	PUSHJ	P,UFDRD		;READ DATA.
	JFCL
	CAMG	B,.JBREL
	JRST	ARCDR2
	MOVE	D,.JBREL
	ADDI	D,2000
	CORE	D,
	JRST	NOCORE
ARCDR2:	MOVEM	A,(B)		;STORE THE DATA.
IFN 1,<
	SKIPL FLSDPS		;flushing duplicate filenames?
	JRST ARCDR0		;nope, don't even check
	OUTSTR [ASCIZ /$/]
	MOVSI A,400000
	IORB A,(B)		;force on the temporary tape bit, avoid .ARC
ARCDR0:
>;IFN 1
	JUMPGE	A,.+2		;JUMP IF P-DUMP
	ADDI	W,1		;T-DUMP. INCREMENT THE T COUNT
	ADDI	B,1		;INCREMENT B.
ARCDR3:	SOJG	C,ARCDR1	;LOOP.
	JUMPE	W,CPOPJ		;JUMP IF NOTHING TO WRITE IN DAT
	MOVEI	A,0
	EXCH	A,DNAMEO	;GET UFD NAME
	JUMPE	A,AR.DR3	;JUMP IF UFD NAME HAS BEEN WRITTEN(DAT)
	PUSHJ	P,UIDXBG	;ADD UFD NAME TO FILE INDEX
	PUSHJ	P,DFWRTX	;WRITE UFD NAME.
AR.DR3:	MOVE	A,MMNAM		;GET THE NAME
	PUSHJ	P,DFWRTX
	MOVE	A,MMEXT		;GET THE EXT
	HRRI	A,(W)		;AND THE COUNT.
	PUSHJ	P,DFWRTX
	MOVE	B,.JBFF		;GET POINTER TO THE DATA.
	MOVE	D,.JBFF		;ANOTHER POINTER. THE COMPACT ONE.
	HRRZ	C,MMEXT		;AND THE COUNT
	HLLZS	MMEXT		;CLEAR COUNT.
ARCDR4:	SKIPL	A,(B)		;SKIP IF WE WANT TO WRITE THIS.
	AOJA	D,ARCDR5	;DONT WRITE THIS, BUT COMPACT IT.
	PUSHJ	P,DFWRTX	;WRITE IN T FILE.
	JRST	ARCDR6

ARCDR5:	MOVEM	A,-1(D)		;STORE, COMPACTING.
	AOS	MMEXT		;COUNT ONE.
ARCDR6:	ADDI	B,1		;INCREMENT TAKER.
	SOJG	C,ARCDR4	;LOOP.
	POPJ	P,

ARCDR7:	SKIPN	A,DNAMEO	;WAS THE UFD NAME WRITTEN TO THE DAT FILE?
	PUSHJ	P,DFWRTX	;YES. SO WE WRITE A ZERO TO END IT.
	POPJ	P,		;DONE.

;ROUTINES FOR HANDLING THE INDEX ON THE ARC FILE.
;HERE WHEN THERE'S NO ROOM IN THE INDEX BLOCK WE'RE BUILDING.
AIDXBW:	EXCH	B,ADXPDP			;STRAIGHTEN OUT THE AC'S
	PUSH	P,A
	PUSH	P,B
	PUSHJ	P,AIDXND			;DO THE WORK
	POP	P,B
	POP	P,A				;FIX STACK AND TRY AGAIN.

;HERE TO INITIATE A NEW UFD INTO THE INDEX FILE
AIDXBG:	EXCH	B,ADXPDP
	CAMN	B,[-2,,ADXPDL+175]		;RUN OUT OF SPACE?
	JRST	AIDXBW				;YES.  THIS IS HARD.
	PUSH	B,A				;STORE THE UFD NAME
	PUSH	B,ARCWC				;AND THE CURRENT WORD NUMBER
	EXCH	B,ADXPDP
	POPJ	P,

;HERE TO WRITE OLD INDEX, POINT IT TO A NEW ONE.  INITIALIZE A NEW INDEX
AIDXND:	MOVE	A,ARCWC				;GET WORD COUNT
	ADDI	A,177
	TRZA	A,177				;CALC WORD NUMBER OF NEXT INDEX BLOCK
AIDXFR:	MOVEI	A,0				;END OF WORLD - FORCE LAST INDEX.
	PUSH	P,A
	PUSHJ	P,DMFRC				;FORCE CURRENT BLOCK OUT
	POP	P,A
	EXCH	A,ADXPDL+176			;GET OLD INDEX BLOCK WORD NUMBER
	LSH	A,-7				;CONVERT TO RECORD NUMBER
	USETO	DSKMSC,1(A)			;SET THE BLOCK.
	PUSHJ	P,AIDXWT			;WRITE THE 128 WORDS OF INDEX.
	SKIPG	A,ADXPDL+176			;GET THE WORD NUMBER OF NEXT INDEX
	POPJ	P,				;ZERO MEANS LAST WAS FORCED AT EOF
	LSH	A,-7
	USETO	DSKMSC,1(A)			;SET TO WRITE BLANK INDEX BLOCK.
	JRST	.+2
AIDXIN:	SETZM	ADXPDL+176			;HERE TO INITIALIZE EVERYTHING
	MOVE	A,[-200,,ADXPDL-1]
	MOVEM	A,ADXPDP
	SETZM	ADXPDL
	MOVE	A,[ADXPDL,,ADXPDL+1]
	BLT	A,ADXPDL+175			;CLEAR FRESH INDEX BLOCK
	MOVEI	A,200
	ADD	A,ADXPDL+176
	MOVEM	A,ARCWC				;COUNT THE INDEX IN THE WC
AIDXWT: MOVSI	B,-200
	MOVE	A,ADXPDL(B)
	PUSHJ	P,DMPUT
	AOBJN	B,.-2
	JRST	DMFRC				;GO FORCE THIS BLOCK OUT.

SKPADX:	PUSHJ	P,TNREAD
	POPJ	P,				;END OF FILE?
SKPAD1:	MOVSI	B,-173
	PUSHJ	P,TNREAD
	JFCL
	AOBJN	B,.-2
	PUSHJ	P,TNREAD
	JFCL
	MOVEM	A,ALTIPP			;SAVE NAME OF LAST INDEXED PPN
	SETOM	ALTRPP				;NAME OF LAST PPN READ
	MOVSI	B,-3
	PUSHJ	P,TNREAD
	JFCL
	AOBJN	B,.-2
	POPJ	P,

;NOW, SKIP ZEROS UNTIL WE SEE THE NEXT INDEX BLOCK, IF ANY
RDAPP1:	PUSHJ	P,TNREAD			;SKIP ANY NULLS PRECEDING NEXT INDEX
	POPJ	P,
	JUMPE	A,.-2				;SKIP NULLS.
	PUSHJ	P,SKPAD1			;SKIP INDEX BLOCK
RDAPPN:	MOVE	A,ALTIPP			;GET NAME OF LAST PPN IN INDEX
	CAMN	A,ALTRPP			;SAME AS LAST PPN READ?
	JRST	RDAPP1				;YES. NOW SKIP TO INDEX
	PUSHJ	P,TNREAD
	POPJ	P,				;END OF FILE.
	MOVEM	A,ALTRPP
	JRST	CPOPJ1

ARCB0:	OUTSTR	[ASCIZ/Can't find or access DART.DAT for archive - LOCATE.
/]
ARCBX:	RESET	
	SETZM	REDOPN		;no magtape open for reading
	SETZM	WRTOPN		;no magtape open for writing
	SETZM	MT2BUF		;no second set of magtape buffers, jobff reset
IFN STANSW,<
	PUSH P,A		;RESET clears interrupt enablings!
	MOVEI A,INTRPT		;address of interrupt handler
	MOVEM A,.JBAPR
	MOVSI A,INTTTI		;interrupt on ESC I
	INTENB A,		;enable interrupts
	POP P,A
>;IFN STANSW
	HALT	.

ARCB1:	OUTSTR	[ASCIZ/Can't find or access DART.ARC for archive - LOCATE.
/]
	JRST	ARCBX

ARCB2:	OUTSTR	[ASCIZ/Can't enter new DART.DAT
/]
	JRST	ARCBX

ARCB3:	OUTSTR	[ASCIZ/Can't enter new DART.ARC
/]
	JRST	ARCBX
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             subttl	mrestore	; ILMRS1 ILMRS2 ILMRS3 MRSDEF MRSLNK MRSNAM MRSEXT MRSPPN MRSLEN MRESTO MRES1 MRESL MRESL1 MRESL2 MRES2 MRESA MRESA0 MRESA7 MRESA6 MRESA8 MRESA9 MRESA1 MRESA2 MRES3 MRTS MRTS1 MRTS2 MRTS3 MRTS4

;Major Restore Command.  This command may be used to restore a list of directories,
;or, after some catastrophe, all directories.

;Requirements:
; First, restore ALLDIR.DAT[DMP,SYS] from the END of the (last tape of the)
; last dump completed prior to the castrophe.
; Then typein the MRESTORE command followed by a series of arguments, e.g.,
;   MRESTORE [*,*]
;   MRESTORE [*,FOO],[2,BAR]
; Note there is no point in trying to MRESTORE a individual files
; since the LOCATE command will find the particular tapes of interest.

ILMRS1:	OUTSTR	[ASCIZ/Destination term illegal in MRESTORE
/]
	JRST	RESTAR

ILMRS2:	OUTSTR	[ASCIZ/Individual names illegal in source term.  Only *.* legal.
/]
	JRST	RESTAR

ILMRS3:	OUTSTR	[ASCIZ/I need ALLDIR.DAT.  You'd better find one from some old tape.
Alternatively, if you wanted ALLDIR.OLD, copy it as ALLDIR.DAT.
/]
	JRST	RESTAR


MRSDEF:: PHASE 0		;Define data block for MRESTORE internal list
MRSLNK:: 0			;Link to next
MRSNAM:: 0			;File name
MRSEXT:: 0			;Extension,,Tape number + 400000 if Temp class
MRSPPN:: 0			;PPN
MRSLEN==.
	DEPHASE
	ORG MRSDEF

MRESTO:	SETZM MASCOP		;not doing master tape copy
	PUSHJ	P,SCAN			;SCAN THE COMMAND LINE.
	SETZM	MRSTDV-1		;KLUGE
	SKIPN	R,DEST			;WAS THERE ANY DESTINATION GIVEN
	MOVEI	R,MRSTDV-1		;KLUGE TO ZERO MRSTDV BLOCK
	MOVSI	R,(R)			;SOURCE OF BLT
	HRRI	R,MRSTDV		;DESTINATION
	BLT	R,MRSTPN		;DO THE TRANSFER
	MOVEI	A,ALLMSK		;ASSUME DSK:*.*[*,*]
	SKIPN	DEST			;WAS THERE EXPLICIT DEST TERM
	MOVEM	A,MRSTET		;NO. SET *.* FLAGS
	SKIPN	A,MRSTDV		;GET THE DEVICE NAME
IFE FTHELP,<
	MOVSI	A,'DSK'			;NONE THERE. USE DISK
>;IFE FTHELP
IFN FTHELP,<
	JRST [	OUTSTR [ASCIZ/
Will restore to device 'RSK'.

/]
		MOVSI A,'RSK'		;NONE THERE. USE DISK
		JRST .+1]
>;IFN FTHELP
	MOVEM	A,MRSTDV		;SAVE AS RESTORE DEVICE.
	MOVE	B,MRSTET		;GET SPECIAL BITS 
	CAIE	B,ALLMSK
	JRST	ILMRS1			;ILLEGAL DESTINATION TERM

	HRRZ	W,TBASE			;GET THE BASE OF ALL TERMS
	CAME	W,FSPTR			;ARE THERE ANY SOURCE TERMS AT ALL?
	JRST	MRES1			;YES.
	PUSHJ	P,GETBLK		;GET A TERM BLOCK
	MOVEI	A,ALLMSK		;RESTORE *.*[*,*]
	MOVEM	A,FSEXT(R)		;STORE WILD FLAGS
MRES1:	MOVE	A,USRPPN		;INITIAL STICKY PPN
	MOVEM	A,STKPPN		;SAVE IT
	SETZM	A,STKBIT		;SAVE STICKY BITS
	MOVE	A,FSDEV(W)		;LOOK FOR A DEVICE
	MOVEM	A,MTDEV			;DEV NAME GIVEN IN FIRST TERM. SAVE IT.
	MOVE	A,FSPTR
	MOVEM	A,.JBFF			;MAKE .JBFF FROM FREE POINTER.
MRESL:
repeat 0,<
	HRRZ	B,FSEXT(W)		;GET MAGIC BITS
	TRON	B,ALLFIL+ALLEXT		;IS THE NAME WILD?
	SKIPE	FSNAM(W)		;NOT WILD. IS THERE ANY NAME?
	MOVEI	B,0			;WILD NAME OR EXPLICIT NAME
	IORB	B,FSEXT(W)		;NO NAME AND NOT WILD. ASSUME *.*
>;repeat 0
	MOVEI A,FSNAM(W)	;ptr to filename and ext/wild bits
	PUSHJ P,STWILD		;make omitted filename wild, and maybe ext too
	MOVE B,FSEXT(W)		;get wild bits
	TRC	B,ALLFIL!ALLEXT
	TRCE	B,ALLFIL!ALLEXT
	JRST	ILMRS2		;not *.* -- that's illegal in MRestore
	ANDI	B,ALLPRJ!ALLPRG		;SELECT ONLY THE PPN BITS.
	SKIPN	A,FSPPN(W)		;PICKUP ANY EXPLICIT PPN
	JUMPE	B,MRESL1		;JUMP IF THERE IS NO EXPLICT BITS
	MOVEM	A,STKPPN		;SAVE NEW STICKY PPN
	MOVEM	B,STKBIT		;SAVE STICKY BIT
	JRST	MRESL2

MRESL1:	MOVE	A,STKPPN		;GET STICKY PPN
	MOVEM	A,FSPPN(W)
	HRRZ	B,STKBIT
	IORM	B,FSEXT(W)		;SAVE STICKY BITS HERE TOO
MRESL2:	ADDI	W,FSLEN			;INCREMENT W
	CAML	W,FSPTR			;ARE WE DONE?
	JRST	MRES2			;YES.
	SKIPE	A,FSDEV(W)		;PICKUP DEVICE NAME
	CAMN	A,MTDEV			;EXPLICIT DEVICE 
	JRST	MRESL			;NO DEVICE, OR SAME DEVICE
	OUTSTR	[ASCIZ/Multiple source devices.
/]
	JRST	RESTAR

MRES2:	MOVEI	A,10+GARBIT		;READ MFD. PREVENT LOSSAGE FROM BAD RETR.
IFE FTHELP,<
	MOVE	B,MRSTDV		;DEVICE
>;IFE FTHELP
IFN FTHELP,<
	OUTSTR [ASCIZ/Looking for DSK:ALLDIR.DAT ...
/]
	MOVSI	B,'DSK'			;DEVICE
>;IFN FTHELP
	MOVEI	C,UFDBUF		;BUFFER HEADER FOR INPUT
	OPEN	UFD,A			;CHANNEL FOR READING ALLDIR.DAT
	PUSHJ	P,NODEV			;LOSE BIG
	INBUF	UFD,NBUFS
	MOVE	A,['ALLDIR']
	MOVSI	B,'DAT'
	MOVEI	C,0
	MOVE	D,DUMPER
	LOOKUP	UFD,A			;SEEK FILE
	JRST	ILMRS3			;FATAL ERROR!
	MOVE	S,.JBFF			;GET POINTER TO FREE SPACE.
	SETZM	MRBASE			;Linked list of all blocks

MRESA:	PUSHJ	P,UFDRD			;READ PPN FROM ALLDIR.DAT
	JRST	MRES3			;EOF.
	JUMPE	A,MRES3			;OR ZERO ENDS THE LIST?
	MOVE	Z,A			;Z_PPN
;CHECK FOR ANY INTEREST IN THIS PPN	;SET UP INSTR. TO XCT.
	MOVE	R,TBASE			;BASE OF TERMS
MRESA0:	HRRZ	B,FSEXT(R)
	ANDI	B,ALLPRG!ALLPRJ
	CAIN	B,ALLPRG!ALLPRJ
	JRST	MRESA9			;FOR [*,*] IS EASY.
	HLLZ	C,FSPPN(R)
	HLLZ	D,Z
	TRNN	B,ALLPRJ		;[*,?
	CAMN	C,D			;NO THEY MATCH?
	JRST	MRESA6			;PRJ MATCHES
MRESA7:	ADDI	R,FSLEN
	CAMGE	R,FSPTR
	JRST	MRESA0
	JRST	MRESA8			;REJECT

MRESA6:	HRRZ	C,FSPPN(R)
	TRNN	B,ALLPRG
	CAIN	C,(Z)
	JRST	MRESA9
MRESA8:	SKIPA	Y,[JRST MRESA1]
MRESA9:	MOVSI	Y,(<JFCL>)
MRESA1:	PUSHJ	P,UFDRD			;READ FILE NAME
	JFCL
	SKIPN	W,A			;MOVE FILE NAME TO W.
	JRST	MRESA			;ZERO TERMINATES PPN
	PUSHJ	P,UFDRD			;GET EXTENSION
	JFCL
	MOVE	X,A			;SAVE EXT IN X.
	XCT	Y			;EITHER JRST MRESA1 OR JFCL
	MOVEI	A,MRSLEN(S)		;MAKE SURE THERE'S ROOM for block
	CAMGE	A,.JBREL
	JRST	MRESA2			;JUMP IF THERE'S ROOM LEFT
	CORE	A,			;GET MORE CORE
	JRST	NOCORE			;NONE AVAILABLE
MRESA2:	MOVEM	W,MRSNAM(S)		;STUFF FILE
	MOVEM	X,MRSEXT(S)		;STUFF EXT,,TAPE NUMBER
	MOVEM	Z,MRSPPN(S)
	MOVE	A,MRBASE
	MOVEM	A,MRSLNK(S)
	MOVEM	S,MRBASE
	ADDI	S,MRSLEN
	JRST	MRESA1

MRES3:	RELEAS	UFD,			;RELEASE CHANNEL
	MOVEM	S,FSPTR			;Save next loc as free pointer
	MOVEM	S,.JBFF			;and as new jobff.
	SKIPN	X,MRBASE		;JUMP IF THERE ARE ANY TERMS AT ALL.
	POPJ	P,			;NONE?!!
	PUSHJ	P,MRSORT		;ANOTHER INCREDIBLE SORT.
	MOVEM	X,MRBASE		;MRBASE=sorted list of terms
	PUSHJ	P,MRLIST		;MAKE LISTING FILE IF DESIRED
	SETZM	MRTPNO			;OPR DOESN'T CARE WHICH TAPE, YET.
MRTS:	SKIPN	A,MRBASE
	JRST	MRTS4			;DONE IF NO "TERMS" LEFT
	HRRZ	B,MRSEXT(A)		;GET TAPE NUMBER FROM FIRST TERM.
	MOVEM	B,TAPNO
MRTS1:	MOVE	D,A			;D:=Address of the previous block.
	SKIPN	A,MRSLNK(A)
	JRST	MRTS2			;OFF THE END - THIS WILL BE LAST TAPE.
	HRRZ	C,MRSEXT(A)
	CAMN	B,C
	JRST	MRTS1			;loop while the same.
MRTS2:	EXCH	A,MRBASE		;MRBASE:=pointer to remainder.
	MOVEM	A,TBASE			;TBASE:=pointer to this set of terms
	SETZM	MRSLNK(D)		;Zero link out of last of these terms
	PUSH	P,.JBFF
	SKIPE	B,MRTPNO		;GET OPR DESIRED TAPE NUMBER
	CAMN	B,TAPNO			;SAME AS TAPE WE PROPOSE?
	JRST	.+2			;OPR DOESN'T CARE (YET) OR WE MATCH IT.
	JRST	MRTS3			;OPR CARES AND WE AREN'T THERE YET.
	PUSHJ	P,DOMT0			;CAUSE TAPE TO BE MOUNTED.
	 JRST	MRTS3			;SKIP RESTORE IF OPERATOR REQUESTS TAPE "X"
	MOVE	A,MTAPNO
	MOVEM	A,PREQTP		;SAVE TAPE NUMBER TO TELL RDFIL TO CHECK IT
	PUSHJ	P,MRTV			;RESTORE FROM ONE TAPE.
MRTS3:	POP	P,.JBFF
	JRST	MRTS			;LOOP UNTIL LIST EXHAUSTED.

MRTS4:	SKIPE	MRTPNO
	OUTSTR	[ASCIZ/Sorry, the tape you requested was not needed for this restore
/]
	POPJ	P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          subttl	mrestore	; MRLIST MRLALT MRLST0 MRLST1 MRLST2 MRLST3 MRLST4 MRLST8 MRLST9 MRSORT MRSRT1 MRSRT2 MRSRT3 MRSCMP MRSCM0 MRSCM1 MRSCM3

MRLIST:	OUTSTR	[ASCIZ/Type Y to make restore listing (LPT:MRESTO.LST)  /]
	SETZM	ALTLST		;not alternate format listing.
	PUSHJ	P,YORN
	 JRST	MRLALT		;test for alternate form
	JRST	MRLST0

MRLALT:	OUTSTR	[ASCIZ/Type Y to make the alternate format listing: /]
	PUSHJ	P,YORN
	 POPJ	P,
	SETOM	ALTLST
MRLST0:	MOVE	A,FSPTR
	MOVEM	A,.JBFF
	MOVEI	A,0
	MOVSI	B,'LPT'
	MOVSI	C,LSTBUF		;OUTPUT BUFFER HEADER
	OPEN	LST,A
	PUSHJ	P,NODEV			;OOPS.
	OUTBUF	LST,2
	MOVE	A,['MRESTO']
	MOVSI	B,'LST'
	SETZB	C,D
	ENTER	LST,A
	JFCL				;IGNORE ENTER FAILURE.
	SKIPE	ALTLST
	JRST	MRLST8
	MOVE	A,[JRST LSTOUT]
	MOVEM	A,XDMPUT		;SET INSTR TO XCT
	PUSHJ	P,TPGINX		;INITIALIZE PAGE OUTPUT -SPECIAL
	SETZM	TPGNUM
	MOVE	R,MRBASE		;address of first of list
;HERE TO START A NEW PAGE.  FIRST FINISH OLD, IF ANY.
MRLST1:	HRRZ	A,TPGPDP
	CAIL	A,TPBUF
	PUSHJ	P,TPGPUT
	JUMPE	R,MRLST3		;Jump if end of all terms
	HRRZ	B,MRSEXT(R)		;GET TAPE NUMBER FROM FIRST TERM.
	MOVEM	B,TAPNO
	PUSHJ	P,REELMX		;SETUP TAPNAM
	HRRZ	B,MRSEXT(R)
MRLST2:	HRRZ	C,MRSEXT(R)
	CAME	C,B
	JRST	MRLST1			;FINISH OLD PAGE
	MOVE	A,TPGPDP
	PUSH	A,MRSNAM(R)		;NAME
	PUSH	A,MRSEXT(R)			;EXT,,TAPE NUMBR
	PUSH	A,MRSPPN(R)		;PPN
	MOVEM	A,TPGPDP
	AOBJN	A,.+2
	PUSHJ	P,TPGPUT		;FORCE PAGE NOW. (PRESERVE B)
	SKIPN	R,MRSLNK(R)		;Advance to next term
	JRST	MRLST1			;OFF THE END - FINISH PAGE.
	JRST	MRLST2

MRLST3:	MOVEI	A,0
	DPB	A,LSTBUF+1
MRLST4:	TRZ	FL,LSTON
	CLOSE	LST,
	RELEAS	LST,
	POPJ	P,

;alternate listing format
MRLST8:	TRO	FL,LSTON
	MOVEI	R,MRBASE-MRSLNK
MRLST9: SKIPN	R,MRSLNK(R)		;address of first of list
	JRST	MRLST4
	MOVE	A,MRSNAM(R)		;NAME
	HLLZ	B,MRSEXT(R)		;EXT,,TAPE NUMBR
	MOVE	D,MRSPPN(R)		;PPN
	PUSHJ	P,TYFIL
	HRRZ	A,MRSEXT(R)
	TRNN	A,400000
	MOVEI	B,[ASCIZ/ P/]
	TRZE	A,400000
	MOVEI	B,[ASCIZ/ T/]
	PUSHJ	P,STROUT
	HRRZ	A,MRSEXT(R)
	TRZ	A,400000
	PUSHJ	P,DECOUT
	MOVEI	B,CRLF
	PUSHJ	P,STROUT
	JRST	MRLST9



;SORT a list.  RECURSIVE.  LIST HEADER IN X.  RETURNS SORTED LIST IN X.

MRSORT:	JUMPE	X,CPOPJ			;NO WORK FOR NO LIST
	SKIPN	W,MRSLNK(X)		;GET LINK TO NEXT
	POPJ	P,			;JUMP IF NO NEXT. 1-ELEMENT LIST IS SORTED.
	MOVE	Y,W			;TAIL OF THE W LIST
	MOVE	Z,X			;TAIL OF THE X LIST
MRSRT1:	MOVE	A,MRSLNK(Y)		;GET LINK-OUT OF W LIST
	MOVEM	A,MRSLNK(Z)		;STORE AS LINK-OUT IN X LIST
	SKIPN	Z,A			;ADVANCE X-TAIL
	JRST	MRSRT2			;NO NEXT
	MOVE	A,MRSLNK(Z)		;GET LINK-OUT OF X-LIST
	MOVEM	A,MRSLNK(Y)		;STORE AS LINK-OUT OF W-LIST
	SKIPE	Y,A			;ADVANCE W-TAIL
	JRST	MRSRT1			;MAKE LISTS OF ALTERNATE ELEMENTS.
MRSRT2:	PUSH	P,W			;SAVE W-LIST
	PUSHJ	P,MRSORT		;SORT THE X-LIST (RECUR UNTIL DONE)
	EXCH	X,(P)			;EXCH SORTED X-LIST WITH W-LIST
	PUSHJ	P,MRSORT		;AND SORT W-LIST
	POP	P,W			;(X AND W ARE INTERCHANGED, BUT WHO CARES)
;W AND X NOW (ASSUME) POINT TO SORTED LISTS.  MERGE THEM INTO ONE LIST.
	MOVEI	Z,Y-MRSLNK		;MERGE LIST HEAD IN Z
MRSRT3:	PUSHJ	P,MRSCMP		;COMPARE.CAR(W) & CAR(X).  Skip if X small
	 EXCH	X,W			;X Larger. EXCH THEM
	MOVEM	X,MRSLNK(Z)		;X<W. ADD CAR(X) TO OUT-LIST
	MOVE	Z,X			;ADVANCE END OF OUT-LIST.
	SKIPE	X,MRSLNK(X)		;FORM CDR(NA)
	JRST	MRSRT3			;CONTINUE THE MERGE
	MOVEM	W,MRSLNK(Z)		;STORE OTHER LIST IN THE OUT-LIST
	MOVE	X,Y			;GET THE ADDRESS OF THE LIST-HEAD
	POPJ	P,			;RETURN, POINTER TO SORTED LIST IN NA


MRSCMP:	HRRZ	A,MRSEXT(X)
	HRRZ	B,MRSEXT(W)
	CAMN	A,B
	JRST	MRSCM0			;compare by name if tape numbers equal
	CAML	A,B			;W comes first if tape number is larger
	AOS	(P)			;X comes first
	POPJ	P,			;W comes first

MRSCM0:	MOVE	A,MRSPPN(X)		;GET THE TWO NAMES.
	CAMN	A,MRSPPN(W)		;SKIP IF DIFFERENT UFD NAMES.
	JRST	MRSCM1			;NAME ARE THE SAME. Select file names
	PUSHJ	P,UFDCNV		;CONVERT NAME in A.
	MOVEM	A,DNX			;SAVE FUNNY NAME
	MOVE	A,MRSPPN(W)
	PUSHJ	P,UFDCNV
	MOVEM	A,TNX			;SAVE FUNNY NAME.
	PUSHJ	P,PPNCMP
	AOS	(P)			;DNX[X] < TNX[W]
	POPJ	P,

MRSCM1:	MOVE	A,MRSNAM(X)
	MOVE	B,MRSNAM(W)
	TLC	A,400000		;again, unsigned compare
	TLC	B,400000
	CAMGE	A,B
	JRST	CPOPJ1			;X is smaller than W
	CAME	A,B
	POPJ	P,			;W is smaller than X
	HLRZ	A,MRSEXT(X)
	HLRZ	B,MRSEXT(W)
	CAMGE	A,B
	JRST	CPOPJ1			;X is smaller than W
	CAME	A,B
	POPJ	P,			;W is smaller than X (or equal???)
	OUTSTR	[ASCIZ/Duplicate term will be removed: /]
	MOVE	A,MRSNAM(X)
	HLLZ	B,MRSEXT(X)
	MOVE	D,MRSPPN(X)
	PUSHJ	P,TYFIL
	HRRZ	A,MRSEXT(X)
	TRNN	A,400000
	OUTSTR	[ASCIZ/ P/]
	TRZE	A,400000
	OUTSTR	[ASCIZ/ T/]
	PUSHJ	P,DECOUT
	OUTSTR	CRLF
	SKIPN	MRSLNK(X)		;Is there a second term in X?
	JRST	MRSCM3			;no.  return X and a short W.
	MOVE	X,MRSLNK(X)		;There's more in x.  Remove first.
	POPJ	P,			;Select next from W.

MRSCM3:	MOVE	W,MRSLNK(W)		;shorten W
	JRST	CPOPJ1			;Return one-element X; W will be appended.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              subttl	mrestore	; MRTV MTRV1 MTRV2 MTRV3 MTRV4 MTRV5 MTRV5A MTRV5B MTRV5C MTRV6 MTRM MTRM1 MTRM2 MTRM3 MTRM4 MTRM5 MTRM6

;HERE WE ACTUALLY START MOVING A TAPE:
MRTV:	SKIPN	GOTALT			;Avoid rewind if operator said so
	PUSHJ	P,MTAREW		;Rewind tape for forgetful operators
	MOVEI	A,10			;DEVICE MODE
	SKIPN	B,MRSTDV		;GET THE DESTINATION DEVICE
IFE FTHELP,<
	MOVSI	B,'DSK'			;NONE THERE. USE DISK
>;IFE FTHELP
IFN FTHELP,<
	JRST [	OUTSTR [ASCIZ/
Will restore to device 'RSK'.

/]
		MOVSI B,'RSK'		;NONE THERE. USE DISK
		JRST .+1]
>;IFN FTHELP
	MOVEM	B,MRSTDV		;SAVE
	MOVSI	C,FOBUF			;NO BUFFERS
	TLZ	FL,UDPGO		;ASSUME NOT UDP

	MOVE	D,B			;GET DEVICE NAME
	DEVCHR	D,
	TLNE	D,DEVDSK
	JRST	MTRV1
IFE UDPSW,<
	JRST	NOTDSK
>;IFE UDPSE
IFN UDPSW,<
	TLNN	D,DEVUDP	;IS THIS A UDP?
	JRST	NOTDSK		;NO.
	INIUDP	B		;INITIALIZE UDP
	TLO	FL,UDPGO
	MOVEI	A,10		;BETTER TRY MODE 10
	MOVSI	C,FOBUF		;AND OUTPUT ONLY
	UOPEN	FILE,A		;DO THE OPEN
>;IFN UDPSW

MTRV1:	OPEN	FILE,A		;ATTEMPT TO OPEN OUTPUT DEVICE
	PUSHJ	P,NODEV		;OOPS.
IFN UDPSW,<
	TLNN	FL,UDPGO	;SKIP IF WE ARE THE UDP
>;IFN UDPSW
	OUTBUF	FILE,22		;TELL SYSTEM TO BUILD US SOME BUFFERS
MTRV2:	PUSHJ P,RDFIL		;READ RETRIEVAL FROM MTAPE
	 JRST .-1		;saw a tape header/trailer, keep going (can't happen)
	TRNE FL,MTAEOT		;SKIP UNLESS logcial END OF TAPE
	JRST MTRV5

	PUSHJ P,DPYSER		;DISPLAY FILE NAME FROM THE TAPE
	 FILINF+DDNAM,,DPYFIL

	MOVEI	W,TBASE-MRSLNK		;GET THE BASE OF TERM BLOCK.
MTRV3:	MOVE	R,W			;R:=Previous (See MTRM)
	SKIPN	W,MRSLNK(W)
	JRST	MTRV4			;not this file.
	MOVE	Y,MRSNAM(W)		;GET THE NAME
	CAME	Y,FILINF+DDNAM		;SAME AS MAGTAPE NAME?
	JRST	MTRV3			;NO. NO MATCH WITH THIS TERM.
	HLLZ	Y,MRSEXT(W)		;GET EXT FROM THIS TERM
	HLLZ	Z,FILINF+DDEXT		;GET EXT FROM MT
	CAME	Y,Z			;SAME AS MAG TAPE EXTENSION?
	JRST	MTRV3			;NO MATCH
	MOVE	Y,MRSPPN(W)		;GET PPN
	CAMN	Y,FILINF+DDPPN		;COMPARE WITH MT PPN
	JRST	MTRM			;WIN. MOVE A FILE.
	JRST	MTRV3

MTRV4:	PUSHJ	P,RDFILX		;FLUSH THROUGH THE END OF THIS FILE
	TRNN	FL,MTAEOT		;SKIP IF EOT
	JRST	MTRV2			;LOOK FOR ANOTHER FILE ON THE TAPE
MTRV5:	TRZ	FL,MTAEOT
	PUSHJ	P,MTAREW
	OUTSTR	[ASCIZ/
Some files are supposed to be on this tape, but I couldn't find them.
/]
MTRV5A:	OUTSTR	[ASCIZ/Type one of the following:
LIST	Disply the names of the unrestored files, then ask this again,
GO	To continue on the next tape, forgetting these files,
RETRY	To reread this tape.
Don't abbreviate:  /]
	PUSHJ	P,GETWRD
	CAMN	A,['LIST  ']
	JRST	MTRV5B
	CAMN	A,['GO    ']
	JRST	MTRV6
	CAMN	A,['RETRY ']
	JRST	MRTV
	OUTSTR	[ASCIZ/Please respond with one of the options listed below.
/]
	JRST	MTRV5A

MTRV5B:	MOVEI	W,TBASE-MRSLNK		;Get the base of the term block
MTRV5C:	SKIPN	W,MRSLNK(W)
	JRST	MTRV5A
	MOVE	A,MRSNAM(W)		;Name from the term block
	HLLZ	B,MRSEXT(W)		;Extension from the term block
	MOVE	D,MRSPPN(W)		;The PPN
	PUSHJ	P,TYFIL			;Type the file name.
	MOVEI	B,CRLF
	PUSHJ	P,STROUT
	JRST	MTRV5C			;Continue printing term blocks


;Here is the way to get out.
MTRV6:	RELEAS	FILE,			;RELEASE DESTINATION DEVICE
IFN UDPSW,<
	TLZE	FL,UDPGO
	SETZM	USYNC			;MAKE SURE WE CAN'T DIDDLE THE UDP
>;IFN UDPSW
	PUSHJ	P,MTAREL		;RELEASE SOURCE DEVICE
	TRZ	FL,SAFETY
	POPJ	P,

;Here to restore a file.
MTRM:	MOVE	X,MRSLNK(W)		;Get the link out of this block
	MOVEM	X,MRSLNK(R)		;Save as link out of the previous.

	MOVE	A,FILINF+DDNAM		;SET UP THE DEFAULTS
	MOVE	B,FILINF+DDEXT
	MOVE	C,FILINF+DDPRO
	MOVE	D,FILINF+DDPPN

IFN STANSW,<
	MOVE	X,[A,,FILBLK]		;SAVE THE FILE NAME SOMEWHERE.
	BLT	X,FILBLK+3		;SAVE..
	TRO	FL,SAFETY
IFN UDPSW,<
	TLNE	FL,UDPGO		;ON THE UDP?
	ULOOK	FILE,A			;YES. ASK RPH
>;IFN UDPSW
	LOOKUP	FILE,A			;LOOKUP THE FILE.
	JRST	.+2			;LOOKUP FAILURE IS A GOOD WAY TO START
	HRRI	B,-1			;THIS IS LOOKUP SUCCESS CODE.
	TLNN	FL,UDPGO
	CLOSE	FILE,NUPACC		;AVOID BEING IN READ/ALTER MODE
	PUSHJ	P,LCHECK		;CHECK THE OMENS.
	JRST	MTRM6			;FOR SOME REASON, DON'T RESTORE.
	TRZ	FL,SAFETY
	MOVE	D,[FILBLK,,A]
	BLT	D,D
IFN UDPSW,<
	TLNE	FL,UDPGO		;SKIP UNLESS THIS IS ENTER ON UDP
	JRST	MTRM1			;ENTER ON UDP. DON'T CLEAR PROTECT
>;IFN UDPSW
	SETZ	C,			;MAKE SURE WE DON'T PROTECT IT TOO MUCH
	JRST	MTRM2			;GO DO DISK ENTER

IFN UDPSW,<
MTRM1:	SKIPN	PASFLG			;HAS THERE BEEN A PASSWORD CHECK?
	PASCHK				;NO. DO IT. RETURN WHEN IT'S OK
	UENTER	FILE,A
IFN FTHELP,<.FATAL Fix the unlikely case of UDPSW and FTHELP here and at RSTG5H.>
>;IFN UDPSW
MTRM2:
IFN FTHELP,<
	PUSHJ P,NXTUNT		;tell system we want next file on next drive
	PUSH P,D+1
	PUSH P,D+2
	GETSTS FILE,D+1
	PUSH P,D+1		;save a UUO later, remember status
	TRO D+1,400		;make us use long-block enter
	SETSTS FILE,(D+1)
	HRR B,FILINF+DDEXT	;and creation/date and hi date bits
	MOVE C,FILINF+DDPRO	;get real protection/date word from retrvl
	MOVE D+1,FILINF+DREFTM	;extra words for long-block enter: ref date
	MOVE D+2,FILINF+DDMPTM	;  and dump date
	SETOM HENTOK		;assume ENTER will skip
>;IFN FTHELP
	ENTER FILE,A		;create destination file
IFN FTHELP,<
	 SETZM HENTOK		;didn't skip, remember that
	POP P,D+1		;old status
	SETSTS FILE,(D+1)	;turn off 400 bit
	MTAPE FILE,[	'GODMOD'  ;set special 4 words back the way they use to be
			11
			FILINF+DQINFO]
	 JRST [	OUTSTR [ASCIZ/Uh, oh, lost trying to restore the 4 info words.
/]
		JRST 4,.]
	POP P,D+2
	POP P,D+1
	SKIPN HENTOK		;skip if ENTER skipped
>;IFN FTHELP

>;IFN STANSW
IFE STANSW,<
	PUSHJ P,RSTPRE
	 JRST MTRM6
	ENTER FILE,LKBLK
>;IFE STANSW

	JRST	[OUTSTR [ASCIZ/ENTER failed: /]
		MOVE	D,[FILBLK,,A]
		BLT	D,D
		PUSHJ	P,TYFIL
		JRST	MTRM6]
IFN STANSW,<
	MOVE	D,INVERS		;GET THE TAPE VERSION NUMBER
	MOVE	C,FILINF+DDOFFS		;GET THE NEEDED OFFSET.
	CAIL	D,IOVER2		;DART VERSION 4 (FORMAT 2) HAS THIS KLUGE
	CAIG	C,1			;OTHER THAN NORMAL?
	JRST	MTRM4			;EARLY VERSION OR NORMAL FILE.
	TLNE	FL,UDPGO
	JRST	MTRM3			;CAN'T DO IT ON (OLD) UDPS.
	MOVEM	C,WROFFS+2		;SET FOR WRITE OFFSET UUO.
	MTAPE	FILE,WROFFS		;WRITE THE FILE OFFSET
	MOVEI	C,2
	SUB	C,FILINF+DDOFFS
	USETO	FILE,(C)
	;JJW 9/85 USETO changes the output byte count from 0 to 200, which must be
	;accounted for since we haven't yet stored the first word into the buffer.
	AOS	FOBUF+2			;Fix count in buffer header
	JRST	MTRM4

MTRM3:	OUTSTR	[ASCIZ/UDP OUTPUT FILE WILL NOT HAVE RECORD OFFSET
/]
>;IFN STANSW
MTRM4:	MOVE	D,[FILBLK,,A]
	BLT	D,D
	PUSHJ	P,TYFIL			;TYPE A FILE NAME
IFN FTHELP,<
	SETZM RSTUFD		;not restoring and compressing a UFD
>;IFN FTHELP
	PUSHJ	P,RFDATA		;GO DO THE RESTORE
IFN STANSW,<
	TLNE	FL,UDPGO
	JRST	MTRM5			;AVOID RENAME IF UDP
	MOVE	D,[FILBLK,,A]
	BLT	D,D
	TLZ	C,400000		;AVOID RESTORING WITH PROT=400
IFE FTHELP,<
	RENAME	FILE,A			;RENAME TO OLD CREATION DATE
	 OUTSTR	[ASCIZ/ (RENAME TO UPDATE DATE OF CREATION FAILED) /]
>;IFE FTHELP
>;IFN STANSW
MTRM5:	OUTSTR	CRLF
	SKIPE	TBASE			;Any terms left to do?
	JRST	MTRV2			;RETURN - READ NEXT TAPE FILE.
	PUSHJ	P,MTAREW	;REWIND THE TAPE, WE'RE THROUGH.
	JRST	MTRV6		;ALL TERMS FOR THIS TAPE HAVE BEEN PROCESSED!

;HERE TO FLUSH CURRENT FILE.
MTRM6:	PUSHJ	P,RDFILX		;FLUSH THROUGH THE END OF THIS FILE
	TRNE	FL,MTAEOT		;SKIP UNLESS EOT
	JRST	MTRV5			;NOTHING WE CAN DO ABOUT THAT.
	JRST	MTRM5
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                subttl	uuo handler	 ; .UUCON UUOCN1 UUSKP2 UUSKP1 UUORET UPDLOV UUOERR UUTAB UDPINX UDPCHX

.UUCON:	PUSH	P,UUOCON	;SAVE RETURN ADDRESS LIKE A PUSHJ
	MOVEM	16,17(P)	;HERE FROM A PUSHJ 17,UUCON IN JOB41
	MOVEI	16,1(P)		;SOURCE,,DESTINATION
	BLT	16,16(P)	;SAVE 0-16 ON STACK
	ADD	P,[XWD 17,17]	;ADJUST STACK
	JUMPG	P,UPDLOV
UUOCN1:	MOVEM	D,UUOTMP	;SAVE D TEMPORARILY.
	HRRZ	D,UUO		;GET THE EFFECTIVE ADDRESS
	CAIGE	D,17		;SKIP IF NOT IN THE AC'S (AT OR ABOVE P=17)
	ADDI	D,-16(P)	;RELOCATE ARGUMENT TO POINT AT STACK
	HRRM	D,UUO		;SET NEW ARGUMENT WHERE IT WILL BE SEEN
	LDB	D,[POINT 9,UUO,8];GET OP CODE
	CAIL	D,UUMAX		;ARE WE IN RANGE?
	MOVEI	D,0		;SET OPCODE TO ZERO TO MAKE ERROR.
	MOVE	D,UUTAB(D)	;GET DISPATCH
	EXCH	D,UUOTMP	;RESTORE D, JUMP ADDRESS IN UUOTMP
	PUSHJ	P,@UUOTMP	;DISPATCH
	JRST	UUORET		;NON SKIP RETURN
	JRST	UUSKP1
UUSKP2:	AOS	-17(P)		;DOUBLE SKIP
UUSKP1:	AOS	-17(P)		;HERE TO DO A SKIP RETURN
UUORET:	SUB	P,[XWD 17,17]
	MOVSI	16,1(P)
	BLT	16,16		;RESTORE AC'S AND RETURN
	POPJ	P,


UPDLOV:	OUTSTR	[ASCIZ/%%% PDL OV AT UUOCON
/]
	HALT	UUOCN1

UUOERR:	OUTSTR	[ASCIZ/%%% ILLEGAL USER UUO.
/]
	HALT	CPOPJ

UUTAB:	UUOERR
IFN UDPSW,<
	OUTUDP
	INUDP
	LOKUDP
	ENTUDP
	RENUDP
	OPNUDP
	CLSUDP
	UDPM2
	UDPINX
	UDPCHX
>;IFN UDPSW

SDEF(UUMAX,.-UUTAB)
IFN UDPSW,<
UDPINX:	MOVE	0,@UUO			;GET THE ARGUMENT INTO 0
	JRST	INTUDP			;CALL ROUTINE.

UDPCHX:	OUTSTR	[ASCIZ/UDP WRITE PASSWORD: /]
	PTYUUO	16,[0
		3]			;ECHO OFF.
	PPIOT	6,1400			;POSITION DPY PAGE PRINTER
	PUSHJ	P,GETSIX		;GET SIXBIT TERM FROM TTY
	PPIOT	6,0			;RESET PAGE PRINTER
	PTYUUO	16,[0
		4]			;ECHO ON.
	MOVE	0,B			;GET IT INTO REGISTER 0
	OUTSTR	CRLF
	PUSHJ	P,UDPCHK		;ASK HELLIWELL IF I'M RIGHT
	JRST	.+2
	POPJ	P,
	PUSHJ	P,FLUSH			;CLEAR TTY line
	JRST	UDPCHX			;AROUND
>;IFN UDPSW
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         subttl	help put the world back together after a tape runs away.  ; HELPPN HELPER HELP1 HELP2 HLPOK HLPUND HLPEOF HLPFIN

;CALLED FROM DDT ONLY

HELPPN:	0			;PPN OF FIRST FAILING RECORD.

HELPER:	INIT	FILE,10	
	'DSK   '
	FOBUF,,
	HALT	.
	INIT	UFD,10
	'DSK   '
	0,,UFDBUF
	HALT	.
	MOVE	A,['ALLDIR']
	MOVSI	B,'MEM'
	SETZB	C,D
	LOOKUP	UFD,A
	HALT	.
	MOVE	A,['ALLDIR']
	MOVSI	B,'MEM'
	SETZB	C,D
	ENTER	FILE,A
	HALT	.
	SKIPN	HELPPN
	HALT	.
HELP1:	PUSHJ	P,UFDRD		;READ A WORD
	JRST	HLPEOF
	CAMN	A,HELPPN	;IS THIS THE PPN TO STOP AT?
	JRST	HLPOK		;YES.
HELP2:	PUSHJ	P,DDFWRT	;NO. WRITE A PPN. (OR, WRITE AN EXT OR DATE WORD)
	PUSHJ	P,UFDRD		;READ A FILE NAME.
	JRST	HLPUND		;UNEXPECTED EOF
	PUSHJ	P,DDFWRT	;WRITE A FILE NAME
	JUMPE	A,HELP1		;ZERO FILE NAME MEANS A PPN IS NEXT.
	PUSHJ	P,UFDRD		;READ EXTENSION AND DUMP TAPE WORD
	JRST	HLPUND		;UNEXPECTED EOF
	TRNN	A,200000	;WAS FILE DUMPED THIS TIME?
	JRST	HELP2		;NO, WRITE THE WORD, AND LOOP
	PUSHJ	P,DDFWRT	;WRITE EXT,,TAPNO
	PUSHJ	P,UFDRD		;READ DATE WRITTEN WORD
	JRST	HLPUND		;UNEXPECTED EOF
	JRST	HELP2		;WRITE THE WORD, AND LOOP

HLPOK:	OUTSTR	[ASCIZ/FOUND THE DESIRED PPN.
/]
	JRST	HLPFIN

HLPUND:	OUTSTR	[ASCIZ/UNEXPECTED EOF
/]
	JRST	HLPFIN

HLPEOF:	OUTSTR	[ASCIZ/EOF WITHOUT HAVING FOUND THE PPN.
/]
HLPFIN:	CLOSE	FILE,
	CLOSE	UFD,
	RELEAS	FILE,
	RELEAS	UFD,
	OUTSTR	[ASCIZ/(TERMINATION AFTER CLOSING ALL FILES)
/]
	HALT	.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               subttl	dreck	reconstruct from wreckage left after the head crash, 12/23/80	 ; UFDLST CURPPN KEEPPN DRKFND DRKLST DRKDEF DRKLNK DRKNAM DRKEXT DRKPPN DRKLEN DRECK DRECK1 DRECK2 DREK2A DREK2B DREK2C DREK2E DREK2D DREK2Z DRECK3 DREK3A DREK3B DREK3D DREK3Z DRKENT DREKE1 DRKWRT DRKWT1 DRKPUT DRKPU1 LITSRT LITSR1 LITSR2 LITSR3 LITSR4 NAMCMP NAMCM1 NAMCM2 DRKSRC

;REG 12/28/80

UFDLST:	0			;AOBJN pointer to list of dead ufds.
CURPPN:	0			;Current PPN.
KEEPPN:	0			;non zero if CURPPN is smashed.
DRKFND:	0			;List of Found Files
DRKLST:	0			;List of Lost files

DRKDEF:: PHASE	0
DRKLNK:: 0			;link to next record
DRKNAM:: 0			;file name
DRKEXT:: 0			;file ext,,tape number
DRKPPN:: 0			;file ppn
DRKLEN==.
	DEPHASE
	ORG	DRKDEF


DRECK:	OUTSTR	[ASCIZ/DART data base manipulation.
Read list of mangled UFDs
/]
	SETZM	REAPLS		;No reap-log file?
	TRZ	FL,LSTON	;no list file.

	SETZM	DRKLST		;List header of the list of lost files
	SETZM	DRKFND		;List header of the found files

	INIT	MEM,17
	'DSK   '
	0
	HALT	.
	MOVSI	A,'UFD'
	MOVSI	B,'LOG'
	MOVEI	C,0
	MOVE	D,['CSDREG']
	LOOKUP	MEM,A
	HALT	.
	MOVE	A,D
	HRR	A,.JBFF
	MOVEM	A,UFDLST		;pointer to the ufd list
	SUBI	A,1			;aobjn pointer
	HLRO	B,D
	MOVN	B,B
	ADDB	B,.JBFF
	CAMGE	B,.JBREL
	JRST	DRECK1
	CORE	B,
	JRST	NOCORE
DRECK1:	MOVEI	B,0
	INPUT	MEM,A
	CLOSE	MEM,
	RELEAS	MEM,

	OUTSTR	[ASCIZ/
Read ALLDIR.BMM, the mangled version of the latest ALLDIR.MEM file
/]
	INIT	FILE,17!DMPBIT	;channel for lookups.  Don't change ref time
	'DSK   '
	0
	HALT	.

	INIT	UFD,10
	'DSK   '
	0,,UFDBUF
	HALT	.
	INBUF	UFD,NBUFS
	MOVE	A,['ALLDIR']
	MOVSI	B,'BMM'
	MOVEI	C,0
	MOVE	D,DUMPER		;PPN of dumper
	LOOKUP	UFD,A
	HALT	.
	SETZM	TAPNO
DRECK2:	PUSHJ	P,UFDRD			;read from file. expect user name
	JRST	DREK2Z			;end of file.
	JUMPN	A,DREK2B		;here's a PPN
	OUTSTR	[ASCIZ/Hole in file.  Commences in data area for /]
	MOVE	A,CURPPN
	PUSHJ	P,PPNOUT
	OUTSTR	[ASCIZ/ on tape /]
	MOVE	A,TAPNO
	TRNE	A,400000
	OUTCHR	["T"]
	TRZN	A,400000
	OUTCHR	["P"]
	ANDI A,TAPMSK			;clear extra bits, leave only tape nbr
	PUSHJ	P,DECOUT
	SETOM	TAPNO
	OUTSTR	CRLF
DREK2A:	PUSHJ	P,UFDRD
	JRST	DREK2Z			;eof while skipping hole.
	JUMPE	A,DREK2A
	PUSH	P,A
	OUTSTR	[ASCIZ/Hole ends in data area for /]
	PUSHJ	P,PPNOUT
	OUTSTR	CRLF
	POP	P,A
DREK2B:	MOVEM	A,CURPPN		;Save Current PPN.
	MOVEI	D,0			;assume ignore this ppn
	MOVE	B,UFDLST
	CAME	A,(B)
	AOBJN	B,.-1
	SKIPGE	B
	MOVEI	D,1			;don't ignore this ppn.
DREK2C:	PUSHJ	P,UFDRD			;read a file name
	JRST	DREK2Z			;eof is not expected. who cares?
	JUMPE	A,DRECK2		;Zero means, a new PPN next
	MOVE	B,A			;save file name
	PUSHJ	P,UFDRD			;get ext.
	 MOVEI	A,0			;Use zero if end of file.
	MOVE	C,A			;save extension and tape number
	TRZN	A,200000		;Is this the current tape?
	JRST	DREK2D			;no.
	SKIPL	TAPNO
	JRST	DREK2E
	HRRZM	A,TAPNO
	PUSH	P,B
	OUTSTR	[ASCIZ/Hole ends at tape number /]
	HRRZ	A,A
	TRNE	A,400000
	OUTCHR	["T"]
	TRZN	A,400000
	OUTCHR	["P"]
	ANDI A,TAPMSK			;clear extra bits, leave only tape nbr
	PUSHJ	P,DECOUT
	OUTSTR	CRLF
	POP	P,B
	SKIPA
DREK2E:	HRRZM	A,TAPNO			;Yes, set tape number.
	PUSHJ	P,UFDRD			;yes, read it
	 JFCL				;ignore eof or test above
DREK2D:	JUMPE	D,DREK2C		;Jump if ignore this ppn
	TRZ	C,200000		;flush signal from C
	PUSHJ	P,DRKENT
	JRST	DREK2C			;Get next file

DREK2Z:	CLOSE	UFD,
	RELEAS	UFD,

	OUTSTR	[ASCIZ/
Read ALLDIR.OLD, the older copy of ALLDIR.MEM file.  Merge with other stuff.
/]
	INIT	UFD,10
	'DSK   '
	0,,UFDBUF
	HALT	.
	INBUF	UFD,NBUFS
	MOVE	A,['ALLDIR']
	MOVSI	B,'OLD'
	MOVEI	C,0
	MOVE	D,DUMPER		;PPN of dumper
	LOOKUP	UFD,A
	HALT	.
DRECK3:	PUSHJ	P,UFDRD			;read from file. expect user name
	JRST	DREK3Z			;end of file.
	JUMPN	A,DREK3A		;here's a PPN
	OUTSTR	[ASCIZ/Hole in file?  I'm confused.  Follows /]
	MOVE	A,CURPPN
	PUSHJ	P,PPNOUT
	OUTSTR	CRLF
	HALT	DRECK3

DREK3A:	MOVEM	A,CURPPN		;Save Current PPN.
	MOVEI	D,0			;assume ignore this ppn
	MOVE	B,UFDLST
	CAME	A,(B)
	AOBJN	B,.-1
	SKIPGE	B
	MOVEI	D,1			;don't ignore this ppn.
DREK3B:	PUSHJ	P,UFDRD			;read a file name
	 JRST	DREK3Z			;eof is not expected. who cares?
	JUMPE	A,DRECK3		;Zero means, a new PPN next
	MOVE	B,A			;save file name
	PUSHJ	P,UFDRD			;get ext.
	 MOVEI	A,0			;Use zero if end of file.
	MOVE	C,A			;save extension
	JUMPE	D,DREK3B		;Jump if ignore this ppn
	MOVEI	W,DRKLST-DRKLNK
	PUSHJ	P,DRKSRC		;Search lost list
	 JRST	DREK3B			;Already in the LOST list
	MOVEI	W,DRKFND-DRKLNK		;Not in the LOST list. Try FOUND
	PUSHJ	P,DRKSRC		;search in FOUND List
	 JRST	DREK3B			;in FOUND list.  Ignore this one.
DREK3D:	PUSHJ	P,DRKENT		;not in either list.  Add it to the list.
	JRST	DREK3B			;Get next file

DREK3Z:	CLOSE	UFD,
	RELEAS	UFD,

	OUTSTR	[ASCIZ/Output a sorted list of known files from smashed UFDs
/]
	MOVEI	A,0			;LISTING IN MODE 0
	MOVSI	B,'DSK'			;PICKUP THE LISTING DEVICE
	MOVSI	C,LSTBUF		;BUFFER HEADER.
	OPEN	LST,A			;OPEN THE DEVICE
	PUSHJ	P,NODEV			;LOSE.
	OUTBUF	LST,2			;MAKE SOME BUFFERS.
	TRO	FL,LSTON		;ANNOUNCE WE ARE LISTING
	MOVE	A,['DART  ']		;
	MOVSI	B,'LST'
	SETZB	C,D
	ENTER	LST,A
	 JRST	NOENT
	MOVE	X,DRKLST
	PUSHJ	P,LITSRT
	MOVEM	X,DRKLST		;sorted
	PUSHJ	P,DRKWRT
	CLOSE	LST,
	RELEAS	LST,
	EXIT

;Here's a file from a damaged PPN.  Does it exist on the disk?
DRKENT:	MOVE	W,B			;file name
	HLLZ	X,C			;ext
	MOVEI	Y,0
	MOVE	Z,CURPPN
	LOOKUP	FILE,W			;does this file exist on disk?
	JRST	DREKE1			;no.  must record it
	CLOSE	FILE,			;This file exists. Add to Found List
	MOVE	X,.JBFF			;address to store new file record
	MOVEI	W,DRKLEN		;advance JOBFF
	ADDB	W,.JBFF
	CAMGE	W,.JBREL		;in bounds?
	JRST	.+3			;yes.
	CORE	W,			;no, get more memory
	JRST	NOCORE			;no more to be had
	MOVE	W,DRKFND		;get the present head of the list
	MOVEM	W,DRKLNK(X)		;store as link out of this item
	MOVEM	X,DRKFND		;store this address as new list head
	MOVEM	B,DRKNAM(X)		;store file name
	MOVEM	C,DRKEXT(X)		;file extension and tape number
	MOVE	A,CURPPN		;and the ppn
	MOVEM	A,DRKPPN(X)		;in the record.
	POPJ	P,

;file does not exist.  Add to LOST List
DREKE1:	CLOSE	FILE,
	MOVE	X,.JBFF			;address to store new file record
	MOVEI	W,DRKLEN		;advance JOBFF
	ADDB	W,.JBFF
	CAMGE	W,.JBREL		;in bounds?
	JRST	.+3			;yes.
	CORE	W,			;no, get more memory
	JRST	NOCORE			;no more to be had
	MOVE	W,DRKLST		;get the present head of the list
	MOVEM	W,DRKLNK(X)		;store as link out of this item
	MOVEM	X,DRKLST		;store this address as new list head
	MOVEM	B,DRKNAM(X)		;store file name
	MOVEM	C,DRKEXT(X)		;file extension and tape number
	MOVE	A,CURPPN		;and the ppn
	MOVEM	A,DRKPPN(X)		;in the record.
	POPJ	P,


DRKWRT:	MOVEI	X,DRKLST-DRKLNK		;pointer to start of catalog
DRKWT1:	SKIPN	X,DRKLNK(X)		;advance to next item in list
	POPJ	P,			;end of list
	PUSH	P,X
	PUSHJ	P,DRKPUT
	POP	P,X
	JRST	DRKWT1

DRKPUT:	MOVE	A,DRKNAM(X)
	PUSHJ	P,SIXOUT
	MOVEI	A,"."
	PUSHJ	P,OUT.CH
	HLLZ	A,DRKEXT(X)
	PUSHJ	P,SIXOUT
	MOVE	A,DRKPPN(X)
	PUSHJ	P,PPNOUT
	HRRZ	A,DRKEXT(X)
	JUMPE	A,DRKPU1
	TRNE	A,400000
	MOVEI	B,[ASCIZ/  T/]
	TRNN	A,400000
	MOVEI	B,[ASCIZ/  P/]
	PUSHJ	P,STROUT
	LDB	A,[POINT 12,DRKEXT(X),35]
	PUSHJ	P,DECOUT
DRKPU1:	MOVEI	B,CRLF
	JRST	STROUT

;SORT a list.  RECURSIVE.  LIST HEADER IN X.  RETURNS SORTED LIST IN X.
LITSRT:	JUMPE	X,CPOPJ			;NO WORK FOR NO LIST
	SKIPN	W,DRKLNK(X)		;GET LINK TO NEXT
	POPJ	P,			;JUMP IF NO NEXT. 1-ELEMENT LIST IS SORTED.
	MOVE	Y,W			;TAIL OF THE W LIST
	MOVE	Z,X			;TAIL OF THE X LIST
LITSR1:	MOVE	A,DRKLNK(Y)		;GET LINK-OUT OF W LIST
	MOVEM	A,DRKLNK(Z)		;STORE AS LINK-OUT IN X LIST
	SKIPN	Z,A			;ADVANCE X-TAIL
	JRST	LITSR2			;NO NEXT
	MOVE	A,DRKLNK(Z)		;GET LINK-OUT OF X-LIST
	MOVEM	A,DRKLNK(Y)		;STORE AS LINK-OUT OF W-LIST
	SKIPE	Y,A			;ADVANCE W-TAIL
	JRST	LITSR1			;MAKE LISTS OF ALTERNATE ELEMENTS.
LITSR2:	PUSH	P,W			;SAVE W-LIST
	PUSHJ	P,LITSRT		;SORT THE X-LIST (RECUR UNTIL DONE)
	EXCH	X,(P)			;EXCH SORTED X-LIST WITH W-LIST
	PUSHJ	P,LITSRT		;AND SORT W-LIST
	POP	P,W			;(X AND W ARE INTERCHANGED, BUT WHO CARES)
;W AND X NOW (ASSUME) POINT TO SORTED LISTS.  MERGE THEM INTO ONE LIST.
	MOVEI	Z,Y-DRKLNK		;MERGE LIST HEAD IN Z
LITSR3:	PUSHJ	P,NAMCMP		;COMPARE.CAR(W) & CAR(X).  Skip if X small
	 EXCH	X,W			;X Larger. EXCH THEM
	MOVEM	X,DRKLNK(Z)		;X<W. ADD CAR(X) TO OUT-LIST
	MOVE	Z,X			;ADVANCE END OF OUT-LIST.
	SKIPE	X,DRKLNK(X)		;FORM CDR(NA)
	JRST	LITSR3			;CONTINUE THE MERGE
LITSR4:	MOVEM	W,DRKLNK(Z)		;STORE OTHER LIST IN THE OUT-LIST
	MOVE	X,Y			;GET THE ADDRESS OF THE LIST-HEAD
	POPJ	P,			;RETURN, POINTER TO SORTED LIST IN NA


;X and W are pointers to catalog cards.  Skip if X is smaller than W
NAMCMP:	HRLZ	C,DRKPPN(X)		;Prog name to LH of C
	PUSHJ	P,LADJ
	MOVE	A,C			;Leftjust Progname to LH of A
	HLLZ	C,DRKPPN(X)		;Project to lh of C
	PUSHJ	P,LADJ
	HLR	A,C			;leftjust Proj to RH of A
	TLC	A,400000		;Force unsigned comparison below

	HRLZ	C,DRKPPN(W)		;Prog name to LH of C
	PUSHJ	P,LADJ
	MOVE	B,C			;Leftjust Progname to LH of B
	HLLZ	C,DRKPPN(W)		;Project to lh of C
	PUSHJ	P,LADJ
	HLR	B,C			;leftjust Proj to RH of B
	TLC	B,400000
;A has "PPN" from X, B from W.
	CAMGE	A,B
	JRST	CPOPJ1			;X is smaller than W
	CAME	A,B
	POPJ	P,			;W is smaller than X
	TLC	A,400000		;unadjust
	CAME	A,['1  1  ']		;[1,1] in adjusted form
	JRST	NAMCM1			;not a UFD name.
	HRLZ	C,DRKNAM(X)		;UFDs are special
	PUSHJ	P,LADJ			;Prog name to LH of C
	MOVE	A,C			;Leftjust Progname to LH of A
	HLLZ	C,DRKNAM(X)		;Project to lh of C
	PUSHJ	P,LADJ
	HLR	A,C			;leftjust Proj to RH of A
	TLC	A,400000		;Force unsigned comparison below

	HRLZ	C,DRKNAM(W)		;Prog name to LH of C
	PUSHJ	P,LADJ
	MOVE	B,C			;Leftjust Progname to LH of B
	HLLZ	C,DRKNAM(W)		;Project to lh of C
	PUSHJ	P,LADJ
	HLR	B,C			;leftjust Proj to RH of B
	TLC	B,400000
;A has "PPN" from X, B from W.
	CAMGE	A,B
	JRST	CPOPJ1			;X is smaller than W
	CAME	A,B
	POPJ	P,			;W is smaller than X
	JRST	NAMCM2			;not supposed to happen

NAMCM1:	MOVE	A,DRKNAM(X)
	MOVE	B,DRKNAM(W)
	TLC	A,400000		;again, unsigned compare
	TLC	B,400000
	CAMGE	A,B
	JRST	CPOPJ1			;X is smaller than W
	CAME	A,B
	POPJ	P,			;W is smaller than X
NAMCM2:	HLRZ	A,DRKNAM(X)
	HLRZ	B,DRKNAM(W)
	CAMGE	A,B
	JRST	CPOPJ1			;X is smaller than W
	POPJ	P,			;W is smaller than X (or equal???)

;Search for file in list.  SKIP if NOT in LIST
DRKSRC:	SKIPN	W,DRKLNK(W)
	JRST	CPOPJ1			;not in the list already.
	MOVE	A,CURPPN
	CAMN	B,DRKNAM(W)
	CAME	A,DRKPPN(W)
	JRST	DRKSRC			;no match here. Try next
	HLLZ	A,C
	HLLZ	X,DRKEXT(W)
	CAME	A,X			;do ext match?
	JRST	DRKSRC			;no.  loop.
	POPJ	P,			;file already in list.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     subttl	test magtape by writing and reading back	 ; MTTEST MTTES2 MTTES3 MTTES4 MTTES7 MTTES6 MTTES5 MTTES9

;Start here from DDT to test magtape by writing all possible bytes on
;the tape, one at a time in bursts.
MTTEST:	OUTSTR [ASCIZ/Writing test pattern: /]
	PUSHJ P,MTINIW		;Init the magtape for writing
repeat 0,<
	MOVSI W,-100		;aobjn cnt,,initial byte to write
MTTES2:	MOVE B,[POINT 6,A]	;byte ptr for stuffing data word
	MOVEI C,6		;number of bytes per word
MTTES3:	IDPB W,B		;duplicate byte in word
	SOJG C,MTTES3		;loop till word filled with byte
	MOVEI D,2		;number of magtape files to write w/ each value
MTTES4:	MOVE C,WRCSZ		;write two whole records of this data
	LSH C,1			;two times record size
>;repeat 0

	MOVNI D,1
MTTES7:	MOVN C,D		;number of nonzero words to write
	MOVEI A,2376		;good number to lose with
MTTES6:	PUSHJ P,TWRITE		;write word in buffer
	 JRST 4,MTTES5		;end of tape
	SOJG C,MTTES6		;write some number of nonzero words
	MOVEI A,0		;data for rest of buffer is zero
	MOVE C,WRCSZ		;get record size
	ADD C,D			;less amount already filled
MTTES5:	PUSHJ P,TWRITE		;write a word on tape (via buffer)
	 JRST 4,.+1		;end of tape
	SOJG C,MTTES5		;loop till have enough output
JFCL;	PUSHJ P,MT2CLZ		;force out buffer, write eof
	OUTCHR ["."]		;indicate progress
MTTES9:	SUBI D,3		;this many more zeroes next time
	CAML D,NWRCSZ		;quit when writing all nonzero record
	JRST MTTES7		;loop with different record data
;	AOBJN W,MTTES2		;loop through all possible byte values
	PUSHJ P,MT2CLZ		;close the magtape
	PUSHJ P,DDTGO		;done, call DDT
	JRST MTTEST		;start over after DDT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       subttl	check order of PPNs in DART.DAT-format file	 ; CHKFIL CHKDAT CHKDAI CHKDAL CHKDAY CHKDAX CHKER0 CHKER1 CHKER2 CHKER3 CHKER4 CHKER5 CHKERT

;Call CHKDAT from DDT to check order of PPNs indexed in a DART.DAT-format file.

CHKFIL:	'T32   '	;name of file to check
	'DAT   '
	0
	0

CHKDAT:	MOVEI	A,10
	MOVSI	B,'DSK'
	MOVEM	B,STRNAM
	MOVEI	C,UFDBUF
	OPEN	UFD,A		;DART.DAT INPUT
	PUSHJ	P,NODEV
	INBUF	UFD,NBUFS	;SOME BUFFERS
	MOVE	A,DUMPER
	MOVEM	A,CHKFIL+3	;set up PPN for lookup
	LOOKUP	UFD,CHKFIL	;open DART.DAT-format file
	 JRST	CHKER0		;no file found

	SETZM	MMEXT		;no previous ptr
	MOVE	A,['2     ']	;make most "negative" PPN
	MOVEM	A,TNX		;use as "previous" PPN
CHKDAI:	MOVEI	C,176/2		;number of PPNs per index block
CHKDAL:	PUSHJ	P,UFDRD		;get new PPN
	 JRST	CHKER1		;unexpected EOF
	JUMPE	A,CHKDAX	;jump if end of index list
	PUSHJ	P,UFDCNV	;convert sixbit to sortable form
	MOVEM	A,DNX		;new PPN
	PUSHJ	P,UFDRD		;get ptr word
	 JRST	CHKER1		;unexpected EOF
	CAMG	A,MMEXT		;ptr greater than last?
	JRST	CHKER3		;no!
	MOVEM	A,MMEXT		;save
	PUSHJ	P,PPNCMP	;compare PPNs
	 JRST	CHKER2		;out of order
	MOVE	A,DNX
	MOVEM	A,TNX		;save current PPN as previous PPN
	SOJG	C,CHKDAL	;get new PPN
	PUSHJ	P,UFDRD		;get ptr to next index block
	 JRST	CHKER1		;unexpected EOF
	TRNE	A,177		;should be on record boundary
	JRST	CHKER4
	LSH	A,-7		;convert to record address
	USETI	UFD,1(A)	;select record to read next
	JRST	CHKDAI		;resume reading index block entries with new block

CHKDAY:	PUSHJ	P,UFDRD		;get 1st word of pair
	 JRST	CHKER1		;unexpected EOF
	JUMPN	A,CHKER5	;should be zero
CHKDAX:	PUSHJ	P,UFDRD		;get 2nd word of pair
	 JRST	CHKER1		;unexpected EOF
	JUMPN	A,CHKER5	;should be zero
	SOJGE	C,CHKDAY	;read two extra words (next block ptr and zero)
	OUTSTR	[ASCIZ/ Done. /]
	JRST	@.JBDDT

CHKER0:	OUTSTR	[ASCIZ/Input file not found (see lookup block at CHKFIL)./]
	JRST	CHKERT

CHKER1:	OUTSTR	[ASCIZ/Unexpected EOF reading index block./]
	JRST	CHKERT

CHKER2:	OUTSTR	[ASCIZ/Indexed PPNs out of order./]
	JRST	CHKERT

CHKER3:	OUTSTR	[ASCIZ/Index pointers out of order./]
	JRST	CHKERT

CHKER4:	OUTSTR	[ASCIZ/Next-index-block address not on record boundary./]
	JRST	CHKERT

CHKER5:	OUTSTR	[ASCIZ/Non-zero data follows last index block entry./]
CHKERT:	JRST	@.JBDDT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ;disaster recovery stuff (FTHELP) ; HENTOK THSUNT RSTUFD UFDCNT UNTPNT NUMUNT NXTUNT NXTUN2 NXTUN3 NXTSPL NXTSYS

IFN FTHELP,<	;whole page, disaster recovery code

HENTOK:	0	;flag for ENTER code in RESTORE and MRESTORE, indicating success
THSUNT:	-1	;last disk unit we forced a file to be written on (logical unit)
RSTUFD:	0	;nonzero if we're restoring a UFD (via RESTORE, not MRESTORE)
UFDCNT:	0	;count of words till next UFD entry in UFD we are restoring

;Table of disk block addresses to get stuck into LSTBLK(RSK SAT) to force
;system to write on particular disk units.  Index with logical disk unit number.
UNTPNT:	135274	;middle block of the unit 0
	430064	;middle block of the unit 1
	722654	;middle block of the unit 2
NUMUNT__.-UNTPNT ;number of disk units

printx Here we use the normally illegal UUO:  SPY AC,  to set LSTBLK(RSK).
OPDEF SPY [CALLI 42]	;a special UUO for our purposes, patched specially in system

;Set LSTBLK to next disk unit, cycling around from last time we were here,
;so next ENTER of RSK file goes on next disk unit.
;But if file is SPLSYS.UFD or   1  3.UFD, then select particular disk unit.
NXTUNT:	PUSH P,C
	HLRZ C,B		;get extension
	CAIN C,'UFD'		;maybe a directory?
	CAME D,['  1  1']	;directories are files in MFD
	JRST NXTUN2		;not a directory
	CAMN A,['SPLSYS']
	JRST NXTSPL		;have special place for this directory
	CAMN A,['  1  3']
	JRST NXTSYS		;have special place for this directory
NXTUN2:	AOSL C,THSUNT		;unit we forced last file to use
	CAIL C,NUMUNT		;within bounds?
	SETZB C,THSUNT		;no, start over
	MOVE C,UNTPNT(C)	;get block address to stuff into LSTBLK(RSK)
NXTUN3:	SPY C,			;set LSTBLK(RSK SAT) to force next file somewhere
	POP P,C
	POPJ P,

NXTSPL:	MOVE C,UNTPNT+1		;put SPL,SYS on logical unit 1
	JRST NXTUN3

NXTSYS:	MOVE C,UNTPNT+2		;put 1,3 on logical unit 2
	JRST NXTUN3

>;IFN FTHELP
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ;temporary tape copy recovery routines ; RECOPY RECLUP RECLU2 RECPEF REPEOT RECPER RECFIC RECFIL

repeat 0,<

;Read initial P3000 and P3001 tapes and re-copy them, fixing words 16 and
;17 of the retrieval for each file on the tapes.  Move word 17 to word 16
;and zero word 17.
RECOPY:	MOVE A,['MTU0  ']
	MOVEM A,MTDEV
	PUSHJ P,MTINIR		;open MTU0 for input
	MOVE A,['MTU1  ']
	MOVEM A,MTDEV
	PUSHJ P,MTINIW		;open MTU1 for output
RECLUP:	PUSHJ P,MTAINP		;read a block from tape
	GETSTS MTA,A		;check status from read
RECLU2:	TRZE A,IOTEND
	PUSHJ P,REOTAP		;report phys end of tape
	TRNE A,740000		;ignore IODEND
	JRST RECPER		;read error
	TRZE A,IOEOF		;IODEND (EOF)?
	JRST RECPEF		;EOF, write an EOF (byte count should be zero)
	PUSHJ P,RECFIL		;check buffer for files, copy to output buffer
	JRST RECLUP

;Here upon reading an EOF.  Copy it to output tape, check for logical EOT.
RECPEF:	SKIPLE TIBUF+2		;input byte count should be zero
	HALT .
	PUSHJ P,MTACLZ		;close input tape, clearing EOF
	SETSTS MTA,(A)		;RESET END OF TAPE BIT
	PUSHJ P,MT2CLZ		;close output, writing EOF
	PUSHJ P,MT2CLS		;check for EOT
	 PUSHJ P,REPEOT		;phys EOT on output
	PUSHJ P,MTAINP		;read next block, to check for logical EOT
	GETSTS A,		;check for two EOFs in row, i.e., log EOT
	TRZN A,IOEOF		;END OF FILE?
	JRST RECLU2		;back to main loop
	OUTSTR [ASCIZ/Logical end of tape seen; that's all folks.
/]
	HALT .

;Here on physical EOT on output tape.  Report it, hope we end input tape soon!
REPEOT:	OUTSTR [ASCIZ/** Physical end of output tape (EOT marker) **
** Input tape better end soon.  Type CONTINUE to keep copying. **
/]
	GETSTS MTA2,A
	TRZ A,IOIMPM!IOTEND	;clear bits that comes with EOT
	SETSTS MTA2,(A)
	HALT CPOPJ		;continue to keep writing

;Here on read error -- we hope never to get here, because this means
;we've lost data and don't know what to do.
RECPER:	OUTSTR [ASCIZ/%%% MT read error, fatal, status = /]
	PUSHJ P,TYPOCH		;type octal half words
	OUTSTR CRLF
	HALT .

;Here on successful read of data record.  Scan it for files, fixing
;retrieval of any files found, then copy whole record to output buffer
;and write it.
RECFIL:	ILDB C,TIBUF+1		;pick up word-count word
	JUMPE C,RECEMP		;jump if no more data in this record
	JUMPL C,RECFST		;jump if file-start block
	TLNN C,-1		;skip if header-trailer block
	JRST RECFCN		;file-continuation block
	HLRZ A,C		;get version number
	CAIE A,VERSION		;make sure version number is current
	JRST RECBVE		;bad version number
	MOVNI B,(C)		;number of words to follow, including rot cksum
	ADDB B,TIBUF+2		;decrement byte count
	JUMPLE B,RECBSH		;jump if byte count too small for tape hdr/trlr
	MOVE B,TIBUF+1		;ptr to wd cnt word in buffer
	MOVEI B,1(B)		;ptr to data
	PUSHJ P,ROTCHK		;add up the checksum
	ADD C,TIBUF+1		;advance byte ptr to checksum word
	CAME A,(C)		;checksum match?
	JRST RECHCE		;no, header checksum error
	HRRM C,TIBUF+1		;update byte ptr in core
    pushj p,tibufc	;check tibuf+1 for overflow
RECFIC:	SOSLE TIBUF+1		;count down byte count
	JRST RECFIL		;loop back and check out next data block
	;done scanning record, now write it out to new tape.
	...

RECFST:	HLRE A,C		;negative tape format number
	CAME A,[-IOVER]		;make sure tape format is current
	JRST RECBFE		;bad format number
	PUSHJ P,RECCKS		;check the checksum
	MOVE D,TIBUF+1		;get byte ptr
	MOVE B,CONDAR(D)	;get 'DART' word
	CAME B,['DART  ']	;OK?
	JRST RECDWE		;no
	MOVE B,CONFMT(D)	;get '*FILE*' word
	CAME B,['*FILE*']	;OK?
	JRST RECFWE		;no
	...

>;repeat 0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   subttl	restore, compare commands	 ; cminfo COMPGO RESTGO RESTG0 RSTG1 RSTG2 RSTG2A RSTG2B CMPDFT RSTDFT

;RESTORE disk files from tape.

;COMPARE disk files against versions on tape.
;Syntax is:	COMPARE <disk filename, incl. wildcards>_<list of tape files>
;Default is:	COMPARE *.*[*,*]_*.*[*,*] (compares every file on tape)
;If any destination (disk file) term is given, the default PPN is your
;alias (maybe the default in that case SHOULD be [*,*]).  For comparisons,
;we open the disk files in mode 410 to avoid updating ref date.  We always
;compare all of the file's header info (date written, protection, mode,
;file length), but we only compare file data until a word differs.  (To
;compare entire file, comment out the SETOM SUPCMP at CMPFLD.)  We don't
;compare the "creation date" (low 15 bits of extension word).

cminfo:	block 4		;special 4 words of disk info go here

;COMPARE command.
COMPGO:	SETOM SWITOK		;rel dump number switch is OK here
IFN FTCOPY,<
	OUTSTR [ASCIZ/Writing log file on current disk area.
/]
	PUSHJ P,MCLINI		;open log file on DUMPER area
;;	SETOM LRETRY		;limit retries
>;IFN FTCOPY
	setzm diffgo		;stop at first difference in each file
	PUSHJ P,SCAN		;SCAN THE COMMAND LINE.
	MOVEI K,CMPRST		;COMPARE cmd data area
	PUSHJ P,CMPDFT		;setup default dests
	JRST RESTG0		;join with RESTORE code

;RESTORE command.
RESTGO:	SETOM SWITOK		;rel dump number switch is OK here
IFN 0*FTCOPY,<
	OUTSTR [ASCIZ/Writing log file on current disk area.
/]
	PUSHJ P,MCLINI		;open log file on DUMPER area
	SETOM LRETRY		;limit retries
>;IFN 0*FTCOPY
	PUSHJ P,SCAN		;SCAN THE COMMAND LINE.
	MOVEI K,REGRST		;REGULAR RESTORE DATA AREA
	PUSHJ P,RSTDFT		;setup default dests
RESTG0:	SKIPN	A,RSTDEV		;GET THE DEVICE NAME
IFE FTHELP,<
	MOVSI	A,'DSK'			;NONE THERE. USE DISK
>;IFE FTHELP
IFN FTHELP,<
	JRST [	OUTSTR [ASCIZ/
Using destination device 'RSK' (not 'DSK').

/]
		MOVSI A,'RSK'		;NONE THERE. USE DISK
		JRST .+1]
>;IFN FTHELP
	MOVEM	A,RSTDEV		;SAVE AS RESTORE DEVICE.
	MOVE	B,RSTEXT		;GET SPECIAL BITS 
	SKIPN	A,RSTPPN		;SKIP IF THERE IS ANY PPN THERE.
	TRNE	B,ALLPRG+ALLPRJ		;NO PPN. SKIP IF NO WILD PPN FLGS
	JRST	RSTG0			;EXPLICIT PPN,  OR WILD PPN THERE 
	xct r.comp(k)		;skip unless doing compare
	 troa b,allprg!allprj	;for compare, assume [*,*] even if filename given
	skipa A,USRPPN		;USE THE CURRENT PPN.
	hrrm b,rstext		;store wild bits (changed if compare)
RSTG0:	MOVEM	A,RSTPPN		;STORE DESTINATION PPN.
repeat 0,<
	TRNN	B,ALLFIL+ALLEXT		;ANY WILD NAME? (BITS STILL IN B)
	SKIPE	RSTNAM			;NAME NOT WILD. SKIP IF NO NAME
	JRST	.+2			;SKIP IF EXPLICIT NAME OR WILD NAME
	MOVEI	B,ALLFIL+ALLEXT		;NO NAME AND NO WILD TERM MEANS *.*
	IORM	B,RSTEXT		;OR IN THE MAJIC BITS
>;repeat 0
	MOVEI A,RSTNAM		;ptr to filename and ext/wild bits
	PUSHJ P,STWILD		;make omitted filename wild, and maybe ext too
	HRRZ	W,TBASE			;GET THE BASE OF ALL TERMS
	CAME	W,FSPTR			;ARE THERE ANY SOURCE TERMS AT ALL?
	JRST	RSTG1			;YES.
	PUSHJ	P,GETBLK		;no, GET A TERM BLOCK
	MOVEI	A,ALLFIL+ALLEXT		;RESTORE *.*[CURRENT AREA]
	xct r.comp(k)		;skip unless doing compare
	 movei a,allfil+allext+allprj+allprg ;compare *.*[*,*]
	MOVEM	A,FSEXT(R)		;STORE WILD FLAGS
RSTG1:	MOVE	A,USRPPN		;INITIAL STICKY PPN
	MOVEM	A,STKPPN		;SAVE IT
	SETZM	A,STKBIT		;SAVE STICKY BITS
	MOVE	A,FSDEV(W)		;LOOK FOR A DEVICE
	MOVEM	A,MTDEV			;DEV NAME GIVEN IN FIRST TERM. SAVE IT.
	MOVE	A,FSPTR
	MOVEM	A,.JBFF			;MAKE .JBFF FROM FREE POINTER.
RSTG2:
repeat 0,<
	HRRZ	B,FSEXT(W)		;GET MAGIC BITS
	TRON	B,ALLFIL+ALLEXT		;IS THE NAME WILD?
	SKIPE	FSNAM(W)		;NOT WILD. IS THERE ANY NAME?
	JRST	.+2			;WILD NAME OR EXPLICIT NAME
	IORM	B,FSEXT(W)		;NO NAME AND NOT WILD. ASSUME *.*
>;repeat 0
	MOVEI A,FSNAM(W)	;ptr to filename and ext/wild bits
	PUSHJ P,STWILD		;make omitted filename wild, and maybe ext too
	MOVE B,FSEXT(W)
	ANDI	B,ALLPRJ+ALLPRG		;SELECT ONLY THE PPN BITS.
	SKIPN	A,FSPPN(W)		;PICKUP ANY EXPLICIT PPN
	JUMPE	B,RSTG2A		;JUMP IF THERE IS NO EXPLICT BITS
	MOVEM	A,STKPPN		;SAVE NEW STICKY PPN
	MOVEM	B,STKBIT		;SAVE STICKY BITS
	JRST	RSTG2B

RSTG2A:	MOVE	A,STKPPN		;GET STICKY PPN
	MOVEM	A,FSPPN(W)
	HRRZ	B,STKBIT
	IORM	B,FSEXT(W)		;SAVE STICKY BITS HERE TOO

RSTG2B:	ADDI	W,FSLEN			;INCREMENT W
	CAML	W,FSPTR			;ARE WE DONE?
	JRST	RSTG3			;YES.
	SKIPE	A,FSDEV(W)		;PICKUP DEVICE NAME
	CAMN	A,MTDEV			;EXPLICIT DEVICE 
	JRST	RSTG2			;NO DEVICE, OR SAME DEVICE
	OUTSTR	[ASCIZ/Multiple source devices.
/]
	JRST	RESTAR

CMPDFT:	SKIPA A,[ALLFIL+ALLEXT+ALLPRJ+ALLPRG] ;assume dsk:*.*[*,*] for COMPARE
RSTDFT:	MOVEI A,ALLFIL+ALLEXT	;assume dsk:*.*[current user] for RESTORE
	SETZM RSTDEV-1		;kluge
	SKIPN R,DEST		;was there any destination given?
	MOVEI R,RSTDEV-1	;kluge to zero rstdev block
	MOVSI R,(R)		;source of blt
	HRRI R,RSTDEV		;destination
	BLT R,RSTPPN		;do the transfer
	SKIPN DEST		;was there explicit dest term?
	MOVEM A,RSTEXT		;no. set *.* flags
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              subttl more restore, compare code	; RSTG3 RSTG3A RSTG4A RSTG4 RSTG5 RSTG5A RSTG5B RSTG5C RSTG50 RSTG51 RSTG6 RSTG66 RST5DD RST5DZ RST5DE RSTG7 RSTG77 RSTG99

RSTG3:	PUSHJ P,MTINIR		;INIT THE MAGTAPE DEVICE, just reading
	PUSHJ P,MTANOP		;DO A MTA NO-OP TO DETECT FRONT OF TAPE
	MOVEI A,10		;DEVICE MODE
	xct r.comp(k)		;skip unless doing compare
	 movei a,410		;avoid updating ref date in compare (long block lookup)
	SKIPN B,RSTDEV		;GET THE DESTINATION DEVICE
IFE FTHELP,<
	MOVSI B,'DSK'		;NONE THERE. USE DISK
>;IFE FTHELP
IFN FTHELP,<
	JRST [	OUTSTR [ASCIZ/
Using destination device 'RSK' (not 'DSK').

/]
		MOVSI B,'RSK'	;NONE THERE. USE DISK
		JRST .+1]
>;IFN FTHELP
	MOVEM B,RSTDEV		;SAVE
	MOVSI C,FOBUF		;NO BUFFERS
	xct r.comp(k)		;skip unless doing compare
	 movei c,fibuf		;input buffer header
	TLZ FL,UDPGO		;ASSUME NOT UDP

	MOVE D,B		;GET DEVICE NAME
IFN STANSW,<
	PNAME D,		;get physical name of device
	 JRST NOTDSK		;no such device
	CAMN D,['NUL   ']	;allow null device as well as disk
	JRST RSTG3A		;null device OK
>;IFN STANSW
	DEVCHR D,
	TLNE D,DEVDSK
	JRST RSTG3A		;IS A DISK
IFE UDPSW,<
	JRST NOTDSK
>;IFE UDPSW
IFN UDPSW,<
	TLNN D,DEVUDP		;IS THIS A UDP?
	JRST NOTDSK		;NO.
	INIUDP B		;INITIALIZE UDP
	TLO FL,UDPGO
	UOPEN FILE,A		;DO THE OPEN
>;IFN UDPSW

RSTG3A:	OPEN FILE,A		;ATTEMPT TO OPEN OUTPUT DEVICE
	 PUSHJ P,NODEV		;OOPS.
IFN UDPSW,<
	TLNE FL,UDPGO		;SKIP unless UDP
	jrst RSTG4a		;no buffers for UDP
>;IFN UDPSW
	xct r.comp(k)		;skip unless doing compare
	 jrst [	inbuf file,nbufs ;compare needs input buffers, not output
		jrst RSTG4a]
	OUTBUF FILE,nbufs	;TELL SYSTEM TO BUILD US SOME BUFFERS
RSTG4A:	SETZM TLISTC		;don't stop unless see ESC I
RSTG4:	XCT R.REGP(K)		;SKIP unless PRESTORE
	 XCT R.EMPT(K)		;PRESTORE, SKIP IF NO TERMS LEFT
	  JRST .+2		;SKIP IF NORMAL RESTORE OR STILL TERMS LEFT
	   JRST RSTG7		;USED UP PRESTORE TAPE FINDING NOTHING!
	PUSHJ P,RDFIL		;READ RETRIEVAL FROM MTAPE
	 JRST .-1		;saw a tape header/trailer, keep going
	TRNE FL,MTAEOT		;SKIP UNLESS logical END OF TAPE
	JRST RSTG99

	PUSHJ P,DPYSER		;DISPLAY FILE NAME FROM THE TAPE
	 FILINF+DDNAM,,DPYFIL

	MOVEI W,TBASE
	MOVEM W,LASTW		;SETUP BACK LINK FOR PRESTORE
	SETZM PREALW		;CLEAR SAVED BLOCK FOR PRESTORE
	SETZM PRLSTW
	SETZM PMULTF		;CLEAR MULTIPLE-MATCH FLAG
	MOVE W,TBASE		;GET THE BASE OF TERM BLOCK.
RSTG5:	XCT R.NULP(K)		;IF PRESTORE, TEST FOR USED UP BLOCK
	 JRST RSTG6		;YES.  (XCT DOES CAIA FOR NORMAL RESTORE)
	HRRZ X,FSEXT(W)		;GET FLAGS
	TRNE X,ALLFIL		;ANY FILE?
	JRST RSTG5A		;YES. SKIP MATCH
	MOVE Y,FSNAM(W)		;GET THE NAME
	CAME Y,FILINF+DDNAM	;SAME AS MAGTAPE NAME?
	XCT R.DIFF(K)		;NO. NO MATCH WITH THIS TERM.
RSTG5A:	TRNE X,ALLEXT		;WILD EXTENSION?
	JRST RSTG5B		;YES.
	HLLZ Y,FSEXT(W)		;GET EXT FROM THIS TERM
	HLLZ Z,FILINF+DDEXT	;GET EXT FROM MT
	CAME Y,Z		;SAME AS MAG TAPE EXTENSION?
	JRST [	TRNE X,GOTEXT	;skip if no explicit extension
		JRST RSTG6	;explicit extension didn't match
		XCT R.DIFF(K)	;no match unless ADVANCE TO cmd
		JRST .+1]	;no extension and ADVANCE TO cmd, consider wild
RSTG5B:	TRNE X,ALLPRJ		;ANY PROJECT?
	JRST RSTG5C		;YES.
	HLLZ Y,FSPPN(W)		;GET PROJECT NAME
	HLLZ Z,FILINF+DDPPN	;GET MT PROJECT NAME
	CAME Y,Z
	XCT R.DIFF(K)		;NO. NO MATCH WITH THIS TERM.
RSTG5C:	TRNE X,ALLPRG		;ANY PROGRAMMER
	JRST RSTG50		;YES.
	HRRZ Y,FSPPN(W)
	HRRZ Z,FILINF+DDPPN
	CAME Y,Z
	XCT R.DIFF(K)		;NO. NO MATCH WITH THIS TERM.
RSTG50:	SKIPN Y,FSTAP(W)	;is there a rel dump number or date specified?
	JRST RST5DD		;no, this is a complete match
	MOVE Z,INVERS		;get tape format number
	CAIGE Z,IOVER3		;skip if later tape format
	JRST RST5DD		;early format, only one dump per tape, allow match
	TRNN Y,DATMSK		;given date?
	JRST RSTG51		;no, must be dump number
	ANDI Y,DATMSK		;just date
	LDB Z,[POINT 3,FILINF+DDEXT,20] ;get file's high date bits
	LDB A,[POINT 12,FILINF+DDPRO,35] ;get file's low date bits
	DPB Z,[POINT 3,A,23]	;combine high and low date bits in A
	CAILE A,(Y)		;is tape file's date on or before requested date?
	XCT R.DIFF(K)		;no, no match
	JRST RST5DD		;yes, we have a match

;Here to check dump number requested and that in file read from tape.
RSTG51:	LDB Z,[POINT RDHBTS,Y,RDHPOS] ;get high bits of dump number requested
	LDB Y,[POINT RDLBTS,Y,RDLPOS] ;get low bits of same
	DPB Z,[POINT RDHBTS,Y,35-RDLBTS] ;combine dump number parts
	HLRZ Z,SRCDEV+LL3DMP-1	;get rel dump number of file on tape
	CAIE Y,(Z)		;rel dump numbers the same?
	XCT R.DIFF(K)		;no, no match
	JRST RST5DD		;WIN. DUMP FILE RETURN TO RSTG7 OR RSTG4

;Here if file didn't match term.
RSTG6:	MOVEM W,LASTW		;SAVE BACK POINTER FOR PRESTORE
	XCT R.NXT(K)		;POINT TO NEXT TERM
	XCT R.END(K)		;IS THIS OVERRUN YET?
	 JRST RSTG5		;NO. CONTINUE LOOKING THRU TERM BLOCKS
	SKIPE PREALW		;NO MORE TERMS.  ANY FOUND FOR PRESTORE?
	JRST RST5DZ		;YES, DO THE PRESTORE NOW

	xct r.comp(k)		;skip unless doing compare
	 jrst RSTG66		;don't stop comparison on ESC I
	AOSN SAWEOF		;skip if haven't seen eof
	SOSE TLISTC		;want to stop here (ESC I seen)?
	JRST RSTG66		;don't stop
	PUSHJ P,STOPIT		;stop here
	XCT R.REGP(K)		;skip unless PRESTORE command
	 JRST PRPOSN		;wants to interrupt to re-position the tape
	JRST RSTG77		;quit, as if finished

RSTG66:	PUSHJ P,RDFILX		;FLUSH THROUGH THE END OF THIS FILE
	TRNE FL,MTAEOT		;SKIP UNLESS EOT
	JRST RSTG99		;logical EOT, ask for another tape
	JRST RSTG4		;LOOK FOR ANOTHER FILE ON THE TAPE

;Here if file DOES match term.
RST5DD:	XCT R.FIND(K)		;skip unless positioning tape
	 JRST POSWIN		;we found the file, now back up to its beginning
	XCT R.REGP(K)		;FOUND A MATCH, SKIP unless PRESTORE
	 SKIPA Y,LASTW		;PRESTORE, SAVE MATCH AND KEEP LOOKING
	  JRST RSTG5D		;NORMAL RESTORE, GO DO IT
	SKIPN PREALW		;HAVE WE ALREADY SAVED ONE?
	JRST RST5DE		;NO, SAVE THIS ONE
	SETOM PMULTF		;YES, FLAG THAT WE NEED THIS FILE AGAIN
RST5DZ:	MOVE Y,PRLSTW		;RESTORE THE FIRST ONE WE FOUND
	MOVEM Y,LASTW
	MOVE W,PREALW
	SETZM PREALW		;DON'T LOOP INFINITELY IF SAFETY LOOKUP
	SETZM PRLSTW		;  FAILS
	JRST RSTG5D		;GO DO THE RESTORE

RST5DE:	MOVEM Y,PRLSTW		;FIRST MATCH, SAVE IT
	MOVEM W,PREALW
	JRST RSTG6		;CONTINUE SCAN

RSTG7:	XCT R.REGP(K)		;SKIP unless PRESTORE
	 PUSHJ P,MTAREW		;PRESTORE, REWIND THE TAPE
RSTG77:	RELEAS FILE,		;RELEASE DESTINATION DEVICE
IFN UDPSW,<
	TLZE FL,UDPGO
	SETZM USYNC		;MAKE SURE WE CAN'T DIDDLE THE UDP
>;IFN UDPSW
	PUSHJ P,MTAREL		;RELEASE SOURCE DEVICE
	TRZ FL,SAFETY
	POPJ P,

RSTG99:	XCT R.FIND(K)		;skip unless positioning tape
	 JRST POSLUZ		;failed to position tape
	PUSHJ P,MTAREW
	TRZ FL,MTAEOT
	XCT R.REGP(K)		;SKIP unless PRESTORE
	 JRST RSTG77		;PRESTORE, RETURN WITH FILE NOT FOUND
	OUTSTR [ASCIZ/Mount the next tape and type return to proceed.
Type altmode to return to command level.
/]
	CLRBFI
	INCHWL A
	CAIN A,ALTMOD
	JRST RSTG7
	PUSHJ P,MTACLZ
	JRST RSTG4		;GO READ MORE.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            subttl restore/compare	actually move a file here. ; RSTG5D RSTG5E RSTPRE RSTG5H RSTG5G RSTG5I RSTG5n RSTG5G RSTG5W RSTG5X RSTG5F PFILEX RSTG6A PSTKIL PREKIL

RSTG5D:	TRNE X,ALLMSK		;SKIP IF THERE IS NO WILDNESS.
	JRST RSTG5E		;WILD TERM. DO NOT FLUSH TERM.
	XCT R.BLT(K)		;JUMPS OFF IF PRESTORE
	MOVNI X,FSLEN		;LOAD - LENGTH OF BLOCK.
	ADDB X,FSPTR		;SHRINK TERM BLOCK STORAGE
	MOVSI Z,(X)		;SOURCE OF BLT
	HRRI Z,(W)		;DESTINATION
	BLT Z,FSLEN-1(W)	;BLT LAST TERM DOWN ONTO THIS ONE.
RSTG5E:	HRRZ X,@R.EXT(K)	;GET THE WILD FLAGS INTO X FROM RESTORE SIDE
	MOVE A,FILINF+DDNAM	;SET UP THE DEFAULTS
	MOVE B,FILINF+DDEXT
	MOVE C,FILINF+DDPRO
	MOVE D,FILINF+DDPPN
	TRNN X,ALLFIL		;IS RESTORE FILE NAME WILD?
	MOVE A,@R.NAM(K)	;NOT WILD WE TAKE THIS NAME.
	TRNN X,ALLEXT		;IS RESTORE EXTENSION WILD?
	HLL B,@R.EXT(K)		;NOT WILD, TAKE THIS EXTENSION.  DATE75
	TRNN X,ALLPRJ		;IS PROJECT WILD?
	HLL D,@R.PPN(K)		;NO. SLURP THIS UP.
	TRNN X,ALLPRG		;IS PROGRAMMER WILD?
	HRR D,@R.PPN(K)		;NO. SLURP IT UP.
	xct r.comp(k)		;skip unless doing compare
	 jrst RSTG5g
IFE STANSW,<
	PUSHJ P,RSTPRE		;MAKE SUBR SO MRESTORE CAN USE
	 JRST RSTG6A		;don't restore file after all
	JRST RSTG5G

RSTPRE:	MOVEM A,LKBLK+.RBNAM
	MOVEM B,LKBLK+.RBEXT
	MOVEM C,LKBLK+.RBPRV
	MOVEM D,LKBLK+.RBPPN
>;IFE STANSW
	MOVE X,[A,,FILBLK]	;SAVE THE FILE NAME SOMEWHERE.
	BLT X,FILBLK+3		;SAVE..
	TRO FL,SAFETY
IFN UDPSW,<
	TLNE FL,UDPGO		;ON THE UDP?
	ULOOK FILE,A		;YES. ASK RPH
>;IFN UDPSW
	LOOKUP FILE,A		;LOOK UP THE FILE.
	 JRST .+2		;LOOKUP FAILURE IS A GOOD WAY TO START
	HRRI B,-1		;THIS IS LOOKUP SUCCESS CODE.
	TLNN FL,UDPGO
	CLOSE FILE,NUPACC	;AVOID BEING IN READ/ALTER MODE
	XCT R.SAFE(K)		;CHECK THE OMENS.
IFN STANSW,<
	 JRST RSTG6A		;FOR SOME REASON, DON'T RESTORE.
>;IFN STANSW
IFE STANSW,<
	 POPJ P,
>;IFE STANSW
	TRZ FL,SAFETY
	MOVE D,[FILBLK,,A]
	BLT D,D
IFN STANSW,<
IFN UDPSW,<
	TLNE FL,UDPGO		;SKIP UNLESS THIS IS ENTER ON UDP
	JRST RSTG5H		;ENTER ON UDP. DON'T CLEAR PROTECT
>;IFN UDPSW
	SETZ C,			;MAKE SURE WE DON'T PROTECT IT TOO MUCH
	JRST RSTG5G		;GO DO DISK ENTER
IFN UDPSW,<
RSTG5H:	SKIPN PASFLG		;HAS THERE BEEN A PASSWORD CHECK?
	PASCHK			;NO. DO IT. RETURN WHEN IT'S OK
	UENTER FILE,A
IFN FTHELP,<.FATAL Fix the unlikely case of UDPSW and FTHELP here and at MTRM1.>
>;IFN UDPSW
RSTG5G:
IFN FTHELP,<
	xct r.comp(k)		;skip unless doing compare
	 jrst rstg5i		;compare -- don't worry about different units
	PUSHJ P,NXTUNT		;tell system we want next file on next disk unit
	PUSH P,D+1
	PUSH P,D+2
	GETSTS FILE,D+1
	PUSH P,D+1		;save a UUO later, remember status
	TRO D+1,400		;make us use long-block enter
	SETSTS FILE,(D+1)
	HRR B,FILINF+DDEXT	;and creation/date and hi date bits
	MOVE C,FILINF+DDPRO	;get real protection/date word from retrvl
	MOVE D+1,FILINF+DREFTM	;extra words for long-block enter: ref date
	MOVE D+2,FILINF+DDMPTM	;  and dump date
RSTG5I:	SETOM HENTOK		;assume ENTER will skip
>;IFN FTHELP
	xct r.comp(k)		;skip unless doing compare (note: long-block lookup)
	 jrst [	move x,[a,,filblk] ;save the file name somewhere
		blt x,filblk+3
		setzm supcmp	;not suppressing comparison yet for this file
		hllzs diffgo	;no differences found for this file yet
		inskip		;clear ^O
		 jfcl
		lookup file,a	;doing compare, not restore -- read file (clob W,X)
		 jrst .+2	;failed, take direct return as from ENTER below
		jrst .+3]	;success, take skip return as if from ENTER below
	ENTER FILE,A		;create destination file
IFN FTHELP,<
	 SETZM HENTOK		;didn't skip, remember that
	POP P,D+1		;old status
	SETSTS FILE,(D+1)	;turn off 400 bit
	skipn hentok		;don't bother w/special words if ENTER failed
	jrst RSTG5n
	MTAPE FILE,[	'GODMOD' ;set special 4 words back the way they use to be
			11
			FILINF+DQINFO]
	 JRST [	OUTSTR [ASCIZ/Lost trying to restore the 4 info words!
/]
		JRST 4,.]
RSTG5n:	POP P,D+2
	POP P,D+1
	SKIPN HENTOK		;skip if ENTER skipped
>;IFN FTHELP
>;IFN STANSW
IFE STANSW,<
	MOVE A,FILINF+DQVER
	MOVEM A,LKBLK+.RBVER
	SETZM LKBLK+.RBSPL
	MOVE A,FILINF+DDLNG
	ADDI A,177
	LSH A,-7
	MOVEM A,LKBLK+.RBEST
	SETZM LKBLK+.RBALC
	SETZM LKBLK+.RBPOS
	SETZM LKBLK+.RBFT1
	MOVE A,FILINF+DDMPTM
	MOVEM A,LKBLK+.RBNCA
	SETZM LKBLK+.RBMTA
	SETZM LKBLK+.RBSTS
	MOVE A,FILINF+DQAUT
	MOVEM A,LKBLK+.RBAUT
	JRST CPOPJ1

RSTG5G:	ENTER FILE,LKBLK
>;IFE STANSW
	 JRST [	movei d,[asciz/ENTER failed -- /]
		xct r.comp(k)           ;skip unless doing compare
		 movei d,[asciz/LOOKUP for compare failed -- /]
		outstr (d)
		movei c,(b)		;just the error code
		caile c,nflers		;make sure we're in range
		movei c,nflers
		outstr @filetb(c)	;say why we lost
;;		OUTSTR [ASCIZ/ENTER failed: /]
		MOVE D,[FILBLK,,A]
		BLT D,D
		PUSHJ P,TYFIL
		pushj p,rdfilx	;skip over rest of file on tape
		JRST RSTG5F]
IFN STANSW,<
	MOVE D,INVERS		;GET THE TAPE VERSION NUMBER
	MOVE W,FILINF+DDOFFS	;GET THE NEEDED OFFSET.
	CAIL D,IOVER2		;DART VERSION 4 (FORMAT 2) HAS THIS KLUGE
	CAIG W,1		;OTHER THAN NORMAL?
	movei w,1		;normal offset
;;	JRST RSTG5X		;EARLY VERSION OR NORMAL FILE.
	xct r.comp(k)		;skip unless doing compare
	 pushj p,cmplen		;type filename, compare file info, ALWAYS SKIPS
	  CAIG W,1		;OTHER THAN NORMAL?
	JRST RSTG5X		;EARLY VERSION OR NORMAL FILE or compare
	TLNE FL,UDPGO
	JRST RSTG5W
	MOVEM W,WROFFS+2	;SET FOR WRITE OFFSET UUO.
	MTAPE FILE,WROFFS	;WRITE THE FILE OFFSET
	MOVEI W,2
	SUB W,FILINF+DDOFFS
	USETO FILE,(W)
	;JJW 9/85 USETO changes the output byte count from 0 to 200, which must be
	;accounted for since we haven't yet stored the first word into the buffer.
	AOS FOBUF+2		;Fix count in buffer header
	JRST RSTG5X

RSTG5W:	OUTSTR [ASCIZ/UDP OUTPUT FILE WILL NOT HAVE RECORD OFFSET
/]
>;IFN STANSW
RSTG5X:	MOVE D,[FILBLK,,A]
	BLT D,D
IFN FTHELP,<
	SETOM RSTUFD		;assume restoring a UFD
	PUSH P,B
	HLRZ B,B		;extension
	CAIN B,'UFD'		;is this a UFD
	CAME D,['  1  1']
	SETZM RSTUFD		;not a UFD
	CAME A,['RMDSYS']	;avoid compressing these UFDs during restore
	CAMN A,['RM2SYS']
	HRRZS RSTUFD		;for these UFDs, make RSTUFD positive
	POP P,B
	SETZM UFDCNT		;init UFD-entry wd count to beginning of entry
>;IFN FTHELP
	SETOM PFDRIP		;flag file-data-read in progress, for PRPOSN
	xct r.comp(k)		;skip unless doing compare
	 pushj p,rfcomp		;go do the compare, and always double skip
	  PUSHJ P,TYFIL		;TYPE A FILE NAME (not if compare)
	  PUSHJ P,RFDATA	;GO DO THE RESTORE (not if compare)
IFN STANSW,<
	TLNN FL,UDPGO
	xct r.comp(k)		;skip unless doing compare
	 JRST RSTG5F		;AVOID RENAME IF UDP or compare
	MOVE D,[FILBLK,,A]
	BLT D,D
	TLZ C,400000		;AVOID RESTORING WITH PROT=400
IFE FTHELP,<
	RENAME FILE,A		;RENAME TO OLD CREATION DATE
	 OUTSTR [ASCIZ/ (RENAME TO UPDATE DATE OF CREATION FAILED) /]
>;IFE FTHELP
>;IFN STANSW
RSTG5F:	SETZM PFDRIP		;file no longer open
	XCT R.POST(K)		;if PRESTORE, call PSTKIL to flag term done
	OUTSTR CRLF
	SKIPE PMULTF		;NEED THIS FILE AGAIN FOR PRESTORE?
	PUSHJ P,MTABKF		;YES, RE-READ IT
	SETZM PMULTF
	MOVE W,TBASE		;GET BEGINNING OF TERM LIST
	XCT R.EMPT(K)		;SKIP IF NO TERMS LEFT IN LIST
	JRST RSTG4		;GO PROCESS MORE.
	JRST RSTG7		;THERE ARE NO MORE TERMS

REPEAT 0,<			;code to really link out the term
	MOVE X,LASTW		;GET TERM WHICH LINKED TO THIS ONE
	HRRZ Z,(X)		;DOUBLE CHECK THAT IT POINTS HERE
	CAIE Z,(W)		; (NOTE THAT THIS CODE MUST NOT LOSE W)
	JRST RSTG5E		;NO, DO NOTHING
	HRRZ Z,(W)		;GET LINK OF THE DEAD TERM
	HRRM Z,(X)		;LINK DEAD ONE OUT
	JRST RSTG5E		;REJOIN REGULAR RESTORE
>;REPEAT 0

PFILEX:	MOVEI B,(B)		;GET JUST ERROR CODE
	JUMPE B,CPOPJ1		;SKIP RETURN IF FILE NOT FOUND
	MOVNI A,2		;ERROR CODE FOR ALREADY EXISTS
	HRLM A,FSPREQ(W)	;MUST BE NEGATIVE
	POPJ P,

RSTG6A:	XCT R.POST(K)		;if PRESTORE, call PSTKIL to flag term done
	JRST RSTG6		;not restoring file after all

PSTKIL:
	HRROS FSPREQ(W)		;FLAG TERM AS ALREADY RESTORED
	SOS TRMCNT		;COUNT DOWN HOW MANY TO GO
	POPJ P,

PREKIL:
;	HRROS FSPREQ(W)			;FLAG TERM AS ALREADY RESTORED
;	SOS TRMCNT			;COUNT DOWN HOW MANY TO GO
	JRST RSTG5E
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ;compare -- compare file header info ; cmplen cmple2 RFCOMP RFCM0 RFCM1 RFCM1A RFCM2 RFCMER RFCMCN RFCMEE RFCM3 RFCM5 RFCM6 DDFCOM DDFCM2 DDFCM1 cmpend cmpen2

;Here when doing a COMPARE, after disk lookup has been successful.
;Type filename, then compare file lengths, etc.
;Here with W holding offset of file from tape (Normal = 1).
;This routine always skips.
cmplen:	aos (p)			;always skips
	mtape file,rdoffs	;read disk offset from comparison file
	useti file,400000	;make sure we read from phys beginning of file
	push p,a		;Save data returned by LOOKUP
	push p,b
	push p,c
;;	push p,d		;;ignore file length -- it's in MTAPE block
	move d,filblk+3 	;get back PPN
	pushj p,tyfil		;type the disk filename -- lookup was successful
	outchr [" "]
;;	pop p,d
	pop p,c
	pop p,b
	pop p,a
	mtape file,[	'GODMOD' ;read special 4 words from disk
			10
			cminfo]
	 jrst [ outstr [asciz/Failed to read 4 info words in file compare!
/]
		jrst 4,.]
	move d,rdoffs+3		;get physical length of file just opened
	came d,filinf+ddlng	;file length as expected?
	pushj p,cmpfll		;no, report dif
	came c,filinf+ddpro	;compare pro/date/time word
	pushj p,cmpflp		;report difference in protection word
	hrrz c,b		;disk file's creation half word
	andi c,700000		;just high date written bits
	hrrz d,filinf+ddext	;tape file's creation half word
	andi d,700000		;just high date written bits
	came c,d		;must be memory comparison, in case of difference
	pushj p,cmpflc		;report different in creation dates
	movsi d,-4		;aobjn for comparing 4 special words
cmple2: move c,cminfo(d)	;get data from disk file
	came c,filinf+dqinfo(d)	;compare with data from tape
	pushj p,cmpfls		;report difference
	aobjn d,cmple2		;loop for special words
	came w,rdoffs+2		;compare disk file's offset with tape's version
	pushj p,cmpflo		;report the difference
	popj p,

;Here to compare data from a file on tape with data from a file on the disk.
;This code is a modified version of RFDATA.
;Here we always take double skip return.
RFCOMP:	AOS (P)
	AOS (P)			;always double skip
	MOVE A,SRCTST+LEDONE	;check test word of all ones
	PUSHJ P,TSTONE		;test word for all ones
	SKIPE A,SRCTST+LEDZER	;check test word of all zeroes
	PUSHJ P,TSTZER		;test word for all zeroes
RFCM0:	SOSGE IWC		;READ ONE FILE DATA WORD FROM TAPE
	JRST RFCM1		;WC EXHAUSTED
	PUSHJ P,TREADW		;READ DATA
	XORM A,CHKSUM
	SKIPN SUPCMP		;skip if suppressing further comparison
	PUSHJ P,DDFCOM		;compare tape data word with word from disk
	SOS FSIZE		;DECREMENT THE FILE SIZE FROM TAPE
	JRST RFCM0		;continue reading data

RFCM1:	PUSHJ P,RERDAT		;read any error data for this file
	SKIPLE FSIZE		;don't type out prev media data till done
	JRST RFCM1A
	SKIPE TAPERR-REDERR+MEDERR ;see if any previous media errors
	PUSHJ P,TYPMER		;report previous media errors
RFCM1A:	PUSHJ P,TREADW		;read checksum word
	XORB A,CHKSUM
	JUMPE A,RFCM2		;CHECKSUM IS OK.
	PUSHJ P,ICKBAD		;report bad checkum
RFCM2:	SKIPG FSIZE		;ARE WE DONE?
	JRST RFCM3		;YES.
	PUSHJ P,TREADY		;READ THE WC FROM NEXT RECORD
	TRNE FL,MTAEOT		;skip unless hit premature logical EOT
	JRST RFCM3		;already told user, just truncate the file
	PUSHJ P,FMTCHK		;check format of expected file-continuation wd-cnt
	 JRST RFCMER		;bad format, assume data word, try to recover
	 PUSHJ P,RFDB2S		;file cont block, but MT buffer is short (MT lost)
	 JRST RFCMCN		;continuation-block, all OK
	 JFCL			;file start block with too-short buffer
;looks like a new file or hdr/trlr, end file here, prematurely
	PUSHJ P,RDFLX1		;backup the input byte pointer and byte count
	PUSHJ P,CHKFAK		;Skip IF filename is fake generated during tape copy.
	 SKIPE TOOSHR-REDERR+MEDERR ;if prev media file was too short, old error
	CAIA			;file too short is old error
	PUSHJ P,RFDT22		;report new error
	SKIPE TAPERR-REDERR+MEDERR ;see if any previous media errors
	PUSHJ P,TYPMER		;report previous media errors
	JRST RFCM3		;close the file as if normal end

;Here if found garbage instead of expected file-continuation block word count.
RFCMER:	MOVE A,FSIZE		;amount of file still unread from tape
	MOVEM A,IFSIZE		;this is the max size this new data block could be
	MOVSI A,300000		;force an error in next routine with huge wd cnt
	PUSHJ P,IWCCHK		;check validity of the input word count in A
	 JRST RFCMEE		;no room in buffer for any data!  read new buffer
	 PUSHJ P,BADIWC		;XCT'd: not a valid word-count word, try to recover
	;now assume we've got a continuation block
;Here with continuation block for the current file.
RFCMCN:	CAMLE A,FSIZE		;make sure no more data than file supposed to have
	PUSHJ P,RFDT2L		;word count is longer than remaining file size
    pushj p,iwcdbg		;make sure RH A isn't negative or otherwise bad
	HRRZM A,IWC
	PUSHJ P,DBLOG4		;log wd cnt word in circular buffer for debugging
;;;	SETZM CHKSUM	;;;now done by IWCCHK
	JRST RFCM0

RFCMEE:	[ASCIZ/
%%% At RFCMER with no room for any data in current buffer.
%%% Find a wizard.
/]
	HALT .

;Here when input tape's file has been completely read in.
RFCM3:	xct r.comp(k)		;skip unless doing compare
	 pushj p,cmpend		;make sure disk file has ended too
	SKIPN TAPERR-REDERR+MEDERR ;skip if any previous media errors
	SKIPE TAPERR		;skip if no errors in this file
	PUSHJ P,CKPAUS		;make sure user knows of errors
IFN UDPSW,<
	TLNE FL,UDPGO		;IS THIS THE UDP?
	JRST RFCM5		;YES. CLOSE IT.
>;IFN UDPSW
	CLOSE FILE,NUPACC
	STATZ FILE,740000
	 PUSHJ P,RFCM6		;ERROR.
	POPJ P,

IFN UDPSW,<
RFCM5:	UCLOSE FILE,
	POPJ P,
>;IFN UDPSW

RFCM6:	OUTSTR [ASCIZ/ Disk read error.   Status = /]
	PUSH P,A
	GETSTS FILE,A
	PUSHJ P,DISLOC
	OUTSTR [ASCIZ/
Type CONTINUE to go on./]
	EXIT 1,
	POP P,A
	POPJ P,
	
DDFCOM:	SKIPGE FIBUF+2		;skip unless EOF already
	JRST DDFCM2		;return zeroes for EOF
	SOSG FIBUF+2
	PUSHJ P,DDFCM1		;read a record, skip if EOF
	 CAIA			;not EOF
DDFCM2:	TDZA B,B		;no, must have been end of file, return zeroes
	ILDB B,FIBUF+1		;get disk data
	CAME B,A		;compare tape data with disk data
	PUSHJ P,CMPFLD		;report difference
	POPJ P,

DDFCM1:	INPUT FILE,
	STATZ FILE,740000
	 PUSHJ P,RFCM6
	STATZ FILE,IOEOF
	 AOS (P)		;skip for EOF
	POPJ P,

;Here when file on tape has ended.
;See if disk file still has any nonzero data left after this point.
cmpend:	skipe supcmp		;skip unless disk data differed already
	popj p,			;we already reported a disk data difference
	sosg fibuf+2		;skip if there's disk data left in buffer
	pushj p,ddfcm1		;see if there's another record to read
	 jrst cmpen2		;disk has more data than file on tape
	popj p,			;end of disk file as well as file on tape

cmpen2:	ildb b,fibuf+1		;get disk data
	came b,[0]		;skip if data is zero (must be memory compare)
	pushj p,cmpfle		;report disk file with nonzero extended data
	jrst cmpend		;loop for more disk data
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ;compare -- report a difference ; cmpfll cmpfls cmpflo cmpfld cmpfle cmpflp cmpflc cmpfi0 cmpask cmpgo cmpfi3 diffgo supcmp

;Here from COMPARE command when some difference is detected between file
;from tape and file from disk.  Instruction preceding call is comparison
;that failed.

cmpfll:	push p,[[asciz/file length/]]
	jrst cmpfi0

cmpfls:	push p,[[asciz/special info word/]]
	jrst cmpfi0

cmpflo:	push p,[-1,,[asciz/file offset/]]
	jrst cmpfi0

cmpfld:	push p,[[asciz/file data/]]
	setom supcmp	;suppress comparison after this file data word difference
	jrst cmpfi0

cmpfle:	push p,[[asciz/nonzero disk file data beyond end of file on tape/]]
	setom supcmp	;suppress comparison after this file data word difference
	jrst cmpfi0

cmpflp:	push p,[[asciz\pro/date/time word\]]
	jrst cmpfi0

cmpflc:	push p,[[asciz/high bits of date written/]]
	jrst cmpfi0

;left half of top of stack is:
;  0 if comparison had disk data in AC, tape data in memory
;  -1 if comparison had tape data in AC, disk data in memory
cmpfi0:	exch a,(p)	;start saving ACs, just above return addr, get flag,,text
	push p,b
	push p,c
	push p,a	;save flag,,text ptr
	push p,-4(p)	;copy return address
	sos (p)		;make address of comparison instruction
	sos (p)		; by decrementing return addr twice
	push p,@(p)	;save comparison instruction (a,b,c,text,adr,instr)
	ldb a,[point 4,(p),12] ;get AC field from comp instr
	push p,a	;save AC field (a,b,c,text,adr,instr,AC)
	move a,-6(p)	;restore A, in case it's the AC or index of instruction
	push p,@-1(p)	;save memory contents referenced by comp instruction
	move a,@-1(p)	;pick up the AC contents reference in the comparison
	pop p,b		;get memory contents from comparison
	sub p,[3,,3]	;discard AC, instruction, and ptr to it (leaves a,b,c,text)
	skipge c,(p)	;skip unless comparison had tape data in AC
	exch a,b	;put disk data in A, tape data in B
	movem b,(p)	;save tape data (over text ptr: a,b,c,tape)
	outstr [asciz/Difference detected in /]
	outstr (c)
	outstr [asciz/:
   Disk data is /]
	pushj p,typoch	;type octal halfwords
	outstr [asciz/ 	Tape data is /]
	pop p,a		;tape data
	pushj p,typoch	;type octal halfwords
	outstr crlf
	skipe diffgo	;skip if this is first difference in this file
	jrst cmpfi3
cmpask:	outstr [asciz/	GO<return> continues without any pauses.
	<return> continues scan.  /]
;	SUP<return> suppresses comparison of file data (as does ESC 3 I).
;	setzm supcmp	;don't suppress data comparison yet
	pushj p,getwrd	;get response word in sixbit
	hllos diffgo	;flag a diff seen
	jumpe a,cmpfi3	;jump if plain CR, LF or ALT.
	camn a,['GO    ']
	jrst cmpgo
;	came a,['SUP   ']
	jrst cmpask
;	setom supcmp	;suppress comparison of file data
;	jrst cmpfi3

cmpgo:	setom diffgo	;GO<cr> -- don't stop to ask in future
cmpfi3:	pop p,c
	pop p,b
	pop p,a
	popj p,

;no diffs of file yet	0,,0
;some diffs of file	x,,-1
;don't stop on diffs	-1,,x
diffgo:	0		;flag as described above
supcmp:	0		;nonzero to suppress comparison of disk file's data
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ;tape copy -- save statistics ; PDSTAT PADST1 PADST2 UPSTAT UPSTEE UPSTA0 UPSNEW

;Pad the stats buffer out with null(s) to end of a word.
PDSTAT:	MOVE A,STATBP		;save byte pointer to where the summary line starts
	MOVEI B,0
	JRST PADST2

PADST1:	SOS STATFR		;count one less free byte in buffer
	IDPB B,A		;pad to end of word with null
PADST2:	TLNE A,760000		;end of word?
	JRST PADST1		;no, append some null(s)
	MOVEM A,STATBP		;save updated byte ptr
	POPJ P,

;Append statistics to ends of files.  Here on end of input tape in tape copy.
;We write to the files STATS.TOT (all stats) and STATS.LST (summary lines).
;When a file is busy, we increment the extension repeatedly until we win.
;Note: We don't bother overwriting nulls at the ends of the files, so you
;should probably burp the files now and then.
;Clobbers A,B,C,W,X,Y,Z.
UPSTAT:	MOVEI A,17		;open channel in dump mode
	MOVSI B,'DSK'
	MOVEI C,0
	OPEN STATCH,A		;open channel for statistics
	 PUSHJ P,NODEV		;failed!
	MOVEI A,STATLN		;number of chars the buffer holds
	SUB A,STATFR		;  minus number left empty is number of chars
	ADDI A,4		;round up to whole words (unnecessary, as padded)
	IDIVI A,5		;calculate number of words of stats text
	PUSH P,A		;save word count
	MOVEI B,STATBF		;place where stats start
	MOVSI X,'TOT'		;extension for file
	PUSHJ P,UPSTA0		;append complete stats to one file
	MOVE B,STATSU		;ptr to beginning of summary line
	MOVEI B,1(B)		;summary starts in a new word
	POP P,A			;length of complete stats
	SUB A,STATSU		;adjust for late start of summary stats
	MOVEI A,STATBF-1(A)	;length of summary, in words
	MOVSI X,'LST'		;extension for stats file
	PUSHJ P,UPSTA0		;append summary stats to one file
	RELEAS STATCH,		;allow stats to be peeked at
	POPJ P,

;Here upon LOOKUP or ENTER error.
UPSTEE:	TRZN X,-1		;non-existent file?
	JRST UPSNEW		;yes, create it
	ADD X,[1,,0]		;no, increment the extension
;Extend stats file.  Extension is in X.
UPSTA0:	CLOSE STATCH,		;make sure no file open
	MOVE W,['STATS ']	;filename (extension already in X)
	MOVEI Y,0
	MOVE Z,DUMPER		;PPN
	LOOKUP STATCH,W		;find the existing statistics file
	 JRST UPSTEE		;failed, increment extension
UPSNEW:	MOVE W,['STATS ']	;filename (extension already in X)
	MOVEI Y,0
	MOVE Z,DUMPER		;PPN
	ENTER STATCH,W		;Read-Alter mode
	 JRST UPSTEE		;failed, increment extension
	UGETF STATCH,W		;get new record at end of file
	MOVN A,A		;negative count of words to write
	MOVSI A,(A)		;neg count in LH
	HRRI A,-1(B)		;IOWD in A
	MOVEI B,0
	OUTPUT STATCH,A		;write new stuff
	CLOSE STATCH,		;all done
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   subttl	end of file - list of needed features, bugs, etc ; DART$ DART$

COMMENT `

INTERESTING ROUTINES:

FIXPDU is place to patch when restarting a P dump after first tape, to make
sure that all files dumped in the aborted dump get re-dumped in the re-take.

MMREAD has code to flush T tapes beyond biggest T tape number (NTTAPE)
when you have just reduced that number.  When you increase NTTAPE, no
special handling is needed.


FEATURES STILL NEEDED.

0. bug: if ALLDIR.DAT winds up alone on a tape, the old DAT info about
	that tape fails to be invalidated.
     08/01/76 EJG - FIXED.

1. MRESTO COMMAND
2. SWITCHES IN COMMANDS

3. NO? ALLDIR FOR EACH STRUCTURE SHOULD BE DUMPED AFTER ALL STRUCTURES,
	NOT AFTER EACH STRUCTURE.
4. POSITION COMMAND
7. Feature to expunge dump info for a user, a file, etc?
8. Make DART.MEM and Xnnnnn.DAT one file to eliminate lookups/enters
     08/01/76 EJG - SUPERSEDED : Xnnnnn.DAT eliminated.
9. Maintain ALLDIR.DAT with read/alter constantly, use update rtrv uuo.
     08/01/76 EJG - DONE : ALLDIR.DAT info starts out in ALLDIR.MEM, using R/A.
10. At beginning of dump ALLDIR.OLD_ALLDIR.DAT (if it exists). write
	ALLDIR.TMP.  solves problem of restarting dump clobbers OLD
     08/01/76 EJG - DONE : ALLDIR.DAT renamed to ALLDIR.OLD at end of dump.
11. Don't make Xnnnnn.DAT for each tape.  Make only one merge at
	end of dump, after dumping alldir.dat.
     08/01/76 EJG - DONE.
12. More error recovery features for system-class dumps.
	0. Feature to restart a tape (if it gets munged)
	1. no eot mark - better way than hack using HELPER
	2. pickup fails to correct tape position.
	3. Able to restart an entire tape.
13. ARCHIVE command should run faster.  Increase (dump mode) buffer sizes.
14. System-class dumps: speed up with info in new 16-word UFD entries,
	instead of using extra DSKOPS to read retrieval.
     02/10/78 EJG - DONE.

26-Jan-78  1155	TED  	DART FEATURES AND BUGS  
Make PICKUP at least give up if it can't position the tape.
TAPE ID IN FOOTAGE HEADER
ILL UUO AFTER INIT FAILURE - "Start" after "Can't init xxx"ILLUUO
<ESC>I INTERRUPTION
LOGICAL DEVICE "MTA" FEATURE
/Q IN COMMAND LINE
GOOD LUCK

22-Feb-78  1047	TED  	you're gonna hate me for this
I just thought of another feature I would like to have in dart (i can hear the
groan).  I would like a beep when Dart wants a new tape.  This will save me
having to keep looking at it if I am responsible for the terminal.  Sounds
easy.  Next recompile will be soon enough.   -TED

31-Jul-78  1544	BH  	more dart stuff
- If a file is bigger than a magtape, don't even try to dump it.

22-Aug-78  2303	BH  	I know you're not working on DART but
it might be nice if a system-class dump put something like "37/854 UFDs"
on the third line along with the tape position stuff.  I guess that isn't
a very precise indicator of how much you have left to do but it's the
easiest thing I can think of offhand.


06-Sep-79	  ME&EJG	Re-starting a dump at beginning of current tape
Here is how you try to restart the current tape of the dump at the
beginning of that tape, for instance if the tape broke in the middle
or the drive wasn't writing correctly for that tape only.
(To restart from the first tape of a dump, you should just delete the
two .MEM files and start the dump over (TDUMP or PDUMP), since the
procedure below won't work to restart the first tape of a dump.)

.r dart

*dd
(DDT.  Return with CPOPJ$G)

DART$:	
helppn/	0	$"/dmpsys/		;this is first UFD dumped on the tape
helper$g
FOUND THE DESIRED PPN.
(TERMINATION AFTER CLOSING ALL FILES)
Halt at user mumble
^C
.r dart

*dd
(DDT.  Return with CPOPJ$G)

DART$:	
pickp3-5;PICKP1+25		
PICKP1+25/	HRRZ A,MEMSAV+1	.$b	cpopj$g
*pick
$1B>>PICKP1+24	memsav chknum/	0	5
memsav luser/	TLZA Q,637163(D)	$6t;RMDSYS	$"/dmpsys/
.$6t/	DMPSYS	
memsave fuser/	TLZA Q,637163(D)	$"/dmpsys/
.$6t/	DMPSYS	
memsav ffile$6t/	REMQUE	$"/dart/	;First file in UFD eligible
memsav ffext$6t/	QUE   	$"/dat/		; to be dumped.
memsav ttbuf/	24,,25	24,,24
tapno/	25	24
memsav tapnum/	25	24
tapnam[	642020,,202221	$6t;T00021	$"/T00020/
$b	$p

Mount tape number T00021 and type GO<return>, or type P/T<num> <return>: go
Using tape number T00021
DART   DAT   DMP,SYS
DART   TAP   DMP,SYS
...

end of comment `


IFE UDPSW,<
	END	START		;IF NO UDP, END OF PROGRAM
>;IFE UDPSW
	PAGE
	SUBTTL	R. P. HELLIWELL'S UDP ROUTINES
	.INSERT	UDP[CSP,SYS]
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         